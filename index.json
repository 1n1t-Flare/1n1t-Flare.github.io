[{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/","section":"1n1t-Flare Blog","summary":"","title":"1n1t-Flare Blog","type":"page"},{"content":" HardSignin # 查到了UPX壳，发现是魔改过的，不能直接脱。在010editor中看到upx壳的节区名UPX被改了，改回来后可以直接脱壳。\n32位程序，进行反汇编，又看到很多花指令。主要在TlsCallback的几个函数里面，而且这几个函数本身也常用来反调试。\n先patch掉所以花指令。但是发现main函数依然不能正常反汇编成指令。这里猜测可能有SMC代码自解密。查看TlsCallback_0，能够看到它把main函数的前170个字节异或了0x66加密。用idaPython脚本解密一下。\nimport idc import idaapi import idautils def smc_xorenc(src_addr,dst_addr,key): length = (dst_addr-src_addr) if (dst_addr\u0026gt;src_addr) else 0 for offset in range(length): addr = src_addr + offset value = idc.get_wide_byte(addr) enc_value = value^key ida_bytes.patch_byte(addr,enc_value) if __name__ == \u0026#34;__main__\u0026#34;: smc_xorenc(0x401890,0x401890+170,0x66) 之后重新建立main函数，F5查看伪码。除了常规的输入输出，加密函数是sub_4016B0。\n继续跟踪该函数，分析加密流程：先对输入进行一次base64，之后每8位进行一次RC4（16轮），最后进行一次TEA。后面两次加密的key在TlsCallback_2中用随机数生成，种子已知。在TlsCallback_1 中发现base64的编码表被打乱了顺序。属于魔改的base64。\n编写脚本进行解密。思路是先还原编码表。之后解密TEA和RC4，得到编码后的字符串。在Cyberchef上进行最后的解码。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void TEAdecrypt(int a1, unsigned char* a2, unsigned char* a3) { for (int i = 0; i \u0026lt; 16; i += 2) { unsigned int v7 = *(unsigned int*)(a2 + 4 * i); unsigned int v6 = *(unsigned int*)(a2 + 4 * i + 4); int v5 = 0x9E3779B9 * a1; // 0x9E3779B9 是 1640531527 for (int j = 0; j \u0026lt; a1; ++j) { v6 -= ((v7 + ((v7 \u0026gt;\u0026gt; 5) ^ (v7 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * ((v5 \u0026gt;\u0026gt; 11) \u0026amp; 3)))); v5 -= 0x9E3779B9; v7 -= ((v6 + ((v6 \u0026gt;\u0026gt; 5) ^ (v6 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * (v5 \u0026amp; 3)))); } *(unsigned int*)(a2 + 4 * i) = v7; *(unsigned int*)(a2 + 4 * i + 4) = v6; } } void RC4decrypt(unsigned char *a1,int a2,unsigned char *key,int length) { unsigned char s_box[256],v6[256],temp,t; for ( int i = 0; i \u0026lt; 256; ++i ) s_box[i] = i; for ( int j = 0; j \u0026lt; 256; ++j ) { v6[j] = key[j % length]; } int v4 = 0, v1 = 0, v2 = 0; for ( int k = 0; k \u0026lt; 256; ++k ) { v4 = (v6[k] + v4 + s_box[k]) % 256; temp = s_box[k]; s_box[k] = s_box[v4]; s_box[v4] = temp; } for ( int m = 0; m \u0026lt; a2; ++m) { v1 = (v1 + 1) % 256; v2 = (v2 + s_box[v1]) % 256; t = s_box[v1]; s_box[v1] = s_box[v2]; s_box[v2] = t; a1[m] ^= s_box[(s_box[v1] + s_box[v2]) % 256]; } } char table[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; unsigned char data[] = { 0x59, 0x1B, 0xFD, 0xB4, 0x6B, 0xB8, 0xBE, 0xD9, 0xB3, 0xD3, 0x77, 0xD6, 0xF0, 0x65, 0x5F, 0x18, 0xA0, 0x9D, 0x3A, 0x53, 0x6D, 0x4A, 0x7B, 0x26, 0x74, 0x3A, 0x9C, 0x4E, 0x20, 0x43, 0x19, 0xD8, 0x72, 0xED, 0x95, 0xB5, 0x9C, 0x05, 0x22, 0x56, 0xCB, 0x7A, 0x11, 0x91, 0x9F, 0x7A, 0xBC, 0x0C, 0x4A, 0x69, 0x6D, 0xCE, 0x3D, 0xB4, 0xAB, 0x29, 0x61, 0xFA, 0x62, 0x32, 0xB4, 0xEC, 0x4C, 0xB6 }; int main() { srand(0x114514u); int v6,v4; unsigned char key1[17],key2[17]; for ( int i = 0; i \u0026lt; 100; ++i ) { v6 = rand() % 64; v4 = rand() % 64; char temp = table[v6]; table[v6] = table[v4]; table[v4] = temp; } printf(\u0026#34;%s\\n\u0026#34;,table); srand(0x1919810u); for (int i = 0; i\u0026lt;0x10; ++i ) { key1[i] = rand() % 255; key2[i] = rand() % 255; } TEAdecrypt(0x64,data,key2); RC4decrypt(data,64,key1,0x10); printf(\u0026#34;%s\u0026#34;,data); return 0; } //4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9 //C+vFCnHRGPghbmyQMXvFMRNd7fNCG8jcU+jcbnjRJTj2GTCOGUvgtOS0CTge7fNs02@ snack ( 复现 ) # 一个贪吃蛇游戏。运行发现是用pygame开发的，推测程序是python打包的。使用pyinstxtractor解包。\n这里的解包实际上不算成功。由于游戏程序的python版本和本地版本不符，所以pyz没有解压而是直接跳过。复现到后面发现需要用到 pyz_extracted 里面的库。这里更换python版本重新解包。\n之后尝试用uncompyle6进行反编译，但是出了问题。一开始怀疑pyc文件里有花指令一类的，后面换成了pycdc引擎结果成功了。估计问题还是在版本上\n反编译后的代码不多，加密逻辑是魔改的RC4，而且程序本身就有解密代码，直接copy下来用。(反编译生成的代码语法有一点小问题，s盒的交换还有后面列表推导式不能直接运行，需要改一下)\n解密密钥在自定义的库key中，这个就是上面提到的 pyz_extracted目录下的 key.pyc，反编译就能看到key\nkey_bytes = b\u0026#34;V3rY_v3Ry_Ez\u0026#34; def initialize(key): key_length = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % key_length]) % 256 S[i],S[j] = S[j],S[i] return S def generate_key_stream(S, length): i = 0 j = 0 key_stream = [] for _ in range(length): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i],S[j] = S[j],S[i] key_stream.append(S[(S[i] + S[j]) % 256]) return key_stream def decrypt(data, key): S = initialize(key) key_stream = generate_key_stream(S, len(data)) decrypted_data = [ i ^ data[i] ^ key_stream[i] for i in range(len(data))] return decrypted_data data = [101,97,39,125,218,172,205,3,235,195,72,125,89,130,103,213, 120,227,193,67,174,71,162,248,244,12,238,92,160,203,185,155] decrypted_data = decrypt(bytes(data), key_bytes) print(bytes(decrypted_data)) BEDTEA ( 复现 ) # 反编译main函数的加密部分，先发现了两个反调试：一个是常规的IsDebuggerPresent() 调用API，结果保存到dword_404010，和后面加密过程有关系；另一个是用时间戳，两次调用system_clock::now 判断间隔时间。二者都可以在动调时改寄存器绕过。\n跟踪输入v15，定位到sub_401E80。跟进分析，函数分成两个部分：先修改程序的一段数据作为密钥（参考官方wp，算法是斐波那契）；后面是魔改的TEA，左移右移、delta还有轮数都改了。反编译的结果不太好分析，从汇编看比较清晰。生成密钥的初始值就是第一次反调试时得到的dword_404010。\n回到主函数，sub_401770和sub_401560两个函数这里踩了坑。一开始以为是没有实际功能的库函数一类的，看了官方wp才知道是二叉树的前序遍历和后序遍历。其实看到输入v17参数传进去，就应该猜到是加密的一部分。这里是把加密数据逆序了。\n后面调用了SSE指令集的xor指令，还额外多异或了一些无关数据。xor的值是固定的，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; void tea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3449b8, number = 0x987e55d0; for (int i = 0; i \u0026lt; 22; i++) { d2 -= ((d1\u0026lt;\u0026lt;5) + key[2]) ^ ((d1\u0026gt;\u0026gt;4) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;5) + key[0]) ^ ((d2\u0026gt;\u0026gt;4) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } int main() { unsigned int key[] = {3,5,8,13}, key2[] = {21,34,55,89}, key3[] = {144,233,377,610}; unsigned char datac[] ={ 0x76, 0x71, 0x9D, 0xE7, 0x70, 0x77, 0x3F, 0xA3, 0x02, 0xF1, 0x8D, 0xC9, 0x02, 0xC6, 0xA2, 0x4B, 0xBA, 0x19, 0x56, 0x05, 0xF2, 0x89, 0x5E, 0xE0 }; unsigned char *fd = datac,*bd = datac+23 ,tmp; for(int i = 0; i \u0026lt; 24; i ++) { datac[i] ^= 0x33; } while(fd \u0026lt; bd) { tmp = *fd; *(fd++) = *bd; *(bd--) = tmp; } unsigned int *data = (unsigned int *)datac; tea_decry(data, key); tea_decry(data+2, key2); tea_decry(data+4, key3); printf(\u0026#34;%s\\n\u0026#34;,(char*)data); return 0; } ","date":"2024-08-04","externalUrl":null,"permalink":"/writeups/ichunqiu_summer2024_re/","section":"Writeups","summary":"reverse writeup of cqb-summer 2024","title":"2024春秋杯网络安全联赛夏季赛 Reverse","type":"writeups"},{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/tags/reverse/","section":"Tags","summary":"","title":"Reverse","type":"tags"},{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"题目难度很友好，也借此拿下第一次ak，值得纪念\n编码喵 # 魔改的Base64，反编译看main函数比较乱，但是发现了一个重要的函数_text_72(),跟踪发现了一串特征鲜明的Base64编码表。\n之后在主函数也能找到编码后的密文，用cyberchef解密即可。\nezrc4 # 签到题，原汁原味的RC4，程序中能找到加密后的密文和key。\n唯一需要注意的是key是被xor加密过的，具体算法在函数X_X()中，把key解密后再对RC4解密。\nkey0=\u0026#34;fenkey?\u0026#34; key1=[0x0A, 0x0C, 0x1A, 0x08, 0x11, 0x1F, 0x1E] flag=[] enc=[0xd5,0xb2,0x7c,0xdc,0x90,0xa2,0x6e,0x60,0x6,0x13,0xe4,0x71,0x59,0xb0,0x90,0x31,0xb2,0xc7,0x1d,0xd7,0x7f] key = [chr(ord(key0[i])^key1[i]) for i in range(len(key0))] s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] i = j = 0 for s in enc: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] flag.append(s^k) print(bytes(flag)) ezpython！！！！！ # python的exe文件。用pyinstxtractor先分离出pyc文件。之后进行反编译。由于python版本问题，本地的uncompyle6引擎失效，所以找了在线的pycdc引擎进行反编译。\n查看py源码，导入了Litctfbase64库，然后对程序中的密文字符串进行解码并且作为flag输出。为了分析魔改Base64的具体算法，需要继续查看这个库的源码，位置在pyinstxtractor文件夹下的 .\\ezpy.exe_extracted\\PYZ-00.pyz_extracted\\Litctfbase64.pyc\n反编译就能看到编码表，在Cyberchef解码拿flag。\nhello_upx # 题目已经提示了是upx壳，用upx -d命令脱壳出现问题。后来在DIE中发现壳是魔改过的，而且程序是64位。\n利用x64dbg和Scylla进行手动脱壳。由于第一次手脱，部分思路参考：借助 x64dbg 的 UPX 手工脱壳。\n首先动调找到OEP。查看断点窗口中的入口断点，多次运行直到RIP指向入口处，该程序是在0x44FF70。根据esp定律，经过pushad和popad后，OEP处的栈顶和现在入口处的栈顶地址是相同的。所以需要在esp指向的内存地址处下一个硬件断点。(寄存器窗口空白处右键)\n继续运行至该断点，可以看到刚好是在一系列pop（popad）后面，单步跳过至一个大的跳转指令处，跳转后的地址即为OEP。\n接下来要用Scylla进行dump脱壳，直接使用 IAT Autosearch 功能，期间可能会提示使用 IAT Search Advanced ，选 “是” 继续。然后 Get Imports ，最后直接 Dump 。保存成新的exe文件。\n算法部分比较简单，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; int main() { unsigned long long v4[3]; v4[0] = 0x707541504072684C; v4[1] = 0x655158612559632B; v4[2] = 0x4F5E4E601E5A4E20; unsigned char *data = (unsigned char *)v4; char flag[40]={0}; for (int i=0;i\u0026lt;=24;++i) { flag[i] = (char)(data[i]+i); } printf(\u0026#34;%s\u0026#34;,flag); return 0; } ","date":"2024-06-01","externalUrl":null,"permalink":"/writeups/litctf2024_re/","section":"Writeups","summary":"reverse writeup of LitCTF(NSS) 2024","title":"LitCTF2024 Reverse","type":"writeups"},{"content":"nothing here\n","date":"2024-02-01","externalUrl":null,"permalink":"/docs/","section":"1n1t-Flare Blog","summary":"","title":"docs","type":"page"},{"content":" Week1 # 数字筑基 # 在IDA中打开文件，一眼flag。\n代码金丹 # IDA打开即送 +1\n网络元婴 # IDA打开即送 +2。\t从上到下输入即可。\n虚拟化神 # 反编译程序，在main函数中找到关键变量v13。它的值没有明确给出，而且后续一系列的xor操作都和它有关系，所以通过动态调试找到内存中的值。实际上就是flag。\n另一方面，如果不调试。按照官方wp的提示，这个程序会生成一个文件config.txt。之后根据其内容判断是否输出v13的内容。具体的逻辑是提取config.txt的前两个字符，转换为整数并与1比较。这里直接修改该文件，把0改成1，之后运行程序就能拿到flag。\n赛博天尊 # 分析程序逻辑：do...while部分判断输入Buffer的长度，要求长度为44。其中最后一个字符为}（ascii 125），接下来以-为分隔符将flag内部32位十六进制数拆分成五部分，各部分满足方程组。\n核心在于解方程组，这里尝试了两种方法。\n用 sympy 库求解 #python from sympy import * v7,v8,v9,v10,v11=symbols(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) equations=[Eq(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) , 0x12021DE669FC2), Eq( v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) , 0x159BFFC17D045), Eq(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) , 0xACE320D12501), Eq(v8 + 2 * (v7 + v11 + v9 + 2 * v10) , 0x733FFEB3A4FA), Eq(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 , 0x1935EBA54EB28)] solution = solve(equations) solution = sorted(solution.items(), key=lambda item:int(str(item[0])[1:])) hexs=[] for value in solution: hexs.append(hex(value[1])[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) 用 z3 模块求解\nz3求解出来的结果是z3.RatNumRef类型的，不是内置类型。需要转换为int型。此外要先用Solver.check()判断解的情况，才能调用 Solver.model() 输出解。\n#python from z3 import * v7,v8,v9,v10,v11=Reals(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) s=Solver() s.add(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) == 0x12021DE669FC2) s.add(v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) == 0x159BFFC17D045) s.add(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) == 0xACE320D12501) s.add(v8 + 2 * (v7 + v11 + v9 + 2 * v10) == 0x733FFEB3A4FA) s.add(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 == 0x1935EBA54EB28) hexs=[] if isinstance(s.check(), CheckSatResult): result=s.model() for var in (v7,v8,v9,v10,v11): num = result[var].as_long() hexs.append(hex(num)[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) Week2 # 符文解密师 # 32位程序，IDA打开，在hex窗口找到flag\n编译逆旅者 # 文件后缀为.pyc可知是编译过的python程序。鉴于IDA反编译后的结果是C伪代码，并不能得到源python代码。于是考虑在线python反编译。\n在main()函数中找到flag的十六进制形式。粘贴(ctrl+shift+v)到十六进制编辑器010Editor中得到flag。\n码海舵师 # 32位IDA打开，F5反编译代码如下：\n在21行位置发现可疑的一串乱码，末尾‘=’盲猜是base64，在线解密。\n注册侦探 # 反编译main函数，发现是c++程序，而且调用了很多API函数。分析程序逻辑后发现flag是在一系列判断之后生成并且输出的，所以尝试动态调试。刚开始不知道RegOpenKeyExA,RegQueryValueExA这两个函数的功能，也没有去查。当时思路是修改寄存器的返回值，绕过这两个函数，但在动调过程中发现无法改data的值。所以最后flag没有生成。\n换一种思路，在输出时数据经过了0x33的异或，那么数据是怎么来的？一点点往回找发现和Src变量有关，而且函数中有Src数组的全部值。尝试了一下把Src[0]逐字节异或0x33，结果是0xGa，和flag正好对应。说明就是单字节异或，写脚本解密就得到flag。\n#python \u0026#39;\u0026#39;\u0026#39; Src[0] = 1383353091; Src[1] = 189290078; Src[2] = 38864395; Src[3] = 503515984; Src[4] = 1364350722; Src[5] = 1448105758; Src[6] = 89136641; Src[7] = 85852241; Src[8] = 72812293; Src[9] = 50464516; Src[10] = 1314325334; \u0026#39;\u0026#39;\u0026#39; Src=[1383353091, 189290078, 38864395, 503515984, 1364350722, 1448105758, 89136641, 85852241, 72812293, 50464516, 1314325334] flag=bytes() for num in Src: byte=num.to_bytes(4,\u0026#39;little\u0026#39;) for i in byte: flag+=(i^0x33).to_bytes(1) print(flag.decode()) #0xGame{885b1c80-1dab-dce2-c6b3-664d77410e0d} 看了官方wp，还是从RegOpenKeyExA,RegQueryValueExA入手，创建注册表值，之后运行程序得到flag\n壳艺大师 # 在DIE里查壳发现有upx壳，先进行脱壳。\n程序反编译后整体看上去有点复杂，涉及到很多未知函数。跟踪这些函数，发现大多数没有什么实际用处，感觉像是用来混淆的，暂且忽略它们。核心的判断部分也比较抽象，v7，v8等变量都对应寄存器的值，并不在内存中。缺少关键值，仅凭静态调试梳理不出完整的逻辑。但能看出和异或有关。\n动调也显得繁琐，涉及寄存器的变量还是很多的。（不知道是不是脱壳的原因）\n既然分析不出明确的逻辑，那就猜一下吧。main函数中依然有一系列的数组赋值语句，和上一题非常相似。推测还是对这些数据异或求flag。最开始分析string的时候发现的'The0xGameKey'应该是密钥，循环异或。\n#python from pwn import * src=[0x64, 0x10, 0x22, 0x51, 0x15, 0x22, 0x1A, 0x0F, 0x06, 0x7C, 0x01, 0x18, 0x6C, 0x0A, 0x56, 0x1D, 0x4B, 0x7E, 0x57, 0x08, 0x48, 0x28, 0x51, 0x4C, 0x60, 0x45, 0x07, 0x53, 0x1E, 0x77, 0x4C, 0x5E, 0x5D, 0x7B, 0x53, 0x4F, 0x61, 0x59, 0x07, 0x52, 0x1C, 0x74, 0x07, 0x10] flag=xor(bytes(src),b\u0026#39;The0xGameKey\u0026#39;) print(flag) #b\u0026#39;0xGame{bc7da8b3-396e-c454-bcf0-3806651bbd3f}\u0026#39; Week3 # 代码启示录 # 打开发现是.jar文件，在本地安装JDK来配置Java环境。用反编译器GDA打开文件，一眼flag。\n旋转密码城 # 同上GDA打开，Main类中定义了CaesarPlus() 函数，不难发现是变种的凯撒密码。把密码移位的范围从字母扩大到了ASCII可打印字符的范围。密文在main()主函数中给出。编写python脚本解密：\nenc=\u0026#34;_Iv2\u0026gt;6L424c_4c2\\\\f__5\\\\7fec\\\\da32\\\\3ef2`cgd4b46N\u0026#34; flag=\u0026#39;\u0026#39; for char in enc: index=ord(char) result=index-33-47 if result\u0026lt;0: result+=94 flag+=chr(result+33) print(flag) 变量迷城 # 对Java，android逆向都不太熟悉，拿着反编译代码问了几次GPT。勉强理清了主要的逻辑。\n程序只有一个Main类，直接给了decryptFlag解密函数，能看出来还是循环异或。下面的lambda$static$0函数给出了关于x和y的方程组，可以解出x和y。brand变量也已知是'0xGame'\n#python from z3 import * x,y = Reals(\u0026#39;x y\u0026#39;) s=Solver() s.add(x**2+2*y**2+3*x+4*y == 7384462351178) s.add(5*x**2+6*y**2+7*x+8*y == 22179606057658) print(s.model()) #[y = 1919810, x = 114514] main()的末尾调用解密函数，能看出密钥是x和brand拼接的字符串。但是整个程序并没有给出原始数据，所以不能写脚本解密了。试一下运行程序，但是另一个问题是，程序从头到尾没有任何输入，我们只能等它自己生成flag然后输出。\n结合上网搜索和wp，System.getenv，System.getProperty这两个函数比较关键，提示要创建环境变量和 JVM变量。在命令行中进行设置即可，最后运行jar程序得到flag。\nSystem.getenv()读取的是当前系统环境的环境变量。可以通过 System.getEnv(key) 获取对应环境变量的值。\n通过 System.getProperty(key)获取单个变量值，通过System.getPropertys() 获取所有 JVM 环境变量值。\n启动JVM时，可以通过 -D 设置JVM 环境变量值\n之前一直认为逆向题的flag都是输入到程序的正确字符串，其实是陷入思维定式了。这几周的一些题不是简单地判断输入，而是检查系统的文件或者是变量，还是很打开眼界的。最后还踩了坑：参考wp在cmd敲了命令，结果报错。发现是多了不必要的空格。用powershell试了试发现这段命令不能正常运行。powershell里面set命令不能修改环境变量，要用set-item。\n(cmd.exe) set x=114514 set y=1919810 java -Dbrand=0xGame -jar \u0026#34;C:\\Users\\LENOVO\\Desktop\\变量迷城.jar\u0026#34; 数字幽灵城 # 反编译程序，看到有一个Base58类，说明这道题用到Base58算法。之前对Base64接触比较多，对于Base58不是很了解。于是上网查了一下原理。\nbase58加密与其他base系列不同的是： base64是每6bit位一个映射，base32是每5bit位一个映射 base58不是根据bit位而来，而是直接模58而映射的\n其算法很简单 就是将字符流转成256进制的一个超大数 然后不断的模58 最后得到的结果逆序即是结果\n分析一下decode函数，就是模58的逆运算，能确定是正常的Base58，没有魔改。接下来分析MainActivity类，内部对编码后的flag，也就是变量C0587R.string.encodedFlag进行解码，再和用户输入的flag比对。我们将经过编码的flag提取出来手动解码即可。查找encodedFlag，应该在资源文件里。\nRmC442S4tDMzc3CvzoCx8toKodL8SE8GRQSmz8M84k6g9jG1vVrf3c5TECZR 复制下来拿工具解码即可。大部分在线工具的Base58编码表都是按照比特币的标准，数字在前，之后是大写字母和小写字母。和本题程序的编码表不一样，所以在cyberchef换一下表，进行解码。\n虚构核心 # 用jadx反编译程序，核心的函数都在MainActivity类里面。onClick函数调用checkFlag函数进行判断。继续分析checkFlag函数，发现还需要调用FlagCheker类的checkFlag方法。在反编译的结果里面没找到这个类，推测应该和encrypted.dex有关，但是需要解密出decrypted.dex。程序最后给出了解密函数，和密钥The0xGameKey逐字节异或。\n内置的加密文件不能在jadx里直接打开，也没找到直接导出的方法。将整个.apk文件重命名为.zip后缀的压缩包，解压后在 assets\\目录下找到了encrypted.dex。按照decrypt函数的逻辑手动解密。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { unsigned char key[] = \u0026#34;The0xGameKey\u0026#34;; FILE *encdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\encrypted.dex\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *decdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\decrypted.dex\u0026#34;,\u0026#34;wb+\u0026#34;); unsigned char buf[16]; while (!feof(encdex)) { memset(buf,0,16); fread(buf,sizeof(char),12,encdex); for(int i=0; i\u0026lt;12; i++) { buf[i] ^= key[i]; } fwrite(buf,sizeof(char),12,decdex); } fclose(encdex); fclose(decdex); return 0; } 在010Editor中把解密文件最后面多出的一段删掉，之后用jadx反编译即可。在官方wp给的cmd5网站上查出3段md5的明文，最后各部分拼在一起得到flag\nWeek4 # 二进制学徒 # 在线反编译.pyc文件，直接看到flag\n代码悟道者 # 程序是一个.jar文件。反编译后发现main函数比较清晰，调用加密函数并将结果与内置的密文比较。而且给出了加密算法的具体信息即custom Base64，考虑到换表，用自定义解密工具进行解密得到flag。（这道题挺直白的没什么坑）\n回过头来分析（学习）一下程序中的Base64算法：先把输入的明文字符串转换为字节，每三个字节以二进制的形式拼接，再按6bit拆成4个字节。其中对二进制数据的处理没有采用数组，而是直接进行位运算，通过移位后或运算/移位后与运算实现了拼接和截取，很简洁高效。（和NSSRound18 的那道Base64对比了一下，但那题还要交换特定的bit）\n这里移位时右操作数为负，网上搜索发现结果未定义，根据整体功能猜测符号正负不影响移位结果。\n(摘自oi-wiki) 移位运算中如果出现如下情况，则其行为未定义：\n右操作数（即移位数）为负值； 右操作数大于等于左操作数的位数； 内存星旅者 # 首先静态分析，main函数不算复杂。可以看到比较核心的部分，其中包含两个函数 sub_7FF630D51510 和sub_7FF630D51600。二者还有同样的int型参数v6。\n进一步分析，第二个函数可能与生成flag有关。跟踪该函数，发现其内部有点乱，调用了一大堆未知的函数，但是有两个确定的API函数（GetTempPathA，DeleteFileA，可以上网查到功能）。大概猜测flag被写入一个临时文件，而且最后会删除这个文件。\n第一个函数也比较乱，我们的任务是让它的返回值不为0。最好同时能推出v6的值。这个函数需要命令行参数，但是很难从程序反编译的代码中推断该输入什么。复现的时候卡在这里了很久。最后也不去管这些参数了，采用动态调试直接修改寄存器的值，让rdi的最后一位不是零即可。v6的值还不能完全确定，根据官方wp发现其实是函数后面的1897488这个数（其实挺明显的，当时没想到\n同样按照动态调试修改寄存器的思路，F7进入第二个函数内部，把传入参数的ecx寄存器的值改为1897488（0x001CF410）。\n在DeleteFileA之前打一个断点，运行后就直接去找临时文件。在 C:\\Users\\LENOVO\\AppData\\Local\\Temp里找到了刚生成的文件，名字就叫flag。用记事本打开即可。\n指令神使 # 反编译main函数，发现整体逻辑还算清晰。先把unk_一类的数据恢复为字符串，然后分析程序。输入的flag保存在Str中，再对Str1分别调用sub_140001154和sub_140001118函数，最后与Str2比较。\n跟踪这两个函数，第一个就是简单地判断flag的格式。第二个函数进行加密，是题目的关键。不难看出是针对小写字母的rot13。（看到97，26就猜测和字母表有关系，可能是移位密码，比如摩斯之类的，再根据84推偏移量）最后用CyberChef解一下。把前缀补全。\n还注意到题目里的一个细节，反编译后的代码没有Str1的赋值语句，但是直接就对它调用函数。而且储存flag的Str数组长度至少是44，但声明部分 char Str[7];，显然会溢出。于是在栈窗口中查找这两个变量，发现它们是相连的，地址上刚好相差0x7，也就是说Str1储存的是Str溢出的内容。或者说Str1是指向Str+7的指针，这样也能解释为什么Str1能与Str2字符串的格式相对应。\n算法祭司 # 程序放到DIE里面查看是.NET32位程序，用dnSpy进行反编译，分析Main类。最开始对encryptedKey进行逐字节异或解密。之后读取用户输入，利用异或后的key做密钥，encryptedKey作为初始向量对其进行DES加密。\nMain类中直接给出了DES加密后的Base64编码结果。在资源文件中可以找到encryptedKey，进行异或得到密钥。最后写脚本解密DES即可。\n#python import base64 from Crypto.Cipher import DES encryptedkey=\u0026#34;STV\u0026gt;!\u0026#39;+#\u0026#34; key=\u0026#39;\u0026#39; result=\u0026#39;s7/e+JnJbGEdE9j2g3XHxgym+G6Fu/PjJuW80NeMKgemdqaWG9KVM8Tfcc0eRfaA\u0026#39; for c in encryptedkey: key+=chr(ord(c)^ord(\u0026#39;f\u0026#39;)) des=DES.new(key.encode(),DES.MODE_CBC,iv=encryptedkey.encode()) enc=base64.b64decode(result) flag=des.decrypt(enc) print(flag) #b\u0026#39;0xGame{8edf2e65-1cb3-2e1a-b2d1-b54d3d4bddc5}\\x04\\x04\\x04\\x04 ","date":"2024-01-02","externalUrl":null,"permalink":"/writeups/0xgame2023_re/","section":"Writeups","summary":"reverse writeup of 0xgame2023","title":"0xGame2023 Reverse","type":"writeups"},{"content":" Week1 # What\u0026rsquo;s CBC? # 查询资料知CBC是一种分组加密算法。把明文分为等长的几组，用初始化向量对第一组明文进行xor运算，再进行另一种加密得到第一组密文。接下来用第一组密文作为向量加密第二组明文……依次类推。\n注意到xor运算(⊕)的特殊性质： $$ A⊕0=A $$\n$$ A⊕A=0 $$\n如果两数xor后，对结果再xor这两个数中的一个，可以得到其中另一个数。 $$ (A⊕B)⊕B=A⊕(B⊕B)=A⊕0=A $$ 这样一来，解密就方便很多。但是最后的加密函数encrypt()中出现了未知的密钥key，所以首先要解出key。\n从 i ^ key 推测key是一个数而非bytes类型，而且对每一个i都进行了异或运算，理论上只要知道一个i就可以反推出来 (i ^ key ^i) 。我们已知flag的前七位是标准的 '0xGame{' 格式，题中每组明文或密文均为八位，于是再随便补一个字母凑成第一组明文，与iv异或后推key。\nfrom Crypto.Util.number import * f=b\u0026#39;0xGame{a\u0026#39; iv = b\u0026#39;11111111\u0026#39; enc=b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) k=bytes_xor(f,iv) for i in range(8): key=enc[i]^k[i] print(key) \u0026#39;\u0026#39;\u0026#39; 143 143 143 143 143 143 143 222 \u0026#39;\u0026#39;\u0026#39; 忽略掉最后随便找的那个字母(222那个)，能得到key=143。利用xor的性质写出decrypt, Decrypt_CbC两个解密函数(与题目中的两个加密函数相对应，甚至几乎一样)，代入数据解出flag。\nfrom Crypto.Util.number import * def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) def decrypt(enc,key): result=b\u0026#39;\u0026#39; for i in enc: result += ((i^key)).to_bytes(1,\u0026#39;big\u0026#39;) return result def Decrypt_CbC(enc,iv,key): result=b\u0026#39;\u0026#39; block=[enc[k*8:(k+1)*8] for k in range(len(enc)//8)] for i in block: text = decrypt(i,key) plain = bytes_xor(iv,text) iv=i result += plain return result enc = b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; iv = b\u0026#39;11111111\u0026#39; key = 143 flag = Decrypt_CbC(enc,iv,key) print(flag) 密码，觅码，先有*再密 # 把flag切成四份，每份用不同的方法加密。只要判断出每份是如何加密，逐个击破即可。\nc1：Crypto.Util.number中的bytes_to_long()函数，把bytes转化成整数，用对应的long_to_bytes()解密。但还有个小细节，c1输出时变成自身的5次方，我们需要开五次方根还原c1。这里如果用pow(c1,0.2)会有精度的问题，所以采用gmpy2模块的iroot函数\nc2：把bytes中每个字节取二进制并连在一起，解密时等距离拆分还原为bytes\nc3：常见的base64编码，用对应的b64decode()函数\nc4：十六进制与bytes互化\n还有一个要注意的地方是flag内部是汉字，用utf-8解码\nfrom base64 import b64decode from Crypto.Util.number import* from gmpy2 import iroot c1a=2607076237872456265701394408859286660368327415582106508683648834772020887801353062171214554351749058553609022833985773083200356284531601339221590756213276590896143894954053902973407638214851164171968630602313844022016135428560081844499356672695981757804756591891049233334352061975924028218309004551 c2=\u0026#39;10010000100001101110100010100111101000111110010010111010100001101110010010111111101000011110011010000001101011111110011010011000101011111110010110100110100000101110010010111101100101011110011110111100\u0026#39; c3 = b\u0026#39;lueggeeahO+8jOmCo+S5iOW8gOWni+aIkQ==\u0026#39; c4 = \u0026#39;e4bbace79a8443727970746fe68c91e68898e590a72121217d\u0026#39; c1 = iroot(c1a,5) f1 = long_to_bytes(int(c1[0])) f = [c2[i*8:(i+1)*8] for i in range(len(c2)//8)] f2 = \u0026#39;\u0026#39;.join([hex(int(\u0026#39;0b\u0026#39;+k,base=0))[2:] for k in f]) f2=bytes.fromhex(f2) f3 = b64decode(c3) f4=bytes.fromhex(c4) flag=(f1+f2+f3+f4).decode(\u0026#39;utf-8\u0026#39;) print(flag) Take my bag! # 赛后复现补充：背包dp，动态规划，这下真手撕算法了orz\n没看出是什么加密，也没找到标准的解密方式，就当成算法题做了。\n分析一下我的思路：\n题中的加密函数把明文转为二进制并逆序处理，init是给出的一个数表，关键在init[i] * int(m[i]) % n这个表达式。我们知道二进制中只会出现0和1，相应地，表达式也只会出现两种结果：\nint(m[i]) = 0，表达式等于0\nint(m[i]) = 1，init[i] * int(m[i]) % n = init[i] % n，而init中元素已经对n取过模，不会大于n。故表达式等于init[i]\n即密文c是列表init中特定项的和，这些项的索引与得到的逆序二进制数中“1”对应。解密的思路很直接，遍历所有元素并找出和刚好为c的项，就可以反推二进制数，乃至flag。\n说起来容易，但程序如果这么实现，时间复杂度还是很高的。对思路重新优化，我们可以先把c视为若干项的和，在init中逐一找到各项并从c中减去。如果这一过程能完全进行那么c会被减到0，此时这些被减去的项就是我们要求的。按这个思路编写脚本，选取 [ c减去init某一项的剩余值，在过程不成立时表示回溯情况的偏移量，被减项的索引 ] 作为关键数据保存在栈（列表memory）中，最后剩余值=0时就可以从栈中得到各所求项的索引。（一开始没发现，后来flag交了之后想起来这有点像深度优先搜索算法?）\n接下来按照索引求出二进制数，逆序还原，再转为bytes就看到flag了。\nfrom Crypto.Util.number import * w=16221818045491479713 n=9702074289348763131102174377899883904548584105641045150269763589431293826913348632496775173099776917930517270317586740686008539085898910110442820776001061 c=4795969289572314590787467990865205548430190921556722879891721107719262822789483863742356553249935437004378475661668768893462652103739250038700528111 init = [w*pow(3, i) % n for i in range(512)] memory = [] #记录上一次操作时的[剩余值,偏移量,在init中对应的索引位置] def find(p):\t#找到在init中小于给定数p的最大元素索引 for i in range(512): if init[i]\u0026lt;=p and init[i+1]\u0026gt;p: return i if p==0: return 0 def forward(num,move,index):#保存上一次操作数据，更新偏移量=0，计算剩余值 datas=[num,move,index] memory.append(datas) move=0 return num - init[index-move] num,move,index=c,0, find(c)#初始化 while True: if num==0: break elif (num - init[index - move]\u0026gt;= init[0] or num == init[index - move]) and move\u0026lt;=index: num=forward(num,move, index) index=find(num) else: num,move,index=memory[-1] move+=1 memory.pop()\t#回溯到上一次操作，向左偏移+1 m=[\u0026#39;0\u0026#39;]*512 for k in memory: m[k[2]]=\u0026#39;1\u0026#39; m=\u0026#39;\u0026#39;.join(m)[::-1] flag=long_to_bytes(int(m,2)) print(flag) BabyRSA # RSA在密码学领域是常见的非对称加密算法，破解的难度在于从公钥推出私钥，核心是超大整数的质因数分解。\n在一般的RSA加密中，m表示明文，n是一个超大整数，e为与φ(n)互素的任意整数，(e,n)作为公钥加密明文，得到密文c。解密需要私钥(d,n)，其中d是e关于模φ(n)的乘法逆元。要从密文c中解出明文m，只需要求出n的欧拉函数，为此需要将n质因数分解。\n不同于传统的n=p*q这种只有两个质因数，本题的getN()函数直接给出了16个大质数相乘的超大数n，正常的分解因数算法肯定不好使了。在查找资料的过程中发现了名叫yafu的工具，顺利的分解了n。果然是整齐的16个质数\n这样一来，就可以利用欧拉函数的性质，把各个因数减一再全部相乘，求出φ(n)，进而得到密钥去解密\n还要注意求得的结果是m*mask，要再除以mask并用long_to_bytes()还原为字符串，才能得到正确的flag。\nfrom Crypto.Util.number import * import gmpy2 n=93099494899964317992000886585964221136368777219322402558083737546844067074234332564205970300159140111778084916162471993849233358306940868232157447540597 e = 65537 c=54352122428332145724828674757308827564883974087400720449151348825082737474080849774814293027988784740602148317713402758353653028988960687525211635107801 mask = 54257528450885974256117108479579183871895740052660152544049844968621224899247 factors=[3479527847,2864469667,3561068417,2770441151, 4134768233,3281340371,3111632101,2821163021, 3978177241,3267547559,2329990801,3162958289, 2995527113,4160088337,2732757047,2436711469] phi=1 for p in factors: phi *= (p-1) #欧拉函数 d=gmpy2.invert(e,phi) #通过乘法逆元找到私钥d m=pow(c,d,n) #解密 result=gmpy2.c_div(m,mask) flag=long_to_bytes(result) print(flag) 猜谜 # 已知部分明文攻击\n题目还蛮善良的，给出加密enc()函数的同时还送上了解密的dec()函数，对密文进行第一次解密如下:\nc = b\u0026#39;IPxYIYPYXPAn3nXX3IXA3YIAPn3xAYnYnPIIPAYYIA3nxxInXAYnIPAIxnXYYYIXIIPAXn3XYXIYAA3AXnx=\u0026#39; print(dec(c)) #b\u0026#39;gWM\\x84u\\xe4N\\x05x=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\1\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; 然而第二层加密就不好办了，又又出现了未知的key。题目的意思是把key猜出来?\n分析代码，i%7 这段给了启示。无论len(key)有多大，只有前7位能发挥作用。不妨猜key就是7位的bytes。恰好我们知道flag的前七位是标准格式 '0xGame{' ，再利用xor运算的性质反推key成功。同样用xor解出flag\nkey=b\u0026#39;\u0026#39; flag=\u0026#39;\u0026#39; flagformat=b\u0026#39;0xGame{\u0026#39; text=b\u0026#39;gWM\\x84u\\xe4N\\x05X=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\l\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; for i in range(7): key += (text[i] ^ (flagformat[i]+i)).to_bytes(1,\u0026#39;big\u0026#39;) for j in range(len(text)): flag += chr((text[j] ^ key[j%7])-j) print(flag) Vigenere # 完全没见过的加密方式，百度搜索给出的解释是“使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式”。\n直接找在线解密工具，摸索后发现解密需要密钥，而且只会对字母进行改变。查阅资料发现以下要点：\n1.明文中的所有字母都在字母表上向后偏移某个数目后被替换成密文，偏移量与密钥相对应。\n2.密钥若长度不够可以继续重复。\n现在只需要得到密钥就可以破解flag，题目没有给出密钥的任何信息（也可以暴力破解？），但结合密文：0dGmqk{79ap4i0522g0a67m6i196he52357q60f}，猜测0dGmqk与0xGame 相对应，分析各字母前后的偏移量：6，0，12，4，6。对应g,a,m,e,g ,考虑到密钥的可重复性，取game作为密钥（看起来很靠谱），放到网站解密得到flag。\nWeek2 # EzLFSR # LFSR，又是很陌生的算法。\n查了好几天资料，大概理解的差不多了。作为流密码的关键成分，LSFR也就是线性反馈移位寄存器，能够不断输出随机而长周期的序列。由此它可以作为流密钥产生器的线性驱动部分。寄存器的容量有限，当其中的数据整体左(右)移一位时，最左(右)面的数会溢出（输出）而最右(左)面会留出空位。为了有持续的输出，LSFR通过某种线性反馈函数计算出一个数补到空位，依次循环，源源不断。\n题中给出了初始状态和256位输出，根据移位寄存器的原理，我们可以用initState[i:]+outputState[:i]来表示第i组状态，同时给出计算补充右边空位数字的方法lfsr()，但其中mask未知。即不完全知道LFSR的反馈函数，但已知其级数n=128。而且明文中不包括0xGame{}，不能取巧反推反馈函数。\n注意到反馈函数中有异或运算，state和mask中元素只能取0或1。可以把mask[i]理解为寄存器第i位的数是否参与到异或运算中（抽头）。用 \\(x_i\\) 表示mask[i]， \\(k_i\\) 至 \\(k_{i+127}\\) 表示第i组状态下寄存器各位数字，从数学角度可得到异或方程组： $$ \\begin{cases} \\quad k_{1}x_1\\oplus k_{2}x_2 \\oplus\\cdots\\oplus k_{128}x_{128} = k_{129} \\\\ \\quad k_{2}x_1\\oplus k_{3}x_2 \\oplus\\cdots\\oplus k_{129}x_{128} = k_{130} \\\\ \\quad k_{3}x_1\\oplus k_{4}x_2 \\oplus\\cdots\\oplus k_{130}x_{128} = k_{131} \\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots \\\\ k_{128}x_1\\oplus k_{129}x_2 \\oplus\\cdots\\oplus k_{255}x_{128} = k_{256} \\\\ \\end{cases} $$ 由于异或有“半加”的性质，用线性(加法)方程组类比异或方程组，上式等价于： $$ \\begin{cases} \\quad k_{1}x_1+ k_{2}x_2 +\\cdots+ k_{128}x_{128} \\equiv k_{129}(\\bmod2)\\\\ \\quad k_{2}x_1+ k_{3}x_2 +\\cdots+ k_{129}x_{128} \\equiv k_{130}(\\bmod2)\\\\ \\quad k_{3}x_1+ k_{4}x_2 +\\cdots+ k_{130}x_{128} \\equiv k_{131}(\\bmod2)\\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots\\\\ k_{128}x_1+ k_{129}x_2 +\\cdots+ k_{255}x_{128} \\equiv k_{256}(\\bmod2)\\\\ \\end{cases} $$ 矩阵表示为： $$ \\begin{bmatrix} k_1 \u0026amp; k_2 \u0026amp; k_3 \u0026amp; \\cdots \u0026amp; k_{128}\\\\ k_2 \u0026amp; k_3 \u0026amp; k_4 \u0026amp; \\cdots \u0026amp; k_{129}\\\\ k_3 \u0026amp; k_4 \u0026amp; k_5 \u0026amp; \\cdots \u0026amp; k_{130}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ k_{128} \u0026amp; k_{129} \u0026amp; k_{130} \u0026amp; \\cdots \u0026amp; k_{255} \\end{bmatrix}X=\\begin{bmatrix} k_{129}\\\\ k_{130}\\\\ k_{131}\\\\ \\vdots\\\\ k_{256}\\\\ \\end{bmatrix} $$ 借助软件Sage函数solve_right()，在有限环Zmod(2)中求解矩阵方程得到mask，转换为secret就可以得到flag\n#SageMath from Crypto.Util.number import * def string2bits(s): return [int(b) for b in s] def bits2string(bs): s = [str(b) for b in bs] return \u0026#39;\u0026#39;.join(s) initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0] outputState = \u0026#39;1101111111011101100001000011111101001000111000110100010011110111010011100110100100111001101010110110101110000011110101000110010010000011111111001111000110111001100111101110010100100001101001111110001010000100111101011011100010000000100000100000100111010110\u0026#39; outputState = string2bits(outputState) States_Array=[initState[i:]+outputState[:i] for i in range(128)] states=matrix(Zmod(2),States_Array) output=matrix(Zmod(2),outputState[:128]) output=output.transpose() mask=states.solve_right(output) mask=[i[0] for i in (mask)] secret=bits2string(mask) secret=long_to_bytes(int(secret,2)) flag = \u0026#39;0xGame{\u0026#39;+secret.decode(\u0026#39;utf-8\u0026#39;)+\u0026#39;}\u0026#39; print(flag) 中间的那个人 # 题目模拟了Alice和Bob两人的加密通信场景，二人使用对称加密的CBC算法。因为未事先商量好密钥，所以加密一方要想办法把密文和特殊处理的密钥一并发送给对方，这里涉及DH密钥交换算法。我们作为“中间的那个人”，通过各种方式截获了二人通信的数据如下： $$ P(A)\\equiv Alice\\equiv g^A (\\bmod\\ p) $$\n$$ P(B)\\equiv Bob\\equiv g^B(\\bmod\\ p) $$\n$$ key\\equiv P(A)^B\\equiv P(B)^A\\equiv g^{AB}(\\bmod\\ p) $$\n由数学关系我们可反推：\\(A\\equiv \\log_gP(A)\\ (\\bmod \\ p)\\) 和\\(B\\equiv \\log_gP(B)\\ \\ (\\bmod \\ p)\\)。即只需要计算其中一个离散对数，得到A或B的值，就可以计算出密钥key。\n借助SageMath计算mod 2下的离散对数：\n#SageMath p=250858685680234165065801734515633434653 G=GF(p) g=G(2) Bob=G(33067794433420687511728239091450927373) B = discrete_log(Bob,g) 再用python计算key，用题中给出的密文和初始化向量 $iv$ 解密，得到flag（其实可以放在Sage里面一步到位，但是我的Sage里面Crypto.Cipher库出了点小问题，就分开写了）\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 g=2 p= 250858685680234165065801734515633434653 Bob= 33067794433420687511728239091450927373 Alice=235866450680721760403251513646370485539 enc=b\u0026#39;s\\x04\\xbc\\x8bT6\\x846\\xd9\\xd6\\x83 y\\xaah\\xde@\\xc9\\x17\\xdc\\x04v\\x18\\xef\\xcf\\xef\\xc5\\xfd|\\x0e\\xca\\n\\xbd#\\x94{\\x8e[.\\xe8\\xe1GU\\xfa?\\xda\\x11w\u0026#39; iv = b\u0026#34;0xGame0xGameGAME\u0026#34; B = 1620639479 key = pow(Alice,B,p) key = sha256(long_to_bytes(key)).digest() aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(enc) print(flag) Week3 # EzECC # ECC 即 EllipseCurve Cryptography，是一种基于椭圆曲线的公钥密码。在数学上椭圆曲线用 $$ y^2+axy+by=x^3+cx^2+dx+e $$ 来表示，而密码学中常取\\(a=b=c=0\\),得到椭圆曲线的一般形式 $$ y^2=x^3+dx+e $$ 密码学椭圆曲线一般定义在有限域GF(p)上。定义了二元运算：点与点的加法“ + ”，包括不同点相加以及点的自加（数乘）两种情况，与题中给出的 add() 函数和 mul() 函数相对应。同时，椭圆曲线上所有点（包括无穷远点\\(O\\)）与“ + ”运算构成abel群，满足封闭性，有限次运算后的结果依然在曲线上。\n不同于数学中光滑连续的曲线，GF(p)上的椭圆曲线只包含离散而有限的整数点以及特殊的无穷远点，点的总数称为曲线的阶\\(n\\) ,若用 \\(G\\) 表示该曲线的生成元，则满足 \\(nG = O\\)。\n曲线上两点满足 \\(Q=mP\\) ,则称 \\(m\\) 为椭圆曲线的离散对数，即 \\(m=log_PQ\\) 。ECC密码体系建立在离散对数求解难题的基础上。\n根据以上性质，我们可以分析ECC的加密过程：首先接受方确定私钥 \\(k\\) 并选择椭圆曲线E(a,b)上基点 \\(G\\) ，计算出公钥 \\(K=kG\\)。将除私钥外的信息公开给发送方。发送方将明文编码成椭圆曲线上一点 \\(M\\)（但本题并没有这样做），随机选一个整数 \\(r\\) 计算出密文｛\\(M+rK,rG\\)｝即题中的 {C_1,C_2}。解密的思路比较直接，注意到数学关系 $$ \\begin{cases} C_1=M+rK=M+rkG\\\\ C_2=rG\\\\ C_1-kC_2=M+rkG-krG=M \\end{cases} $$ 只要求出私钥 \\(k=log_GK\\) 就可以求出 \\(M\\)，难题在于求解离散对数，还好SageMath有内置的求解函数。下图是利用discrete_log()函数求出 \\(r\\) 和 \\(k\\) 的过程：\n另外还有一种思路是求出 \\(r=log_GC_2\\) ，再根据\\(M=C_1-rK\\)求出明文，同样关键在离散对数。但从上图不难发现 \\(r\\) 是一个比较小的数，也可以爆破 \\(r\\) 来规避这一难题。（好像有师傅是这么做的）\n求出 \\(k\\) 或 \\(r\\) 离flag就不远了。脚本求解：\nfrom Crypto.Util.number import * q=1139075593950729137191297 a=930515656721155210883162 b=631258792856205568553568 G = (641322496020493855620384, 437819621961768591577606) K = (781988559490437792081406, 76709224526706154630278) C_1=(55568609433135042994738, 626496338010773913984218) C_2=(508425841918584868754821, 816040882076938893064041) def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+a) * inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t\u0026amp;1 else add(B,A) if B else A) r=10077 k=12515237792257199894 h=mul(r,K) H=(h[0],q-h[1]) m1,m2=add(C_1,H) flag = b\u0026#39;0xGame{\u0026#39; + long_to_bytes(m1)+long_to_bytes(m2) + b\u0026#39;}\u0026#39; print(flag.decode(\u0026#39;utf8\u0026#39;)) LLL-FirstBlood # 初识LLL一头雾水，找了点格密码的资料看了看。实话说也没有理解透，但是发现题里给的MakeMask()函数很有意思。它会生成一个有限域GF(p)内的n阶方阵，各个位置的元素完全随机，但方阵的行列式恒为1。资料中称这样的矩阵为“幺模矩阵”，同时提到了格的一个性质：对于格的一组基 \\(v_1,v_2,\\cdots,v_n\\) 可以进行如下三种变换，得到新的一组基与原来的基等价。\n​\t1.交换若干个基向量的顺序\n​\t2.对基向量取负 \\(v_i\\rightarrow-v_i\\)\n​\t3.把某一基向量的k倍加到另一基向量上 \\(v_i+kv_j\\)\n如果把基表示成矩阵 \\(B_i\\) 的形式，其中列向量为基向量，那么以上三种对基的变换可以写成 \\(B_iU\\) ，这里 \\(U\\) 为幺模矩阵。\n换句话说，我们有基 \\(B_1\\)，而且 \\(B_2=B_1U\\) ，此时 \\(B_1\\) 与 \\(B_2\\) 等价，都会生成相同的格。\n题中M是第一行为编码后的密文、其余位置是随机数的4阶方阵，A是随机生成的幺模矩阵。C是M与A相乘的结果。把M看成格，与幺模矩阵A相乘后得到的格C与M等价，即\\( M \\sim C\\)。根据这种等价关系，我们尝试对C进行格基规约（LLL）化简为M。\n这里设使用LLL算法得到的格基为K，其第一行的四个元素即为被切成四份的flag，用long_to_bytes() 转化一下在拼一起就好了。\n（PS：其实不太确定 C.LLL() 得到的到底是不是M，毕竟只是试了下就出flag了，第一行肯定没问题，但是时间很紧其他行没有验证）\n#Sage from Crypto.Util.number import * p=198880159035681668071031460916089145469 c=[[1528140902799730745476264672501768332416990282355490479242339131918301176698899635154781328839496210200676497333428,2081687444435007467807250373278513114045272585243815458840083487459795021302180077490134099644993120009567147202772,3080873409460299046339495750746632185307246572817534784703936044874106809413620470006445984962733721029566440253675,3491734341995174183626991907292607070252197520631412767989879432598743851171175369180080355977574296558734415823458], [2359409535809048127331244699867147546817134802610067329431135227991488324148374065940238308147500809599395748756798,3191196199160821446351036460385791985682645040446022512790815348810555748825420237291839170774872264097466183208742,4665346530155386457242345394284286198347336281451530670818113876767736288089400119492317775648206643242839430899283,5369350746042850276067380638571565496087948799720968959426256192923852197959381101839484196445995828389461004495917], [1641407111066265429602929560264443103285908072677065498760570514577412905392260182334706635555256537745902283191251,2190536173399177167068153351271988931232272884028569669242062395087922275021628334797729266560930040116807133977244,3127556759140845426132305699421707182108351516931881411928719802847628408656887897596425133523782526561471050447359,3707239956529200159380870618471703921011276020439315706352183576289925263316580408968092016782483770373121972835410], [9883814543195849013523934427451407019514807606993414569626142656857168165339,13190422499129347541373922929251088892868361241120937213742340947017395215646,18832738552342488056498211782604832513006649329982003661701684946590064734701,22323329751908690611034666068697427811613727429398087082295754189068333861152]] C=Matrix(ZZ,c) K=C.LLL() flag=b\u0026#39;\u0026#39; for i in K[0]: flag+=long_to_bytes(-i) print(flag) LLL-SecondBlood # 题中通过encrypt()函数向noise_ 和 mask_ 两个列表各添加4个大质数，并将(mask*m + noise) % p 的结果添加到列表 c_ 中。m是我们要找出的明文。理论上我们只要在有限域GF(q)中解出至少一组形如 mask\\_[i] * m+noise\\_[i]=c\\_[i] 的方程就可以求出m。但本题最大的困难在于 noise 完全未知。注意到mask是511位的超大质数，再与m相乘的结果必然更大，而noise只是50位的质数，显然mask*m 远大于 noise ，我们可以把问题转化为已知高位的HNP问题，进一步，HNP问题可以在格上转化为CVP问题。\n由于对格理论了解的不够充分，解题时借鉴了CVP - CTF Wiki (ctf-wiki.org)上的部分思路和方法。 令向量 \\(M\\)=mask ,\\(C\\)=c_ , 数量阵$P=pE$ ,参数$l\\approx log^\\frac{1}{2}p$ (这里没弄懂底数是几，我按lg算的)。我们构造用如下矩阵表示的格 $$ \\begin{bmatrix} P\u0026amp;0\\\\ M\u0026amp;\\frac{1}{2^{l+1}} \\end{bmatrix} $$ 目标是在这个格上找到与已知向量 \\(C\\) 最近的向量 \\(C\u0026rsquo;\\)，恰好这里 \\(C\u0026rsquo;=mM\\) ，我们就可以求出m。\n利用最近平面算法（Babai\u0026rsquo;s nearest plane algorithm）求解CVP，得到flag，脚本如下（借鉴了一点点）\n#Sage from math import * from Crypto.Util.number import * q = 9342426601783650861020119568565656404715236059903009041977149778244153930435908024696666887269890479558473622355346816236972767736577737332173213722012253 mask = [6237128445236992920577225644858662677575951126467888858782461334057970069468925833844231116647406833999142659751374620280213290736114576089069396331226747, 6368031389213953889417545256750169233725975229197446803885029159767701479445576860704561593200907482372690851152126782391126462547524526631934408981070841, 5106473460982791188578285397420642137630347289252852045044021197988607082777231839839730169682158507822078412449827976663385282021916120837408192506341443, 6318090842950331228033349517542810123596316850353637421587264886413877142612686177796023049304908696413386218992511112752788640732410845589679820003047667] c_ = [3823539664720029027586933152478492780438595004453489251844133830947165342839393878831914879334660250621422877333022321117120398528430519794109624186204492, 1721659645750224819953244995460589691120672649732560768435214608167861246790136217219349234604724148039910656573436663379375048145045443527267790379816425, 668633520079344839648950502380059311916108468801009386138810324259146523323704014491547148973835774917331333581475920804677395949854411894556705238578896, 497860586379981076499130281851986010889356253371192266267220334713415782402939318483926418213877341511996918189750595755372560345085899109305344338944066] def babai(A, w): A = A.LLL(delta=0.75) G = A.gram_schmidt()[0] t = w for i in reversed(range(A.nrows())): c = ((t * G[i]) / (G[i] * G[i])).round() t -= A[i] * c return w - t M = Matrix(QQ, 5, 5) for i in range(4): M[i, i] = q M[4, i] = mask[i] M[4, 4] = 1 / (2 ** (l + 1)) closest = babai(M, vector(c_ + [0])) m=(closest[-1] * (2 ** (l + 1))) % q flag=long_to_bytes(404417766109752774365993311026206252937822359426120081323087457724287886115277329019989616964477) print(flag) Week4 # Normal ECC # 又是一道ECC题，根据上周解题经验直接求 \\(k=log_GK\\)，但是数太大了，尝试跑了几个小时sage毫无作用。\n暴力求 \\(k\\) 肯定是行不通的，这里只好换种思路。Hint中给出了 ord(E)==p 这样一个很特殊的条件，据此上网查照了若干资料，发现具有这种特殊性质的曲线有一个专属名称 “异常曲线” 即 anomalous curve，还有专门的攻击方法 “Smart‘s Attack ” 来求解离散对数。\n将 \\(P, Q\\) 扩充成 \\(E(Q_p)\\) 下的点 \\(P^′, Q^′\\)。原来的离散对数是找到 \\(n\\) 使得 \\(Q=nP\\) 且 \\(P,Q \\in E(F_p) \\)，现在只需先把 \\(P, Q\\) 拓展成 \\(P^′, Q^′\\)，然后找到 \\(n\\) 满足 \\(Q^′−nP^′=O^′\\)，其中 \\(O^′\\)是某个非整数点。\n找到函数 \\(ϕ:\\mathbb{Q}→\\mathbb{Q}\\) 使得 \\(Q=nP⇔ϕ(Q)=nϕ(P)\\)。把椭圆曲线的加法「转换」成正常的加法，也就使离散对数问题变成简单的除法： $$ n=\\frac{ϕ(P)}{ϕ(Q)} $$\n为了套上 \\(ϕ\\)，我们把式子乘上 \\(p\\) 倍，得到 \\(pO^′=pQ^′−npP^′\\)。套上 \\(ϕ\\) 函数得到: $$ n≡\\frac{ϕ(pQ^′)}{ϕ(pP^′)}(\\bmod\\ p) $$\n这里引用了资料（Smart\u0026rsquo;s Attack | Utaha\u0026rsquo;s CTF Note）中的一些分析，也比较幸运地找到了smart’s attack的代码。直接放到脚本里求出 \\(k\\)，再按常规思路解密 \\(M\\) 即可。\n完整的SageMath代码如下：\n#sage from hashlib import md5 def MD5(m):return md5(str(m).encode()).hexdigest() def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) p=11093300438765357787693823122068501933326829181518693650897090781749379503427651954028543076247583697669597230934286751428880673539155279232304301123931419 a=490963434153515882934487973185142842357175523008183292296815140698999054658777820556076794490414610737654365807063916602037816955706321036900113929329671 b=7668542654793784988436499086739239442915170287346121645884096222948338279165302213440060079141960679678526016348025029558335977042712382611197995002316466 E=EllipticCurve(GF(p),[a,b]) G=E(4045939664332192284605924284905750194599514115248885617006435833400516258314135019849306107002566248677228498859069119557284134574413164612914441502516162, 2847794627838984866808853730797794758944159239755903652092146137932959816137006954045318821531984715562135134681256836794735388745354065994745661832926404) K=E(9857925495630886472871072848615069766635115253576843197716242339068269151167072057478472997523547299286363591371734837904400286993818976404285783613138603, 9981865329938877904579306200429599690480093951555010258809210740458120586507638100468722807717390033784290215217185921690103757911870933497240578867679716) C1=E(4349662787973529188741615503085571493571434812105745603868205005885464592782536198234863020839759214118594741734453731681116610298272107088387481605173124, 10835708302355425798729392993451337162773253000440566333611610633234929294159743316615308778168947697567386109223430056006489876900001115634567822674333770) C2=E(5193866657417498376737132473732737330916570240569047910293144235752602489388092937375844109374780050061859498276712695321973801207620914447727053101524592, 684299154840371832195648774293174908478389728255128448106858267664482339440737099810868633906297465450436417091302739473407943955874648486647511119341978) assert E.order() == p k=SmartAttack(G,K,p) M=C1-k*C2 flag=\u0026#39;0xGame{\u0026#39;+MD5( M.xy()[0] )+\u0026#39;}\u0026#39; print(flag) ","date":"2024-01-01","externalUrl":null,"permalink":"/writeups/0xgame2023_crypto/","section":"Writeups","summary":"crypto writeup of 0xgame2023","title":"0xGame2023 Crypto","type":"writeups"},{"content":"An ordinary CTFer mainly interested in Reverse.\nqaq\n","date":"2024-01-01","externalUrl":null,"permalink":"/about/","section":"1n1t-Flare Blog","summary":"","title":"About","type":"page"},{"content":"","date":"2024-01-01","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]