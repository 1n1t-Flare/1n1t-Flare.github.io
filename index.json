[{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/","section":"1n1t-Flare Blog","summary":"","title":"1n1t-Flare Blog","type":"page"},{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/tags/forensics/","section":"Tags","summary":"","title":"Forensics","type":"tags"},{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/tags/reverse/","section":"Tags","summary":"","title":"Reverse","type":"tags"},{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024-11-09","externalUrl":null,"permalink":"/writeups/","section":"Writeups","summary":"","title":"Writeups","type":"writeups"},{"content":"题目难度不大，毕竟是取证比赛，查查信息然后连蒙带猜也能做的差不多。\n赛后从逆向的角度，对涉及到的几个程序再深入分析一下。\n个人赛逆向部分 # exe # 在U盘中,你还发现了一个exe文件,但它被锁定,可能需要进行反编译以便进一步检查。参考David_USB_8GB.e01,使用x64dbg的字符串搜索(String Search)功能,在Bitlocker.exe中查找哪个字符串最有可能与显示的登录状态有关? 承上題,当找到控制登录成功的逻辑代码时,如何修改汇编代码来绕过检查,达到任意输入，都成功登录的效果? Bitlocker.exe的正确用户登录名称是? Bitlocker.exe的正确登录密码是? 当 Bitlocker.exe程序尝试显示登录结果（成功或失败）时,使用了哪一种途径来决定显示的消息? 决定能否解密 Bitlocker Key的字节的内存偏移量(Memory Offset)（相对于基址\u0026quot;bitlocker.exe\u0026quot;）是什么? 决定能否解密 Bitlocker Key的内存偏移量(Memory Offset)后,应该如何利用它来进行解密? 解密后的 Bitlocker Key 是? 从U盘镜像中提取出这个Bitlocker.exe，先用DIE查一下，无壳，但要留意是GUI程序。\n利用DIE自带的字符串功能也可以搜索到相关的字符串。（比IDA中的多了PE头、.text 节、.rsrc节的字符串）\n程序的入口点恰好是WinMain函数，IDA打开后看这个函数的反编译伪码，只有简单的几行，除去最后的消息处理，只调用了两个函数：\nsub_140001620：注册窗口类，这个窗口类在第二个函数中用于创建窗口。 sub_140001700：CreateWindowExA创建主窗口，保持update。 在窗口类的定义中可以发现回调函数v2.lpfnWndProc = sub_1400017C0，进入该函数分析\na2是uMsg参数，在windows.h中可以找到如下的宏定义。结合switch-case中的值可以推测功能\n#define WM_CREATE\t0x0001 #define WM_DESTROY\t0x0002 #define WM_COMMAND\t0x0111 主窗口创建时，产生WM_CREATE消息，调用sub_140001850创建一系列的子窗口句柄，体现为输入框，按钮等控件。退出主窗口时则产生WM_DESTROY消息。\n重点放在command消息，也就是点击按钮时会调用sub_140001AE0。查看这个函数，发现最后用MessageBoxA来输出login结果，合理推测是对输入的用户名和密码进行检查。\n伪码能直接看到两个字符串常量，分别对应Username和Password。代码部分类似memcmp逐个字符检查。\n结果最终保存到v9中，通过if判断登录是否成功。对应的汇编是test + jnz，可以patch成jz来绕过检查。\n后面sub_7FF7CB6F22A0函数还进行了hash，生成bitlocker key，通过MessageBox输出。但是如果直接运行的话输入正确只会显示Keep going那段话。在最后可以看到这段代码由硬编码的byte_7FF7CB6F808C常量控制跳转 (也就是题目中提到决定能否解密Bitlocker Key 的字节)，必须要patch修改一下才能输出。\n到这里已经梳理出程序的整个逻辑。由于程序会解密key，所以理想的做法就是两次patch来绕过拿key，和题目引导的整个流程一致，不太需要关心加解密的具体实现。否则可能还要分析加密的API及其参数来确定是何种加密方式。\n团体赛逆向部分 # 赛后检材直接删了，忘了把程序保存到本地。拿着当时的截图简单讲下思路吧\napk # 你现在査看Ben的笔记本电脑，并发现了APK文件。一般而言，APK的关键组成部分是什么？\n参考 Ben_Laptop.zip内的 Joshe Investment.apk，这个APK没有 classes.dex文件，而是有 smali文件，以下哪一个陈述是正确的？(A：这是一个經過反向工程製作的APK)\nBen使用了哪个工具包生成恶意APK以控制受害者的设备？\n确认哪个.xml文件被特别添加为主活动（activity_main）的布局文件？\n确认被指定为主活动层（activity main layer）.xml文件的公共ID？\n确认应用程序没有要求的权限？\nahmyth/mine/king/ahmyth/文件夹下的 b.smali文件的主要功能是什么？\n在 ahmyth/mine/king/ahmyth/文件夹下的 b.smali文件中，字节数组（Byte Array）在发送到服务器之前执行了哪一系列操作，最终的图像格式是？\n在 ahmyth/mine/king/ahmyth/文件夹下的 b.smali文件中，图像在发送到服务器時的压缩比率是多少？\n在 ahmyth/mine/king/ahmyth/文件夹下的 ConnectionManager.smali中，sendReqmethod的目的是什么？\n承上题，参考 Ben Laptop.zip内的 Joshe Investment.apk，C2服务器的IP地址及端口号？\nahmyth/mine/king/ahmyth/文件夹下的 g.smali文件中，MediaRecorder被初始化用于录音。如果 setAudioSource()方法使用了错误的参数，会发生什么，且这将如何影响录音过程的功能？\nahmyth/mine/king/ahmyth/文件夹下的 g.smali文件中，TimerTask用于在启动 MediaRecorder后调度动作。TimerTask在这个过程中有什么作用？\n在 ahmyth/mine/king/ahmyth/文件夹下的 h.smali文件中，method a()和method b()的主要功能有什么区别？\n在 ahmyth/mine/king/ahmyth/文件夹下的h.smali文件中，method b()需要哪些参数？\n在Ben的Laptop的镜像中，Joshe Investment.apk，jadx反编译后看到符号的混淆比较严重。\n查看ahmyth包，这个应该是远控工具，主活动和主服务也在这个包里面。\n在MainActivity中找SetContentView对应的layout，可以确定使用的布局xml文件，其id保存在R类中。\nAndroidManifest.xml可以查到要求的权限。\n接下来对apk的反编译代码进行分析。由于代码量较大且程序被误删掉，只浅析一下题目ahmyth/mine/king/ahmyth中提到的几个部分\nb.smali # onPictureTaken函数，推测与相机拍摄图像相关。先调用this.d释放camera实例，紧接着调用this.e(bArr)将字节数组解码成bitmap图像，再压缩成JEPG。压缩率是decodeByteArray.compress的第二个参数。整个JPEG图像以字节流写入json对象并发送。\nConnectionManager # 看到sendReq声明了一个b.a.b.e的实例对象，并用e.a().b()进行初始化。\n分别查看二者的代码实现，在b.a.b.e中发现“connect”等关键词，推测与某个服务器建立连接。之后分析e.a.b，找到一串Base64编码过的字符串，解码后即为C2服务器的ip和端口。\ng.smali # TimerTask\nh.smali # 逆向分析，发现sms\n分析sendTextMessage参数\n着重分析方法a和方法b\npython # 在分析Ben的笔记本电脑时，你从调查人员那里获得了以下信息：在对一名被捕的犯罪集团成员进行审问时获得的情报显示，Ben对John心怀怨恨，因为John扣留了Ben的犯罪收益份额。因此，Ben加密了John的机密文件夹，以限制他的访问。参考 Ben_Laptop.zip，解密 secretExcel.encrypted的第一步应该是什么？\n在加密文件 secretExcel.encrypted中，初始向量 （lnitial Vector）的值是什么？\n在加密文件 secretExcel.encrypted中，盐值（SALT）是什么？\n查看encrypt.py代码，如果更改 'PBKDF2'的 'count'参数会产生什么影响？\n根据分析及计算后，解密 secrectExcel.encrypted所用的key具体值是什么？\n同样在Ben的Laptop。这个和逆向关联可能不是很大，直接给了python源码，但是毕竟涉及到加解密。\n找到encrypt.py，源代码如下：\nimport os import sys from Crypto.Cipher import AES from Crypto.Protocol.KDF import PBKDF2 from Crypto.Random import get_random_bytes from Crypto.Util.Padding import pad def encrypt_file(file_path, password): salt = get_random_bytes(32) key = PBKDF2(password, salt, dkLen=32, count=100000000) file_path = os.path.abspath(file_path) output_dir = os.path.dirname(file_path) folder_name = os.path.splitext(os.path.basename(file_path))[O] encrypted_path = os.path.join(output_dir, f\u0026#34;{folder_name}.encrypted\u0026#34;) os.makedirs(os.path.dirname(encrypted_path), exist_ok=True) with open(file_path, \u0026#39;rb\u0026#39;) as f_in, open (encrypted_path, \u0026#39;wb\u0026#39;) as f_out: data f_in.read() cipher = AES.new(key,AES.MODE_CBC) f_out.write(cipher.iv) f_out.write(salt) encrypted_data = cipher.encrypt(pad(data,AES.block_size)) f_out.write(encrypted_data) print(f\u0026#34;File encrypted successfully: {encrypted path}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: if len(sys.argv) != 3: print(\u0026#34;Usage: python encrypt.py \u0026lt;file_path\u0026gt; \u0026lt;password\u0026gt;\u0026#34;) sys.exit(1) file_path = sys.argv[1] password = sys.argv[2] encrypt_file(file_path, password) 先基于PBKDF2算法生成伪随机密钥。查看crypto库的文档可以了解到该算法各个参数的作用，count参数代表迭代的次数，影响计算性能和安全性。\n生成key之后进行AES-CBC加密。其中初始向量iv（16 bytes）和加盐salt（32 bytes）的值依次写入了加密文件的最前面。可以用十六进制编辑器提取出来。\n反解出key再解密AES，恢复被加密的excel文件。\n","date":"2024-11-09","externalUrl":null,"permalink":"/writeups/meiyacup2024/","section":"Writeups","summary":"some simple analysis","title":"第十届美亚杯 Reverse部分","type":"writeups"},{"content":" HardSignin # 查到了UPX壳，发现是魔改过的，不能直接脱。在010editor中看到upx壳的节区名UPX被改了，改回来后可以直接脱壳。\n32位程序，进行反汇编，又看到很多花指令。主要在TlsCallback的几个函数里面，而且这几个函数本身也常用来反调试。\n先patch掉所以花指令。但是发现main函数依然不能正常反汇编成指令。这里猜测可能有SMC代码自解密。查看TlsCallback_0，能够看到它把main函数的前170个字节异或了0x66加密。用idaPython脚本解密一下。\nimport idc import idaapi import idautils def smc_xorenc(src_addr,dst_addr,key): length = (dst_addr-src_addr) if (dst_addr\u0026gt;src_addr) else 0 for offset in range(length): addr = src_addr + offset value = idc.get_wide_byte(addr) enc_value = value^key ida_bytes.patch_byte(addr,enc_value) if __name__ == \u0026#34;__main__\u0026#34;: smc_xorenc(0x401890,0x401890+170,0x66) 之后重新建立main函数，F5查看伪码。除了常规的输入输出，加密函数是sub_4016B0。\n继续跟踪该函数，分析加密流程：先对输入进行一次base64，之后每8位进行一次RC4（16轮），最后进行一次TEA。后面两次加密的key在TlsCallback_2中用随机数生成，种子已知。在TlsCallback_1 中发现base64的编码表被打乱了顺序。属于魔改的base64。\n编写脚本进行解密。思路是先还原编码表。之后解密TEA和RC4，得到编码后的字符串。在Cyberchef上进行最后的解码。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; void TEAdecrypt(int a1, unsigned char* a2, unsigned char* a3) { for (int i = 0; i \u0026lt; 16; i += 2) { unsigned int v7 = *(unsigned int*)(a2 + 4 * i); unsigned int v6 = *(unsigned int*)(a2 + 4 * i + 4); int v5 = 0x9E3779B9 * a1; // 0x9E3779B9 是 1640531527 for (int j = 0; j \u0026lt; a1; ++j) { v6 -= ((v7 + ((v7 \u0026gt;\u0026gt; 5) ^ (v7 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * ((v5 \u0026gt;\u0026gt; 11) \u0026amp; 3)))); v5 -= 0x9E3779B9; v7 -= ((v6 + ((v6 \u0026gt;\u0026gt; 5) ^ (v6 \u0026lt;\u0026lt; 4))) ^ (v5 + *(unsigned int*)( a3 + 4 * (v5 \u0026amp; 3)))); } *(unsigned int*)(a2 + 4 * i) = v7; *(unsigned int*)(a2 + 4 * i + 4) = v6; } } void RC4decrypt(unsigned char *a1,int a2,unsigned char *key,int length) { unsigned char s_box[256],v6[256],temp,t; for ( int i = 0; i \u0026lt; 256; ++i ) s_box[i] = i; for ( int j = 0; j \u0026lt; 256; ++j ) { v6[j] = key[j % length]; } int v4 = 0, v1 = 0, v2 = 0; for ( int k = 0; k \u0026lt; 256; ++k ) { v4 = (v6[k] + v4 + s_box[k]) % 256; temp = s_box[k]; s_box[k] = s_box[v4]; s_box[v4] = temp; } for ( int m = 0; m \u0026lt; a2; ++m) { v1 = (v1 + 1) % 256; v2 = (v2 + s_box[v1]) % 256; t = s_box[v1]; s_box[v1] = s_box[v2]; s_box[v2] = t; a1[m] ^= s_box[(s_box[v1] + s_box[v2]) % 256]; } } char table[] = \u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\u0026#34;; unsigned char data[] = { 0x59, 0x1B, 0xFD, 0xB4, 0x6B, 0xB8, 0xBE, 0xD9, 0xB3, 0xD3, 0x77, 0xD6, 0xF0, 0x65, 0x5F, 0x18, 0xA0, 0x9D, 0x3A, 0x53, 0x6D, 0x4A, 0x7B, 0x26, 0x74, 0x3A, 0x9C, 0x4E, 0x20, 0x43, 0x19, 0xD8, 0x72, 0xED, 0x95, 0xB5, 0x9C, 0x05, 0x22, 0x56, 0xCB, 0x7A, 0x11, 0x91, 0x9F, 0x7A, 0xBC, 0x0C, 0x4A, 0x69, 0x6D, 0xCE, 0x3D, 0xB4, 0xAB, 0x29, 0x61, 0xFA, 0x62, 0x32, 0xB4, 0xEC, 0x4C, 0xB6 }; int main() { srand(0x114514u); int v6,v4; unsigned char key1[17],key2[17]; for ( int i = 0; i \u0026lt; 100; ++i ) { v6 = rand() % 64; v4 = rand() % 64; char temp = table[v6]; table[v6] = table[v4]; table[v4] = temp; } printf(\u0026#34;%s\\n\u0026#34;,table); srand(0x1919810u); for (int i = 0; i\u0026lt;0x10; ++i ) { key1[i] = rand() % 255; key2[i] = rand() % 255; } TEAdecrypt(0x64,data,key2); RC4decrypt(data,64,key1,0x10); printf(\u0026#34;%s\u0026#34;,data); return 0; } //4yZRiNP8LoK/GSA5ElWkUjXtJCz7bMYcuFfpm6+hV0rxeHIdwv32QOTnqg1BDsa9 //C+vFCnHRGPghbmyQMXvFMRNd7fNCG8jcU+jcbnjRJTj2GTCOGUvgtOS0CTge7fNs02@ snack ( 复现 ) # 一个贪吃蛇游戏。运行发现是用pygame开发的，推测程序是python打包的。使用pyinstxtractor解包。\n这里的解包实际上不算成功。由于游戏程序的python版本和本地版本不符，所以pyz没有解压而是直接跳过。复现到后面发现需要用到 pyz_extracted 里面的库。这里更换python版本重新解包。\n之后尝试用uncompyle6进行反编译，但是出了问题。一开始怀疑pyc文件里有花指令一类的，后面换成了pycdc引擎结果成功了。估计问题还是在版本上\n反编译后的代码不多，加密逻辑是魔改的RC4，而且程序本身就有解密代码，直接copy下来用。(反编译生成的代码语法有一点小问题，s盒的交换还有后面列表推导式不能直接运行，需要改一下)\n解密密钥在自定义的库key中，这个就是上面提到的 pyz_extracted目录下的 key.pyc，反编译就能看到key\nkey_bytes = b\u0026#34;V3rY_v3Ry_Ez\u0026#34; def initialize(key): key_length = len(key) S = list(range(256)) j = 0 for i in range(256): j = (j + S[i] + key[i % key_length]) % 256 S[i],S[j] = S[j],S[i] return S def generate_key_stream(S, length): i = 0 j = 0 key_stream = [] for _ in range(length): i = (i + 1) % 256 j = (j + S[i]) % 256 S[i],S[j] = S[j],S[i] key_stream.append(S[(S[i] + S[j]) % 256]) return key_stream def decrypt(data, key): S = initialize(key) key_stream = generate_key_stream(S, len(data)) decrypted_data = [ i ^ data[i] ^ key_stream[i] for i in range(len(data))] return decrypted_data data = [101,97,39,125,218,172,205,3,235,195,72,125,89,130,103,213, 120,227,193,67,174,71,162,248,244,12,238,92,160,203,185,155] decrypted_data = decrypt(bytes(data), key_bytes) print(bytes(decrypted_data)) BEDTEA ( 复现 ) # 反编译main函数的加密部分，先发现了两个反调试：一个是常规的IsDebuggerPresent() 调用API，结果保存到dword_404010，和后面加密过程有关系；另一个是用时间戳，两次调用system_clock::now 判断间隔时间。二者都可以在动调时改寄存器绕过。\n跟踪输入v15，定位到sub_401E80。跟进分析，函数分成两个部分：先修改程序的一段数据作为密钥（参考官方wp，算法是斐波那契）；后面是魔改的TEA，左移右移、delta还有轮数都改了。反编译的结果不太好分析，从汇编看比较清晰。生成密钥的初始值就是第一次反调试时得到的dword_404010。\n回到主函数，sub_401770和sub_401560两个函数这里踩了坑。一开始以为是没有实际功能的库函数一类的，看了官方wp才知道是二叉树的前序遍历和后序遍历。其实看到输入v17参数传进去，就应该猜到是加密的一部分。这里是把加密数据逆序了。\n后面调用了SSE指令集的xor指令，还额外多异或了一些无关数据。xor的值是固定的，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; void tea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x9e3449b8, number = 0x987e55d0; for (int i = 0; i \u0026lt; 22; i++) { d2 -= ((d1\u0026lt;\u0026lt;5) + key[2]) ^ ((d1\u0026gt;\u0026gt;4) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;5) + key[0]) ^ ((d2\u0026gt;\u0026gt;4) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } int main() { unsigned int key[] = {3,5,8,13}, key2[] = {21,34,55,89}, key3[] = {144,233,377,610}; unsigned char datac[] ={ 0x76, 0x71, 0x9D, 0xE7, 0x70, 0x77, 0x3F, 0xA3, 0x02, 0xF1, 0x8D, 0xC9, 0x02, 0xC6, 0xA2, 0x4B, 0xBA, 0x19, 0x56, 0x05, 0xF2, 0x89, 0x5E, 0xE0 }; unsigned char *fd = datac,*bd = datac+23 ,tmp; for(int i = 0; i \u0026lt; 24; i ++) { datac[i] ^= 0x33; } while(fd \u0026lt; bd) { tmp = *fd; *(fd++) = *bd; *(bd--) = tmp; } unsigned int *data = (unsigned int *)datac; tea_decry(data, key); tea_decry(data+2, key2); tea_decry(data+4, key3); printf(\u0026#34;%s\\n\u0026#34;,(char*)data); return 0; } ","date":"2024-08-04","externalUrl":null,"permalink":"/writeups/ichunqiu_summer2024_re/","section":"Writeups","summary":"reverse writeup of cqb-summer 2024","title":"2024春秋杯网络安全联赛夏季赛 Reverse","type":"writeups"},{"content":"","date":"2024-08-04","externalUrl":null,"permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF","type":"tags"},{"content":"","date":"2024-06-24","externalUrl":null,"permalink":"/tags/awdp/","section":"Tags","summary":"","title":"AWDP","type":"tags"},{"content":"","date":"2024-06-24","externalUrl":null,"permalink":"/tags/pwn/","section":"Tags","summary":"","title":"Pwn","type":"tags"},{"content":" 初赛 Reverse # asm_re # 题目以文本形式给出一段arm汇编。按照跳转指令把控制流梳理一遍，发现loc_100003C64 -\u0026gt; loc_100003C7C -\u0026gt;loc_100003cc0形成for循环。\n在loc_100003C7C看到EOR异或，直接猜是加密函数。\n整体的加密算法是((W8*0x50+0x14)^0x4D)+0x1E。\n程序后面还有一段循环，代码和上述几乎完全一样。不确定是否有二次加密，用\u0026quot;flag\u0026quot;四个字符带入验证一下，刚好和数据对应上。最后写脚本解出flag。\ndef decrypt(data): return (((data-0x1E)^0x4D)-0x14)//0x50 Data = [0x1fd7,0x21b7,0x1e47,0x2027,0x26e7,0x10d7,0x1127,0x2007,0x11c7,0x1e47, 0x1017,0x1017,0x11f7,0x2007,0x1037,0x1107,0x1f17,0x10d7,0x1017,0x1017, 0x1f67,0x1017,0x11c7,0x11c7,0x1017,0x1fd7,0x1f17,0x1107,0x0f47,0x1127, 0x1037,0x1e47,0x1037,0x1fd7,0x1107,0x1fd7,0x1107,0x2787] flag = [] for i in Data: flag.append(chr(decrypt(i))) print(\u0026#39;\u0026#39;.join(flag)) ** gdb_debug # #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; #include\u0026lt;time.h\u0026gt; unsigned char data[]={0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78}; unsigned char s[]=\u0026#34;congratulationstoyoucongratulationstoy\u0026#34;; unsigned char ptr[]={0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37}; int main() { unsigned char R1[38],R2[38],R3[38],flag[38]; int T = time(0LL); srand(T \u0026amp; 0xF0000000); for(int i=0;i\u0026lt;38;i++) { R1[i]=rand(); } for(int k=37;k;k--) { R2[k]=rand()%(k+1); } for(int i=0;i\u0026lt;38;i++) { R3[i]=rand(); } for(int k=37;k;k--) { unsigned char v = ptr[k]; ptr[k]=ptr[R2[k]]; ptr[R2[k]] = v; } for(int i=0;i\u0026lt;38;i++) { flag[ptr[i]] = data[i]^s[i]^R3[i]; } for(int i=0;i\u0026lt;38;i++) { flag[i] = flag[i]^R1[i]; } printf(\u0026#34;%s\u0026#34;,flag); return 0; } app-debug # key和 iv都在Native层，尝试使用IDA动调so库未果。\n利用frida hook 获取 key和 iv：\nimport frida import sys jscode = \u0026#34;\u0026#34;\u0026#34; Java.perform(function(){ var jni = Java.use(\u0026#34;com.example.re11113.jni\u0026#34;); var reclass = Java.use(\u0026#34;com.example.re11113.MainActivity\u0026#34;); reclass.legal.overload(\u0026#34;java.lang.String\u0026#34;).implementation = function(string){ console.log(\u0026#34;key: \u0026#34; + jni.getkey()); console.log(\u0026#34;iv: \u0026#34; + jni.getiv()); return this.legal(string); } }) \u0026#34;\u0026#34;\u0026#34; def on_message(message, data): if message[\u0026#39;type\u0026#39;] == \u0026#39;send\u0026#39;: print(\u0026#34;[+] {0}\u0026#34;.format(message[\u0026#39;payload\u0026#39;])) else: print(str(message)) process = frida.get_usb_device(-1).attach(\u0026#34;Re11113\u0026#34;) print(\u0026#39;[*] Attached\u0026#39;) script = process.create_script(jscode) script.on(\u0026#39;message\u0026#39;, on_message) print(\u0026#39;[*] Running\u0026#39;) script.load() sys.stdin.read() 进行 DES/CBC解密即可，注意得到的结果还要unpad再套上flag\nimport base64 from Crypto.Cipher import DES iv = b\u0026#34;Wf3DLups\u0026#34; key = b\u0026#34;A8UdWaeq\u0026#34; b64data = \u0026#34;JqslHrdvtgJrRs2QAp+FEVdwRPNLswrnykD/sZMivmjGRKUMVIC/rw==\u0026#34; data = base64.b64decode(b64data) chiper = DES.new(key,DES.MODE_CBC,iv) flag = chiper.decrypt(data) print(flag) #\u0026#39;188cba3a5c0fbb2250b5a2e590c391ce\\x08\\x08\\x08\\x08\\x08\\x08\\x08\\x08\u0026#39; whereThel1b # python源代码调用了so动态库中的函数。题目的so库是基于Cython编译而来，难度较大。先简单找点资料了解下：\nCython 代码必须编译。从 Python 源代码转换为优化的 C / C ++代码并编译为 Python 扩展模块，这发生在两个阶段：\n包含 Python 扩展模块的 .pyx 源文件由 Cython 编译为 .c 文件。\n.c 文件由 C 编译器编译为 .so 文件 ( 或 Windows 上的 .pyd )\nPython中可直接 import\nCython 一类通用工具，为了提高稳健性，其在转换时会对 Python 代码做额外处理（包括对引用计数的调整），从而干扰我们的逆向。当然，也正是因为它是通用工具，其整体框架和对类似 Python 字节码的处理也有一定规律。\n在linux远程动调，先搭动调环境，这一步踩了不少坑：\n务必以root身份运行linux_server，否则提示权限错误 Process Option中要填Linux系统中so动态库的绝对地址 结合Cython源码和文档，以及网上查到的各种正向逆向教程，从IDA中找到了一些比较重要的内容，可以作为入手点：\n一些规律性的命名\n_pyx_mstate_global_static.__pyx_XX 全局静态变量，函数名\n_pyx_mdef_XX_XX\tPyMethodDef : Python函数名到C函数的映射\n逆向时重点分析的关键函数\n_Pyx_CreateStringTabAndInitStrings()\t字符串信息\n__Pyx_pymod_exec_XX()\tso动态库加载时的初始化\n__pyx_pw_XX_XX()\tpython对应函数的C实现\n分析本题，先从给出的源文件开始，有两行涉及调用so函数。\nwhereThel1b.whereistheflag(flag) ret = whereThel1b.trytry(flag) Python函数没有传指针或者传引用的用法，所以第一个函数whereistheflag 没什么用，结合实际动调应该是输出了whereistheflag 字符串。直接分析第二个函数trytry。\n在so文件中找到对应的_pyx_pw_11whereThel1b_1trytry函数，因为保留了足够的符号信息，静态分析也能大概梳理出程序的整个加密逻辑。思路大概：\n根据GetBuiltinName、GetModuleGlobalName、PyObject_GetAttr 等API和符号名，猜测调用的函数及其参数。\n识别结构固定的异常、GC等和语言特性相关的代码，排除这些非关键代码。\n如图，这一段是random.seed(0)。观察发现IDA的命名还是很规律的：BuiltinName 为导入的模块名，Attr 是从模块中导入的方法。pyargnames 是参数列表，真正传入的参数从下标1开始。\n之后调用whereistheflag1，分析方法类似。可以看出调用了base64.b64encode，最后和random.random的得到的随机数xor。\n分区赛 Pwn-AWDP # 待复现\n先吐槽一波逆天平台\n","date":"2024-06-24","externalUrl":null,"permalink":"/writeups/ciscn202405/","section":"Writeups","summary":"writeup and reproduction of 17th CISCN, reverse \u0026amp; pwn","title":"第十七届CISCN初赛\u0026华东北分区赛","type":"writeups"},{"content":"题目难度很友好，也借此拿下第一次ak，值得纪念\n编码喵 # 魔改的Base64，反编译看main函数比较乱，但是发现了一个重要的函数_text_72(),跟踪发现了一串特征鲜明的Base64编码表。\n之后在主函数也能找到编码后的密文，用cyberchef解密即可。\nezrc4 # 签到题，原汁原味的RC4，程序中能找到加密后的密文和key。\n唯一需要注意的是key是被xor加密过的，具体算法在函数X_X()中，把key解密后再对RC4解密。\nkey0=\u0026#34;fenkey?\u0026#34; key1=[0x0A, 0x0C, 0x1A, 0x08, 0x11, 0x1F, 0x1E] flag=[] enc=[0xd5,0xb2,0x7c,0xdc,0x90,0xa2,0x6e,0x60,0x6,0x13,0xe4,0x71,0x59,0xb0,0x90,0x31,0xb2,0xc7,0x1d,0xd7,0x7f] key = [chr(ord(key0[i])^key1[i]) for i in range(len(key0))] s_box = list(range(256)) j = 0 for i in range(256): j = (j + s_box[i] + ord(key[i % len(key)])) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] i = j = 0 for s in enc: i = (i + 1) % 256 j = (j + s_box[i]) % 256 s_box[i], s_box[j] = s_box[j], s_box[i] t = (s_box[i] + s_box[j]) % 256 k = s_box[t] flag.append(s^k) print(bytes(flag)) ezpython！！！！！ # python的exe文件。用pyinstxtractor先分离出pyc文件。之后进行反编译。由于python版本问题，本地的uncompyle6引擎失效，所以找了在线的pycdc引擎进行反编译。\n查看py源码，导入了Litctfbase64库，然后对程序中的密文字符串进行解码并且作为flag输出。为了分析魔改Base64的具体算法，需要继续查看这个库的源码，位置在pyinstxtractor文件夹下的 .\\ezpy.exe_extracted\\PYZ-00.pyz_extracted\\Litctfbase64.pyc\n反编译就能看到编码表，在Cyberchef解码拿flag。\nhello_upx # 题目已经提示了是upx壳，用upx -d命令脱壳出现问题。后来在DIE中发现壳是魔改过的，而且程序是64位。\n利用x64dbg和Scylla进行手动脱壳。由于第一次手脱，部分思路参考：借助 x64dbg 的 UPX 手工脱壳。\n首先动调找到OEP。查看断点窗口中的入口断点，多次运行直到RIP指向入口处，该程序是在0x44FF70。根据esp定律，经过pushad和popad后，OEP处的栈顶和现在入口处的栈顶地址是相同的。所以需要在esp指向的内存地址处下一个硬件断点。(寄存器窗口空白处右键)\n继续运行至该断点，可以看到刚好是在一系列pop（popad）后面，单步跳过至一个大的跳转指令处，跳转后的地址即为OEP。\n接下来要用Scylla进行dump脱壳，直接使用 IAT Autosearch 功能，期间可能会提示使用 IAT Search Advanced ，选 “是” 继续。然后 Get Imports ，最后直接 Dump 。保存成新的exe文件。\n算法部分比较简单，直接写脚本即可。\n#include\u0026lt;stdio.h\u0026gt; int main() { unsigned long long v4[3]; v4[0] = 0x707541504072684C; v4[1] = 0x655158612559632B; v4[2] = 0x4F5E4E601E5A4E20; unsigned char *data = (unsigned char *)v4; char flag[40]={0}; for (int i=0;i\u0026lt;=24;++i) { flag[i] = (char)(data[i]+i); } printf(\u0026#34;%s\u0026#34;,flag); return 0; } ","date":"2024-06-01","externalUrl":null,"permalink":"/writeups/litctf2024_re/","section":"Writeups","summary":"reverse writeup of LitCTF(NSS) 2024","title":"LitCTF2024 Reverse","type":"writeups"},{"content":" Week1 # ezIDA # 64位IDA打开，Shift+F12打开strings窗口能看到flag。\nezASM # 汇编语言看得有点头大，找到关键的 check flag 部分\nxor al, 0x22 cmp al, byte [c + esi] 发现是异或0x22加密，信息在section .data已经给出，用脚本解密。\nnum=[74, 69, 67, 79, 71, 89, 99, 113, 111, 125, 107, 81, 125, 107, 79, 82, 18, 80, 86, 22, 76, 86, 125, 22, 125, 112, 71, 84, 17, 80, 81, 17, 95, 34] flag=[] for i in num: i^=0x22 flag.append(chr(i)) print(\u0026#39;\u0026#39;.join(flag)) ezPYC # 题目给出了一个用python编写但打包成了exe的程序，先用工具 pyinstxtractor.py 把exe文件还原为pyc文件，再找在线反编译工具导出py文件。\n程序的逻辑同样是异或加密，复用反编译后的代码再修改一点点，进行解密。\nflag=[87, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2] c=[1, 2, 3, 4] result=[] for i in range(0, 36, 1): result.append(chr(c[i % 4] ^ flag[i])) print(\u0026#39;\u0026#39;.join(result)) ezupx # 简单的upx脱壳。脱壳后在IDA中反编译，可以看出与0x32进行了异或。直接脚本解密。\n![ezupx 1](ezupx 1.png)\nnum= [0x64,0x7B,0x76,0x73,0x60,0x49,0x65,0x5D,0x45,0x13,0x6B,0x02,0x47,0x6D,0x59,0x5C,0x02,0x45,0x6D,0x06,0x6D,0x5E,0x03,0x46,0x46,0x5E,0x01,0x6D,0x02,0x54,0x6D,0x67,0x62,0x6A,0x13,0x4F,0x32] for i in num: i^=0x32 flag.append(chr(i)) print(\u0026#39;\u0026#39;.join(flag)) Week2 # ezcpp # 魔改TEA，delta换成了0xDEADBEEF，右移改成左移。\n四次TEA加密的代码都挤到主函数里来了，不过还是能看出来结构的。\n8个字节分组加密，但是每次加密的明文只比上一组向后移了一个字节，最后只加密了前11个字节。（这里用的是最开始的附件，后面更新的附件修复了）\n#include\u0026lt;stdio.h\u0026gt; void modify_tea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0xDEADBEEF, number = delta * 32; for (int i = 0; i \u0026lt; 32; i++) { d2 -= ((d1\u0026lt;\u0026lt;4) + key[2]) ^ ((d1\u0026lt;\u0026lt;5) + key[3]) ^ (d1 + number); d1 -= ((d2\u0026lt;\u0026lt;4) + key[0]) ^ ((d2\u0026lt;\u0026lt;5) + key[1]) ^ (d2 + number); number -= delta; } data[0] = d1; data[1] = d2; } int main() { unsigned char data[33] = { 0x88, 0x6A, 0xB0, 0xC9, 0xAD, 0xF1, 0x33, 0x33, 0x94, 0x74, 0xB5, 0x69, 0x73, 0x5F, 0x30, 0x62, 0x4A, 0x33, 0x63, 0x54, 0x5F, 0x30, 0x72, 0x31, 0x65, 0x6E, 0x54, 0x65, 0x44, 0x3F, 0x21, 0x7D}; unsigned int key[] = {1234,2341,3412,4123}; for(int i = 3; i \u0026gt;= 0; i--) modify_tea_decry((unsigned int*)(data+i),key); printf(\u0026#34;%s\u0026#34;,data); return 0; } android # java层检测用户名，RC4\nnative层检测密码\nbabyre # 可以比较直观的看到开了4个线程，分别对应4种不同的加密方式。每加密一个字节切换到固定顺序的下一个线程，依次加密完输入的flag。\n关于key的部分埋了不少坑，先是.init_array中的函数改了 key，之后主函数中异或了0x11进行加密。加密过程中还会进行异常处理，结果只异或了 key的前3个字节。\n从F5伪码不能直接看出异常的触发，需要看反汇编。idiv在除数为零时触发 SIGFPE信号作为异常。而除数var_38 = i - 3，在异或第4个字节时等于0。\n#include\u0026lt;stdio.h\u0026gt; int main() { unsigned char key[] = {0x66,0x65,0x69,0x66,0x65,0x69}; int flag[] = { 0x2F14, 0x004E, 0x4FF3, 0x006D, 0x32D8, 0x006D, 0x6B4B, -110, 0x264F, 0x005B, 0x52FB, -100, 0x2B71, 0x0014, 0x2A6F, -107, 0x28FA, 0x001D, 0x2989, -101, 0x28B4, 0x004E, 0x4506, -38, 0x177B, -4, 0x40CE, 0x007D, 0x29E3, 0x000F, 0x1F11, 0x00FF, 0}; flag[32] = 249 + 1; for (int i = 0; i \u0026lt; 3; i++)\tkey[i] ^= 17;\t// 异常处理 for (int k = 31; k \u0026gt;= 0; k--) { switch (k % 4){ case 0: flag[k] -= flag[k+1] * key[(k+1)%6]; break; case 1: flag[k] += flag[k+1] ^ key[(k+1)%6]; break; case 2: flag[k] /= flag[k+1] + key[(k+1)%6]; break; case 3: flag[k] ^= flag[k+1] - key[(k+1)%6]; break; } } for (int c=0;c\u0026lt;32;c++) printf(\u0026#34;%c\u0026#34;,(char)flag[c]); return 0; } 作为复现，回过头来看一下Linux的多线程和异常处理：\n#include \u0026lt;semaphore.h\u0026gt; int sem_init(sem_t *sem, int pshared, unsigned int value); int sem_wait(sem_t *sem); int sem_post(sem_t *sem); #include \u0026lt;pthread.h\u0026gt; int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); int pthread_exit(void *retval_ptr); int pthread_join(pthread_t thread, void ** retval); sem信号量机制实现线程同步\npthread相关的函数实现线程的创建，退出和回收\n#include \u0026lt;signal.h\u0026gt; #include \u0026lt;setjmp.h\u0026gt; void (*signal(int sig, void (*handler)(int)))(int); int sigsetjmp(jmp_buf env, int savemask) void siglongjmp(jmp_buf env, int value) C语言通过库函数 setjmp和 longjmp实现异常处理。setjmp设置跳转点，其他地方调用 longjmp跳转到该点抛出异常。POSIX定义了两个新函数 sigsetjmp和 siglongjmp，两者之间的唯一区别是 sigsetjmp增加了一个参数。\nsetjmp函数保存程序当前的堆栈环境到 env参数中，接下来的其它地方，你可以通过调用 longjmp函数来恢复先前被保存的程序堆栈环境，并且因此程序控制流会返回到先前调用 setjmp时的执行点。当 setjmp和 longjmp组合一起使用时，能在程序中实现“非本地局部跳转”（\u0026ldquo;non-local goto\u0026rdquo;）的机制。这种机制常用于实现把程序的控制流传递到错误处理模块之中；或者程序中不采用正常的返回语句，或函数的正常调用等方法，而使程序能被恢复到先前的一个调用例程（即函数）中。\t——MSDN\nsignal函数用于信号处理。本题中捕获算术异常的信号，随即调用 handler函数中的 siglongjmp进行异常处理。\narithmetic # 查壳发现魔改UPX，手动修复节区名之后脱壳。\n类似变种迷宫题，从out文件依次加载数据到内存中，按照下三角排列，作为地图。\n路径只有两个方向，1和2分别对应向下和右下。程序中用随机数生成路径，不过肯定没有用\n最后要求所有路径节点的和大于固定值6752833，一开始想过爆破，但显然很费时费力。而且在动调时还发生内存溢出，整个out文件的内容不能完全读取。\n一般迷宫题比较理想的解法都是写算法求解，翻了下官方wp，确实用的是动态规划。奈何不会算法，这里就仅复现一下思路，不写脚本了。\nWeek3 # crackme # c++异常处理，主动抛出异常并轮流调用三个 catch语句，对应XTEA加密的三步。\n这里的XTEA魔改的比较多，改了加密顺序，改了delta，两次左移右移的位数也不相同。\nIDA对于异常处理相关代码的识别并不是很好。之前用IDA 7.5版本只能识别出第一个异常的try块；后面改用最新版9.0，三个异常都能识别，而且对应的catch块也直接能对应上。但是F5反编译之后看不到check部分。这一部分只能借助反汇编来看，好在并不复杂。\n#include\u0026lt;stdio.h\u0026gt; void modi_xtea_decry(unsigned int *data, unsigned int *key) { unsigned int d1 = data[0], d2 = data[1]; unsigned int delta = 0x33221155; unsigned int number = 0; for (int i = 0; i \u0026lt; 32; i++) { number ^= delta; d2 -= ( ((d1\u0026lt;\u0026lt;5) ^ (d1\u0026gt;\u0026gt;6)) + d1) ^ (number + key[(number\u0026gt;\u0026gt;11) \u0026amp; 3]); d1 -= ( ((d2\u0026lt;\u0026lt;4) ^ (d2\u0026gt;\u0026gt;5)) + d2) ^ (number + key[number \u0026amp; 3]); } data[0] = d1; data[1] = d2; } int main() { unsigned int key[] = {1234,2345,3456,4567}; unsigned int v18[8]; v18[0] = 0x32FC31EA; v18[1] = 0xF0566F42; v18[2] = 0xF905B0B2; v18[3] = 0x5F4551BE; v18[4] = 0xFB3EFCBB; v18[5] = 0x6B6ADB30; v18[6] = 0x4839879; v18[7] = 0x2F4378DF; for(int i = 0; i \u0026lt; 8; i += 2) modi_xtea_decry(v18+i,key); printf(\u0026#34;%s\u0026#34;,(char*)v18); return 0; } 利用动调来追踪输入会比较方便一些\nfindme # IDA反编译程序，在主函数中看到一个fake_flag，下面是一串乱码。观察乱码最后面是等号，猜测是Base系列编码。解码后发现还是一个fake_flag。\nmain函数很短，除了上面两个假flag，只剩下输出Buffer一个语句。查看Buffer变量的内容，发现是字符M，但是紧接着四个字节后又有一个字节'Z'。这里联想到PE文件的MZ头。但是正常它只会出现在文件的最前面部分，中间也没有间隔。于是打开Hex窗口看了后面的数据，又发现了This program cannot be run in DOS mode这一标志性的信息。可以确定在题目的程序里面又藏了一个PE文件。\n能够看出内嵌的文件把原来的每个字节都扩充成了4个字节，高位的3个字节（小端序）都补零对齐。在010Editor中把有这种特征的部分提取出来，另存为enc.exe，然后写了几行c代码把它恢复成正常的PE文件。\n#include\u0026lt;stdio.h\u0026gt; int main() { int buf; char byte; FILE *enc = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\enc.exe\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *dec = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\dec.exe\u0026#34;,\u0026#34;wb+\u0026#34;); while(!feof(enc)) { fread(\u0026amp;buf,sizeof(int),1,enc); byte = buf \u0026amp; 0xff; fwrite(\u0026amp;byte,sizeof(char),1,dec); } fclose(enc); fclose(dec); return 0; } 反编译提取出来的程序，在IDA中没找到main函数。分析汇编部分，看到了不少花指令，而且形式都相似，如下：\njz loc_xx jnz loc_xx db 0xC7 从头开始把所有花指令都patch成nop，重新建立函数，可以正常反编译main函数。除去输入输出，主函数调用了sub_401068和sub_40110C两个函数，最后把处理后的输入和数组byte_405148比较判断。分别跟踪这两个函数，发现大部分比较熟悉（算法和Week2的一道题很像，当时没做出来，后面看wp才知道是RC4）结合网络资料，判断出这两个函数是经过小改的RC4算法。\n改动主要有三点\nS盒初始状态，各元素都是索引值的相反数（从unsigned char的角度来看，溢出成256-i）\n密钥流的生成，取S盒中从后向前第s[v1]+s[v3]个元素，同样看成s[256-(s[v1]+s[v3])]。\n这部分IDA反编译的代码不好理解，array[-(buffer[v1]+buffer[v3])]，最后索引值取负。但是负的索引在C语言没有意义。如果理解为unsigned char，由于array长度只有32，同样也会出现越界的情况。于是分析一下对应的汇编，得出结论是这里负号要看成从array地址减去那个索引值。\n在栈中查看array和buffer之间的偏移量，发现刚好是256，这两个数组无缝衔接。那么从array地址减去k对应的元素也就是buffer从后向前第k个元素。\n加密没有进行异或，而是原文和对应密钥流相加。\n最后进行解密。按照原算法的流程推出密钥流，之后反过来从加密数据中逐一减去即可。\narray= [0x7D, 0x2B, 0x43, 0xA9, 0xB9, 0x6B, 0x93, 0x2D, 0x9A, 0xD0, 0x48, 0xC8, 0xEB, 0x51, 0x59, 0xE9, 0x74, 0x68, 0x8A, 0x45, 0x6B, 0xBA, 0xA7, 0x16, 0xF1, 0x10, 0x74, 0xD5, 0x41, 0x3C, 0x67, 0x7D] buffer = [0]+[256-i for i in range(1,256)] v = b\u0026#39;deadbeef\u0026#39; v6 = list(v*32) v2 = 0 for j in range(256): v2 = (buffer[j]+v6[j]+v2) % 256 buffer[v2],buffer[j] = buffer[j],buffer[v2] v1 = v3 = 0 for i in range(32): v1 = (v1+1) % 256 v3 = (buffer[v1]+v3) % 256 buffer[v1],buffer[v3] = buffer[v3],buffer[v1] index = 256 - (buffer[v1]+buffer[v3]) \u0026amp; 0xff array[i] = (array[i]-buffer[index]) \u0026amp; 0xff print(bytes(array)) encrypt # 主函数遍布Windows加密API，去MSDN上一查都是\u0026lt;bcrypt.h\u0026gt;这个库中的。\n结合文档和程序中的字符串信息，推测出是AES-CBC。\n在生成 pbKey的函数附近找到 pbSecret，推测是key。在前面可以找到iv\nmystery # 主函数只有ptrace反调试，核心代码放到了init和fini部分。\ninit_array预先加密了密钥，先异或后RC4。 fini_array实现类似主函数的功能，对输入的flag进行魔改RC4（生成密钥流后的异或加密改成了减法） #include\u0026lt;stdio.h\u0026gt; void rc4_crypt(unsigned char *data, unsigned char *key, int data_len, int key_len) { unsigned char S[256], tmp = 0, t = 0; int i = 0, j = 0; for (int i = 0; i \u0026lt; 256; i++) S[i]= i; for (int i = 0; i \u0026lt; 256; i++) { j = (j + S[i] + key[i % key_len]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } i = 0, j = 0; for (int l = 0; l \u0026lt; data_len; l++) { i = (i + 1) % 256; j = (j + S[i]) % 256; t = (S[i] + S[j]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; data [l] ^= S[t]; } } void modi_rc4_crypt(unsigned char *data, unsigned char *key, int data_len, int key_len) { unsigned char S[256], tmp = 0, t = 0; int i = 0, j = 0; for (int i = 0; i \u0026lt; 256; i++) S[i]= i; for (int i = 0; i \u0026lt; 256; i++) { j = (j + S[i] + key[i % key_len]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; } i = 0, j = 0; for (int l = 0; l \u0026lt; data_len; l++) { i = (i + 1) % 256; j = (j + S[i]) % 256; t = (S[i] + S[j]) % 256; tmp = S[i]; S[i] = S[j]; S[j] = tmp; data [l] += S[t]; } } int main() { unsigned char key[] = {0x44, 0x4A, 0x56, 0x44, 0x4A, 0x56}; unsigned char key1[] = {0x4D, 0x4E, 0x41, 0x70, 0x4B, 0x4A, 0x4D, 0x5A, 0x48, 0x0E}; unsigned char data[] ={ 0x50, 0x42, 0x38, 0x4D, 0x4C, 0x54, 0x90, 0x6F, 0xFE, 0x6F, 0xBC, 0x69, 0xB9, 0x22, 0x7C, 0x16, 0x8F, 0x44, 0x38, 0x4A, 0xEF, 0x37, 0x43, 0xC0, 0xA2, 0xB6, 0x34, 0x2C}; for (int i = 0; i \u0026lt; 6; i++) key[i] ^= 0x2F; for (int j = 0; j \u0026lt; 10; j++) key1[j] ^= 0x2F; rc4_crypt(key1,key,10,6); modi_rc4_crypt(data,key1,28,10); printf(\u0026#34;%s\u0026#34;,data); } Week4 # crackme2 # 先是异常处理，出题人应该想借异常来隐藏代码。结合上周的经验，IDA9.0能够识别出来这部分异常处理，反编译结果还算清晰。\nmov byte ptr ds:0, 1 引发空指针解引用的异常，直接跳转执行__expect(1)块中的代码（查询MSDN可知，try-except 语句是 Microsoft 特定的扩展，支持 C / C++ 中的结构化异常处理SEH）\n继续分析，NtQueryInformationProcess(···, ProcessDebugPort, \u0026amp;ProcessInformation, ···) 检查是否处于调试状态，结合后面smc进行反调试。先把这里的反调试patch掉。\nsmc大概有两种解决思路\nIDApython脚本进行patch 解密完成处下断点dump 动调还是方便一点，在第二次调用VirtualPrrotect 的地方下断点，此时SMC已经解密完成。在反汇编窗口中找到sub_14000105C 对应地址，重新反编译看到真正的代码逻辑。这里的反调和smc设计的很巧妙，在解密之前已经是一个正常的函数，只不过最后解出fake flag，如果不仔细看很难发现这里暗藏玄机。\n解密后发现是方程，用z3求解。\n考虑到方程中用了左移，最开始用z3的Bitvecs(8) 创建变量，不过确实慢，要跑大概两个多小时。而且比较疑惑的是这种方法解出的flag只有部分正确，其余的超过ascii可见字符范围。\nhgame{S\\xcdC\\xdf\\xb4n\\xe4\\xdfs0\\xec\\xf61ng_equ4t\\xb1On\\xf3} 参考官方wp，改用Ints 创建变量，效果立竿见影。得到正确flag\nfrom z3 import * (v5,v28,v11,v10,v24,v41,v22,v40,v7,v18,v29,v27,v9,v31,v30,v20,v23,v39,v15,v21,v26,v2,v42,v6,v16,v1,v17,v25,v8,v4,v19,v3,v12,v13) = Ints(\u0026#34;v5 v28 v11 v10 v24 v41 v22 v40 v7 v18 v29 v27 v9 v31 v30 v20 v23 v39 v15 v21 v26 v2 v42 v6 v16 v1 v17 v25 v8 v4 v19 v3 v12 v13\u0026#34;) s = Solver() s.add(v18+201*v24+194*v10+142*v20+114*v39+103*v11+52*(v17+v31)+((v9+v23)*2**6)+14*(v21+4*v25+v25)+9*(v40+23*v27+v2+3*v1+4*v2+4*v6)+5*(v16+23*v30+2*(v3+2*v19)+5*v5+39*v15+51*v4)+24*(v8+10*v28+4*(v42+v7+2*v26))+62*v22+211*v41+212*v29==296473) s.add(207*v41+195*v22+151*v40+57*v5+118*v6+222*v42+103*v7+181*v8+229*v9+142*v31+51*v29+122*(v26+v20)+91*(v2+2*v16)+107*(v27+v25)+81*(v17+2*v18+v18)+45*(v19+2*(v11+v24)+v11+v24)+4*(3*(v23+v21+2*v23+5*v4)+v39+29*(v10+v1)+25*v15)+26*v28+101*v30+154*v3==354358) s.add(177*v40+129*v26+117*v42+143*v28+65*v8+137*v25+215*v21+93*v31+235*v39+203*v11+15*(v7+17*v30)+2*(v24+91*v9+95*v29+51*v41+81*v20+92*v18+112*(v10+v6)+32*(v22+2*(v1+v23))+6*(v2+14*v16+19*v15)+83*v5+53*v4+123*v19)+v17+175*v27+183*v3==448573) s.add(113*v19+74*v3+238*v6+140*v2+214*v26+242*v8+160*v21+136*v23+209*v9+220*v31+50*v24+125*v10+175*v20+23*v39+137*v22+149*v18+83*(v4+2*v30)+21*(9*v29+v16)+59*(4*v27+v17)+41*(v1+v41)+13*(v7+11*(v40+v15)+6*v42+4*(v28+2*v11)+v28+2*v11+17*v5)+36*v25==384306) s.add(229*v21+78*v1+v2+v9+133*v27+74*v6+69*v26+243*v7+98*v28+253*v8+142*v25+175*v31+105*v41+221*v10+121*v39+218*(v19+v29)+199*(v24+v30)+33*(v40+7*v17)+4*(27*v20+50*v11+45*v18+19*(v3+v42)+v16+16*v23+52*v4)+195*v22+211*v5+153*v15==424240) s.add(181*v25+61*v2+65*v21+58*v31+170*v29+143*v24+185*v10+86*v11+97*v22+235*(v23+v27)+3*(53*v41+74*(v8+v3)+13*(v42+6*v9)+11*(v39+7*v20)+15*(v18+4*v17)+v7+35*v1+29*v15)+4*(57*v6+18*(v5+2*v26)+v28+17*v16+55*v30)+151*v40+230*v4+197*v19==421974) s.add(209*v21+249*v30+195*v2+219*v25+201*v39+85*v18+213*(v17+v31)+119*(v11+2*v41)+29*(8*v24+v40+4*v27+v27)+2*(v8+55*(2*v29+v19)+3*(v10+39*v9+2*(v6+20*v20)+35*v7)+4*(v5+31*v42+28*v3)+26*v28+46*(2*v26+v16)+98*v1)+53*v23+171*v15+123*v4==442074) s.add(162*v19+74*v5+28*v27+243*v42+123*v28+73*v8+166*v23+94*v24+113*v11+193*v22+122*(v6+2*v7)+211*(v10+v25)+21*(v17+7*v41)+11*(v4+23*(v16+v39)+2*(v40+5*v30+2*(2*v18+v29)+2*v18+v29))+5*(46*v9+26*v20+4*(v31+2*v21)+v15+27*v2+10*v1)+36*(v3+5*v26)==376007) s.add(63*v19+143*v5+250*v6+136*v2+214*v40+62*v26+221*v42+226*v7+171*v28+178*v8+244*v23+(v9*2**7)+150*v31+109*v29+70*v41+127*v20+204*v39+121*v22+173*v18+69*(v25+v30+v27)+74*(v16+2*v15+v15)+22*(7*v24+v17+10*v11)+40*(v1+4*v21+v21)+81*v10+94*v4+84*v3==411252) s.add(229*v15+121*v4+28*v30+206*v16+145*v27+41*v1+247*v6+118*v26+241*v28+79*v8+102*v25+124*v23+65*v9+68*v31+239*v17+148*v24+245*v39+115*v11+163*v22+137*v18+53*(v5+2*v29)+126*(v40+2*v10)+38*(v7+v21+4*v7+6*v41)+12*(v2+16*v42)+109*v20+232*v3+47*v19==435012) s.add(209*v21+233*v40+93*v1+241*v2+137*v8+249*v17+188*v29+86*v24+246*v10+149*v20+99*v11+37*v22+219*v18+17*(v6+10*v25)+49*(v5+3*v3+4*v28+v28)+5*(16*v39+11*(v41+2*v27+v27)+12*v7+v31+30*v16+27*v19)+18*(v23+2*(v4+v26+2*v4)+v4+v26+2*v4)+24*v9+109*v42+183*v30+154*v15==392484) s.add(155*v15+247*v40+157*v28+119*v23+161*v17+133*v20+85*v22+229*(v7+v24)+123*(2*v31+v42)+21*(v41+12*v30)+55*(v9+v5+v18+2*v5)+15*(v3+16*v10+9*v21)+2*(v2+115*v29+111*v16+26*v6+88*v8+73*v39+71*v11+28*(v26+2*(v25+2*v1))+51*v27+99*v4+125*v19)==437910) s.add(220*v3+200*v4+139*v15+33*v5+212*v30+191*v16+30*v27+233*v1+246*v6+89*v2+252*v40+223*v42+19*v25+141*v21+163*v9+185*v17+136*v31+46*v24+109*v10+217*v39+75*v22+157*v18+125*(v11+v19)+104*(2*v41+v20)+43*(v28+2*v29+v29)+32*(v8+v7+2*v8+2*(v23+v26))==421905) s.add(211*v24+63*v15+176*v5+169*v16+129*v27+146*v40+111*v26+68*v42+39*v25+188*v23+130*v9+(v31*2**6)+91*v41+208*v20+145*v39+247*v18+93*(v22+v17)+71*(v6+2*v11)+103*(v8+2*v30)+6*(v21+10*v28+28*v7+9*v29+19*v2+24*v1+22*v3)+81*v10+70*v4+23*v19==356282) s.add(v12==v10+2*(v31+4*(v29+v17))+v31+4*(v29+v17)) s.add(94*v42+101*v2+152*v40+200*v7+226*v8+211*v23+121*v24+74*v11+166*v18+((v6+3*v28)*2**6)+41*(4*v9+v21)+23*(v39+11*v41)+7*(v20+10*v25+2*v12+v12)+3*(78*v30+81*v16+55*v27+73*v1+4*v26+v15+85*v3+65*v19)+62*v22+88*v5+110*v4==423091) s.add(133*v22+175*v15+181*v30+199*v16+123*v27+242*v1+75*v6+69*v2+153*v40+33*v26+100*v42+229*v7+177*v8+134*v31+179*v29+129*v41+14*v10+247*v24+228*v20+92*v11+86*(v9+2*v18)+94*(v23+v21)+37*(v17+4*v3)+79*(v25+2*v28)+72*v5+93*v39+152*v4+214*v19==391869) s.add(211*v24+213*v18+197*v40+159*v25+117*v21+119*v9+98*v17+218*v41+106*v39+69*v11+43*(v2+v29+2*v2)+116*(v4+v10+2*v26)+5*(v42+9*v23+35*v20+37*v31)+11*(v16+13*v27+5*v5+8*v30)+6*(29*v28+25*v8+38*v22+v15+13*v1+10*v3)+136*v7+142*v6+141*v19==376566) s.add(173*v3+109*v15+61*v30+187*v1+79*v6+53*v40+184*v21+43*v23+41*v9+166*v31+193*v41+58*v24+146*v10+(v20*2**6)+89*v39+121*v11+5*(v17+23*v8)+7*(29*v18+v29+4*v7)+13*(3*v42+v16+7*v26+13*v2)+3*(v4+83*v5+51*v27+33*v22+8*(v19+4*v28)+18*v25)==300934) s.add(78*v1+131*v5+185*v16+250*v40+90*v26+129*v42+255*v28+206*v8+239*v25+150*v10+253*v39+104*v22+58*(v2+2*v7)+96*(v15+v31)+117*(v9+2*v4)+27*(v17+8*v18+v18)+19*(v23+3*v21+4*v29+v29)+7*(22*v41+3*(v11+11*v24)+v3+29*v6+14*v27)+109*v20+102*v30+100*v19==401351) s.add(233*v19+71*v5+209*v27+82*v6+58*v26+53*v25+113*v23+206*v31+39*v41+163*v20+222*v11+191*v18+123*(v7+v40)+69*(v9+2*v22+v22)+9*(v3+8*v24+7*(3*v1+v28)+5*v16+19*v30)+4*(v15+26*v17+61*v29+43*v42+49*v2+32*v4)+10*(7*(v8+3*v21)+v39+12*v10)==368427) s.add(139*v30+53*v5+158*v16+225*v1+119*v6+67*v2+213*v40+188*v28+152*v8+187*v21+129*v23+54*v9+125*v17+170*v24+184*v11+226*v22+253*v18+26*(v29+v41)+97*(v4+2*v25)+39*(5*v26+v27)+21*(v39+8*v42)+12*(17*v10+v31+15*v7+12*v19)+165*v20+88*v15+157*v3==403881) s.add(114*v3+61*v27+134*v40+62*v42+89*v9+211*v17+163*v41+66*v24+201*(v7+v18)+47*(5*v16+v22)+74*(v4+v31)+142*(v2+v28)+35*(v20+6*v26)+39*(v15+6*v30)+27*(v25+9*v23+8*v6)+4*(v21+63*v19+2*(v1+12*(v10+v5)+8*v11+26*v29))+10*(v8+4*v39+v39)==382979) s.add(122*v25+225*v21+52*v23+253*v9+197*v17+187*v31+181*v29+183*v41+47*v20+229*v39+88*v22+127*(v10+2*v18)+37*(v7+3*v3)+((v11+2*v30+v30)*2**6)+7*(21*v8+v27+18*(v4+v1+2*v16))+6*(23*v24+v26+17*v2+39*v6)+10*(v5+11*v28+21*v42)+149*v19+165*v40+121*v15==435695) s.add(165*v20+223*v4+249*v5+199*v1+135*v2+133*v26+254*v42+111*v7+189*v28+221*v25+115*v21+186*v9+79*v41+217*v24+122*v11+38*v18+109*(2*v31+v29)+14*(v8+17*v40+8*(v6+2*v16))+4*(11*(5*v30+v39)+6*(v10+2*v22)+v27+52*v17+50*v23)+229*v15+86*v3+234*v19==453748) s.add(181*v25+94*v42+125*v1+226*v26+155*v7+95*v21+212*v17+91*v31+194*v29+98*v24+166*v11+120*v22+59*v18+32*(v9+v8)+158*(v6+v5)+101*(v41+v19)+63*(v4+2*v23)+67*(v28+2*v20)+11*(v39+10*v16+11*v10)+39*(v30+4*(v2+v15))+233*v40+56*v27+225*v3==358321) s.add(229*v21+135*v4+197*v15+118*v5+143*v16+134*v6+204*v40+173*v26+81*v7+60*v28+58*v8+179*v23+142*v9+178*v17+230*v31+148*v29+224*v41+194*v24+223*v10+87*v20+200*v39+233*v11+49*v22+127*(v25+v30)+31*(4*v27+v18)+42*(v1+6*v2)+109*v42+75*v3+165*v19==456073) s.add(41*v4+253*v3+163*v15+193*v30+155*v16+113*v27+131*v6+55*v2+21*v40+53*v26+13*v8+201*v25+237*v9+223*v31+95*v24+194*v20+62*v39+119*v11+171*v22+135*v18+69*(v10+3*v28)+211*(v1+v29)+4*(43*v7+v42+40*v17)+6*(v5+33*v41+20*(2*v19+v21)+24*v23)==407135) s.add(v13==v6+v1+8*v6+4*(v8+2*v27)) s.add(111*v19+190*v3+149*v4+173*v28+118*v23+146*v29+179*v10+51*v20+49*v39+61*v11+125*v22+162*v18+214*(v25+v30)+14*(2*v31+v24)+178*(v41+v16)+11*(4*v9+v21+17*v42)+65*(v26+v17+2*v26+2*v5)+4*(v7+38*v15+4*v13+v13+8*v40+43*v2)==369835) s.add(27*v27+223*v6+147*v26+13*v21+35*(v17+7*v4)+57*(v19+2*v18+3*v11)+11*(v1+17*(v9+v5)+10*v16+3*v31)+2*(53*v23+v25+38*v15+43*v42+115*v29+61*v22+111*(v10+v40)+14*(v20+v7+2*v7+8*v28)+109*v2+100*v41+63*v8)+93*v39+251*v30+131*v3==393303) s.add(116*v9+152*v29+235*v20+202*v18+85*(v8+3*v11)+221*(v16+v40)+125*(2*v41+v24)+7*(19*v4+9*(v10+2*v25)+v2+33*v3+32*v19)+3*(71*v39+43*v22+32*(v17+v26)+15*(v5+v6+2*v23)+v28+74*v31+48*v42)+10*(v21+11*v30+16*v15)+136*v7+106*v1+41*v27==403661) s.add(127*v4+106*v15+182*v30+142*v5+159*v16+17*v1+211*v6+134*v2+199*v7+103*v28+247*v23+122*v9+95*v41+62*v10+203*v39+16*v11+41*(6*v42+v25)+9*(22*v24+v20+27*v31+28*v40)+10*(v8+v22+3*v21+8*v17+2*(v22+3*v21+8*v17)+13*v29)+6*(23*v27+v26)+213*v18+179*v3+43*v19==418596) s.add(149*v19+v1+133*v22+207*v41+182*v26+234*v7+199*v8+168*v21+58*v10+108*v20+142*v18+156*(v9+v25)+16*(v29+6*v31)+126*(v17+2*v39)+127*(v4+2*v27+v40)+49*(v30+4*v16)+11*(v5+22*v11)+5*(v15+v42+45*v24+50*v28)+109*v2+124*v6+123*v3==418697) flag = [] result = s.model() vars = (v5,v28,v11,v10,v24,v41,v22,v40,v7,v18,v29,v27,v9,v31,v30,v20,v23,v39,v15,v21,v26,v2,v42,v6,v16,v1,v17,v25,v8,v4,v19,v3) for var in vars: flag.append(result[var].as_long()) print(bytes(flag).decode()) change # hook，有点像回调函数\n两个加密函数（隔一个字节）交替进行加密。\ndata = [0x13, 0x0A, 0x5D, 0x1C, 0x0E, 0x08, 0x23, 0x06, 0x0B, 0x4B, 0x38, 0x22, 0x0D, 0x1C, 0x48, 0x0C, 0x66, 0x15, 0x48, 0x1B, 0x0D, 0x0E, 0x10, 0x4F] key=b\u0026#34;am2qasl\u0026#34; flag = [] for i in range(len(data)): if(i % 2 == 0): result = (data[i] -10) ^ key[i % len(key)] else: result = data[i] ^ key[i % len(key)] flag.append(result) print(bytes(flag)) ","date":"2024-03-01","externalUrl":null,"permalink":"/writeups/hgame2024/","section":"Writeups","summary":"reverse writeup of Hgame2024","title":"HGAME2024 Revserse","type":"writeups"},{"content":"nothing here\n","date":"2024-02-01","externalUrl":null,"permalink":"/docs/","section":"1n1t-Flare Blog","summary":"","title":"docs","type":"page"},{"content":" Week1 # 数字筑基 # 在IDA中打开文件，一眼flag。\n代码金丹 # IDA打开即送 +1\n网络元婴 # IDA打开即送 +2。\t从上到下输入即可。\n虚拟化神 # 反编译程序，在main函数中找到关键变量v13。它的值没有明确给出，而且后续一系列的xor操作都和它有关系，所以通过动态调试找到内存中的值。实际上就是flag。\n另一方面，如果不调试。按照官方wp的提示，这个程序会生成一个文件config.txt。之后根据其内容判断是否输出v13的内容。具体的逻辑是提取config.txt的前两个字符，转换为整数并与1比较。这里直接修改该文件，把0改成1，之后运行程序就能拿到flag。\n赛博天尊 # 分析程序逻辑：do...while部分判断输入Buffer的长度，要求长度为44。其中最后一个字符为}（ascii 125），接下来以-为分隔符将flag内部32位十六进制数拆分成五部分，各部分满足方程组。\n核心在于解方程组，这里尝试了两种方法。\n用 sympy 库求解 #python from sympy import * v7,v8,v9,v10,v11=symbols(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) equations=[Eq(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) , 0x12021DE669FC2), Eq( v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) , 0x159BFFC17D045), Eq(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) , 0xACE320D12501), Eq(v8 + 2 * (v7 + v11 + v9 + 2 * v10) , 0x733FFEB3A4FA), Eq(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 , 0x1935EBA54EB28)] solution = solve(equations) solution = sorted(solution.items(), key=lambda item:int(str(item[0])[1:])) hexs=[] for value in solution: hexs.append(hex(value[1])[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) 用 z3 模块求解\nz3求解出来的结果是z3.RatNumRef类型的，不是内置类型。需要转换为int型。此外要先用Solver.check()判断解的情况，才能调用 Solver.model() 输出解。\n#python from z3 import * v7,v8,v9,v10,v11=Reals(\u0026#39;v7 v8 v9 v10 v11\u0026#39;) s=Solver() s.add(7 * v9 + 5 * (v8 + v11) + 2 * (v10 + 4 * v7) == 0x12021DE669FC2) s.add(v8 + 3 * (v9 + v10 + 2 * v10 + 2 * (v11 + v7)) == 0x159BFFC17D045) s.add(v10 + 3 * (v11 + 3 * v9) + 2 * (v8 + 4 * v7) == 0xACE320D12501) s.add(v8 + 2 * (v7 + v11 + v9 + 2 * v10) == 0x733FFEB3A4FA) s.add(v8 + 7 * v11 + 8 * (v9 + v10) + 5 * v7 == 0x1935EBA54EB28) hexs=[] if isinstance(s.check(), CheckSatResult): result=s.model() for var in (v7,v8,v9,v10,v11): num = result[var].as_long() hexs.append(hex(num)[2:]) flag=\u0026#39;0xGame{\u0026#39;+\u0026#39;{}-{}-{}-{}-{}\u0026#39;.format(*hexs)+\u0026#39;}\u0026#39; print(flag) Week2 # 符文解密师 # 32位程序，IDA打开，在hex窗口找到flag\n编译逆旅者 # 文件后缀为.pyc可知是编译过的python程序。鉴于IDA反编译后的结果是C伪代码，并不能得到源python代码。于是考虑在线python反编译。\n在main()函数中找到flag的十六进制形式。粘贴(ctrl+shift+v)到十六进制编辑器010Editor中得到flag。\n码海舵师 # 32位IDA打开，F5反编译代码如下：\n在21行位置发现可疑的一串乱码，末尾‘=’盲猜是base64，在线解密。\n注册侦探 # 反编译main函数，发现是c++程序，而且调用了很多API函数。分析程序逻辑后发现flag是在一系列判断之后生成并且输出的，所以尝试动态调试。刚开始不知道RegOpenKeyExA,RegQueryValueExA这两个函数的功能，也没有去查。当时思路是修改寄存器的返回值，绕过这两个函数，但在动调过程中发现无法改data的值。所以最后flag没有生成。\n换一种思路，在输出时数据经过了0x33的异或，那么数据是怎么来的？一点点往回找发现和Src变量有关，而且函数中有Src数组的全部值。尝试了一下把Src[0]逐字节异或0x33，结果是0xGa，和flag正好对应。说明就是单字节异或，写脚本解密就得到flag。\n#python \u0026#39;\u0026#39;\u0026#39; Src[0] = 1383353091; Src[1] = 189290078; Src[2] = 38864395; Src[3] = 503515984; Src[4] = 1364350722; Src[5] = 1448105758; Src[6] = 89136641; Src[7] = 85852241; Src[8] = 72812293; Src[9] = 50464516; Src[10] = 1314325334; \u0026#39;\u0026#39;\u0026#39; Src=[1383353091, 189290078, 38864395, 503515984, 1364350722, 1448105758, 89136641, 85852241, 72812293, 50464516, 1314325334] flag=bytes() for num in Src: byte=num.to_bytes(4,\u0026#39;little\u0026#39;) for i in byte: flag+=(i^0x33).to_bytes(1) print(flag.decode()) #0xGame{885b1c80-1dab-dce2-c6b3-664d77410e0d} 看了官方wp，还是从RegOpenKeyExA,RegQueryValueExA入手，创建注册表值，之后运行程序得到flag\n壳艺大师 # 在DIE里查壳发现有upx壳，先进行脱壳。\n程序反编译后整体看上去有点复杂，涉及到很多未知函数。跟踪这些函数，发现大多数没有什么实际用处，感觉像是用来混淆的，暂且忽略它们。核心的判断部分也比较抽象，v7，v8等变量都对应寄存器的值，并不在内存中。缺少关键值，仅凭静态调试梳理不出完整的逻辑。但能看出和异或有关。\n动调也显得繁琐，涉及寄存器的变量还是很多的。（不知道是不是脱壳的原因）\n既然分析不出明确的逻辑，那就猜一下吧。main函数中依然有一系列的数组赋值语句，和上一题非常相似。推测还是对这些数据异或求flag。最开始分析string的时候发现的'The0xGameKey'应该是密钥，循环异或。\n#python from pwn import * src=[0x64, 0x10, 0x22, 0x51, 0x15, 0x22, 0x1A, 0x0F, 0x06, 0x7C, 0x01, 0x18, 0x6C, 0x0A, 0x56, 0x1D, 0x4B, 0x7E, 0x57, 0x08, 0x48, 0x28, 0x51, 0x4C, 0x60, 0x45, 0x07, 0x53, 0x1E, 0x77, 0x4C, 0x5E, 0x5D, 0x7B, 0x53, 0x4F, 0x61, 0x59, 0x07, 0x52, 0x1C, 0x74, 0x07, 0x10] flag=xor(bytes(src),b\u0026#39;The0xGameKey\u0026#39;) print(flag) #b\u0026#39;0xGame{bc7da8b3-396e-c454-bcf0-3806651bbd3f}\u0026#39; Week3 # 代码启示录 # 打开发现是.jar文件，在本地安装JDK来配置Java环境。用反编译器GDA打开文件，一眼flag。\n旋转密码城 # 同上GDA打开，Main类中定义了CaesarPlus() 函数，不难发现是变种的凯撒密码。把密码移位的范围从字母扩大到了ASCII可打印字符的范围。密文在main()主函数中给出。编写python脚本解密：\nenc=\u0026#34;_Iv2\u0026gt;6L424c_4c2\\\\f__5\\\\7fec\\\\da32\\\\3ef2`cgd4b46N\u0026#34; flag=\u0026#39;\u0026#39; for char in enc: index=ord(char) result=index-33-47 if result\u0026lt;0: result+=94 flag+=chr(result+33) print(flag) 变量迷城 # 对Java，android逆向都不太熟悉，拿着反编译代码问了几次GPT。勉强理清了主要的逻辑。\n程序只有一个Main类，直接给了decryptFlag解密函数，能看出来还是循环异或。下面的lambda$static$0函数给出了关于x和y的方程组，可以解出x和y。brand变量也已知是'0xGame'\n#python from z3 import * x,y = Reals(\u0026#39;x y\u0026#39;) s=Solver() s.add(x**2+2*y**2+3*x+4*y == 7384462351178) s.add(5*x**2+6*y**2+7*x+8*y == 22179606057658) print(s.model()) #[y = 1919810, x = 114514] main()的末尾调用解密函数，能看出密钥是x和brand拼接的字符串。但是整个程序并没有给出原始数据，所以不能写脚本解密了。试一下运行程序，但是另一个问题是，程序从头到尾没有任何输入，我们只能等它自己生成flag然后输出。\n结合上网搜索和wp，System.getenv，System.getProperty这两个函数比较关键，提示要创建环境变量和 JVM变量。在命令行中进行设置即可，最后运行jar程序得到flag。\nSystem.getenv()读取的是当前系统环境的环境变量。可以通过 System.getEnv(key) 获取对应环境变量的值。\n通过 System.getProperty(key)获取单个变量值，通过System.getPropertys() 获取所有 JVM 环境变量值。\n启动JVM时，可以通过 -D 设置JVM 环境变量值\n之前一直认为逆向题的flag都是输入到程序的正确字符串，其实是陷入思维定式了。这几周的一些题不是简单地判断输入，而是检查系统的文件或者是变量，还是很打开眼界的。最后还踩了坑：参考wp在cmd敲了命令，结果报错。发现是多了不必要的空格。用powershell试了试发现这段命令不能正常运行。powershell里面set命令不能修改环境变量，要用set-item。\n(cmd.exe) set x=114514 set y=1919810 java -Dbrand=0xGame -jar \u0026#34;C:\\Users\\LENOVO\\Desktop\\变量迷城.jar\u0026#34; 数字幽灵城 # 反编译程序，看到有一个Base58类，说明这道题用到Base58算法。之前对Base64接触比较多，对于Base58不是很了解。于是上网查了一下原理。\nbase58加密与其他base系列不同的是： base64是每6bit位一个映射，base32是每5bit位一个映射 base58不是根据bit位而来，而是直接模58而映射的\n其算法很简单 就是将字符流转成256进制的一个超大数 然后不断的模58 最后得到的结果逆序即是结果\n分析一下decode函数，就是模58的逆运算，能确定是正常的Base58，没有魔改。接下来分析MainActivity类，内部对编码后的flag，也就是变量C0587R.string.encodedFlag进行解码，再和用户输入的flag比对。我们将经过编码的flag提取出来手动解码即可。查找encodedFlag，应该在资源文件里。\nRmC442S4tDMzc3CvzoCx8toKodL8SE8GRQSmz8M84k6g9jG1vVrf3c5TECZR 复制下来拿工具解码即可。大部分在线工具的Base58编码表都是按照比特币的标准，数字在前，之后是大写字母和小写字母。和本题程序的编码表不一样，所以在cyberchef换一下表，进行解码。\n虚构核心 # 用jadx反编译程序，核心的函数都在MainActivity类里面。onClick函数调用checkFlag函数进行判断。继续分析checkFlag函数，发现还需要调用FlagCheker类的checkFlag方法。在反编译的结果里面没找到这个类，推测应该和encrypted.dex有关，但是需要解密出decrypted.dex。程序最后给出了解密函数，和密钥The0xGameKey逐字节异或。\n内置的加密文件不能在jadx里直接打开，也没找到直接导出的方法。将整个.apk文件重命名为.zip后缀的压缩包，解压后在 assets\\目录下找到了encrypted.dex。按照decrypt函数的逻辑手动解密。\n#include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { unsigned char key[] = \u0026#34;The0xGameKey\u0026#34;; FILE *encdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\encrypted.dex\u0026#34;,\u0026#34;rb+\u0026#34;); FILE *decdex = fopen(\u0026#34;C:\\\\Users\\\\LENOVO\\\\Desktop\\\\decrypted.dex\u0026#34;,\u0026#34;wb+\u0026#34;); unsigned char buf[16]; while (!feof(encdex)) { memset(buf,0,16); fread(buf,sizeof(char),12,encdex); for(int i=0; i\u0026lt;12; i++) { buf[i] ^= key[i]; } fwrite(buf,sizeof(char),12,decdex); } fclose(encdex); fclose(decdex); return 0; } 在010Editor中把解密文件最后面多出的一段删掉，之后用jadx反编译即可。在官方wp给的cmd5网站上查出3段md5的明文，最后各部分拼在一起得到flag\nWeek4 # 二进制学徒 # 在线反编译.pyc文件，直接看到flag\n代码悟道者 # 程序是一个.jar文件。反编译后发现main函数比较清晰，调用加密函数并将结果与内置的密文比较。而且给出了加密算法的具体信息即custom Base64，考虑到换表，用自定义解密工具进行解密得到flag。（这道题挺直白的没什么坑）\n回过头来分析（学习）一下程序中的Base64算法：先把输入的明文字符串转换为字节，每三个字节以二进制的形式拼接，再按6bit拆成4个字节。其中对二进制数据的处理没有采用数组，而是直接进行位运算，通过移位后或运算/移位后与运算实现了拼接和截取，很简洁高效。（和NSSRound18 的那道Base64对比了一下，但那题还要交换特定的bit）\n这里移位时右操作数为负，网上搜索发现结果未定义，根据整体功能猜测符号正负不影响移位结果。\n(摘自oi-wiki) 移位运算中如果出现如下情况，则其行为未定义：\n右操作数（即移位数）为负值； 右操作数大于等于左操作数的位数； 内存星旅者 # 首先静态分析，main函数不算复杂。可以看到比较核心的部分，其中包含两个函数 sub_7FF630D51510 和sub_7FF630D51600。二者还有同样的int型参数v6。\n进一步分析，第二个函数可能与生成flag有关。跟踪该函数，发现其内部有点乱，调用了一大堆未知的函数，但是有两个确定的API函数（GetTempPathA，DeleteFileA，可以上网查到功能）。大概猜测flag被写入一个临时文件，而且最后会删除这个文件。\n第一个函数也比较乱，我们的任务是让它的返回值不为0。最好同时能推出v6的值。这个函数需要命令行参数，但是很难从程序反编译的代码中推断该输入什么。复现的时候卡在这里了很久。最后也不去管这些参数了，采用动态调试直接修改寄存器的值，让rdi的最后一位不是零即可。v6的值还不能完全确定，根据官方wp发现其实是函数后面的1897488这个数（其实挺明显的，当时没想到\n同样按照动态调试修改寄存器的思路，F7进入第二个函数内部，把传入参数的ecx寄存器的值改为1897488（0x001CF410）。\n在DeleteFileA之前打一个断点，运行后就直接去找临时文件。在 C:\\Users\\LENOVO\\AppData\\Local\\Temp里找到了刚生成的文件，名字就叫flag。用记事本打开即可。\n指令神使 # 反编译main函数，发现整体逻辑还算清晰。先把unk_一类的数据恢复为字符串，然后分析程序。输入的flag保存在Str中，再对Str1分别调用sub_140001154和sub_140001118函数，最后与Str2比较。\n跟踪这两个函数，第一个就是简单地判断flag的格式。第二个函数进行加密，是题目的关键。不难看出是针对小写字母的rot13。（看到97，26就猜测和字母表有关系，可能是移位密码，比如摩斯之类的，再根据84推偏移量）最后用CyberChef解一下。把前缀补全。\n还注意到题目里的一个细节，反编译后的代码没有Str1的赋值语句，但是直接就对它调用函数。而且储存flag的Str数组长度至少是44，但声明部分 char Str[7];，显然会溢出。于是在栈窗口中查找这两个变量，发现它们是相连的，地址上刚好相差0x7，也就是说Str1储存的是Str溢出的内容。或者说Str1是指向Str+7的指针，这样也能解释为什么Str1能与Str2字符串的格式相对应。\n算法祭司 # 程序放到DIE里面查看是.NET32位程序，用dnSpy进行反编译，分析Main类。最开始对encryptedKey进行逐字节异或解密。之后读取用户输入，利用异或后的key做密钥，encryptedKey作为初始向量对其进行DES加密。\nMain类中直接给出了DES加密后的Base64编码结果。在资源文件中可以找到encryptedKey，进行异或得到密钥。最后写脚本解密DES即可。\n#python import base64 from Crypto.Cipher import DES encryptedkey=\u0026#34;STV\u0026gt;!\u0026#39;+#\u0026#34; key=\u0026#39;\u0026#39; result=\u0026#39;s7/e+JnJbGEdE9j2g3XHxgym+G6Fu/PjJuW80NeMKgemdqaWG9KVM8Tfcc0eRfaA\u0026#39; for c in encryptedkey: key+=chr(ord(c)^ord(\u0026#39;f\u0026#39;)) des=DES.new(key.encode(),DES.MODE_CBC,iv=encryptedkey.encode()) enc=base64.b64decode(result) flag=des.decrypt(enc) print(flag) #b\u0026#39;0xGame{8edf2e65-1cb3-2e1a-b2d1-b54d3d4bddc5}\\x04\\x04\\x04\\x04 ","date":"2024-01-02","externalUrl":null,"permalink":"/writeups/0xgame2023_re/","section":"Writeups","summary":"reverse writeup of 0xgame2023","title":"0xGame2023 Reverse","type":"writeups"},{"content":" Week1 # What\u0026rsquo;s CBC? # 查询资料知CBC是一种分组加密算法。把明文分为等长的几组，用初始化向量对第一组明文进行xor运算，再进行另一种加密得到第一组密文。接下来用第一组密文作为向量加密第二组明文……依次类推。\n注意到xor运算(⊕)的特殊性质： $$ A⊕0=A $$\n$$ A⊕A=0 $$\n如果两数xor后，对结果再xor这两个数中的一个，可以得到其中另一个数。 $$ (A⊕B)⊕B=A⊕(B⊕B)=A⊕0=A $$ 这样一来，解密就方便很多。但是最后的加密函数encrypt()中出现了未知的密钥key，所以首先要解出key。\n从 i ^ key 推测key是一个数而非bytes类型，而且对每一个i都进行了异或运算，理论上只要知道一个i就可以反推出来 (i ^ key ^i) 。我们已知flag的前七位是标准的 '0xGame{' 格式，题中每组明文或密文均为八位，于是再随便补一个字母凑成第一组明文，与iv异或后推key。\nfrom Crypto.Util.number import * f=b\u0026#39;0xGame{a\u0026#39; iv = b\u0026#39;11111111\u0026#39; enc=b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) k=bytes_xor(f,iv) for i in range(8): key=enc[i]^k[i] print(key) \u0026#39;\u0026#39;\u0026#39; 143 143 143 143 143 143 143 222 \u0026#39;\u0026#39;\u0026#39; 忽略掉最后随便找的那个字母(222那个)，能得到key=143。利用xor的性质写出decrypt, Decrypt_CbC两个解密函数(与题目中的两个加密函数相对应，甚至几乎一样)，代入数据解出flag。\nfrom Crypto.Util.number import * def bytes_xor(a,b): a,b=bytes_to_long(a),bytes_to_long(b) return long_to_bytes(a^b) def decrypt(enc,key): result=b\u0026#39;\u0026#39; for i in enc: result += ((i^key)).to_bytes(1,\u0026#39;big\u0026#39;) return result def Decrypt_CbC(enc,iv,key): result=b\u0026#39;\u0026#39; block=[enc[k*8:(k+1)*8] for k in range(len(enc)//8)] for i in block: text = decrypt(i,key) plain = bytes_xor(iv,text) iv=i result += plain return result enc = b\u0026#34;\\x8e\\xc6\\xf9\\xdf\\xd3\\xdb\\xc5\\x8e8q\\x10f\u0026gt;7.5\\x81\\xcc\\xae\\x8d\\x82\\x8f\\x92\\xd9o\u0026#39;D6h8.d\\xd6\\x9a\\xfc\\xdb\\xd3\\xd1\\x97\\x96Q\\x1d{\\\\TV\\x10\\x11\u0026#34; iv = b\u0026#39;11111111\u0026#39; key = 143 flag = Decrypt_CbC(enc,iv,key) print(flag) 密码，觅码，先有*再密 # 把flag切成四份，每份用不同的方法加密。只要判断出每份是如何加密，逐个击破即可。\nc1：Crypto.Util.number中的bytes_to_long()函数，把bytes转化成整数，用对应的long_to_bytes()解密。但还有个小细节，c1输出时变成自身的5次方，我们需要开五次方根还原c1。这里如果用pow(c1,0.2)会有精度的问题，所以采用gmpy2模块的iroot函数\nc2：把bytes中每个字节取二进制并连在一起，解密时等距离拆分还原为bytes\nc3：常见的base64编码，用对应的b64decode()函数\nc4：十六进制与bytes互化\n还有一个要注意的地方是flag内部是汉字，用utf-8解码\nfrom base64 import b64decode from Crypto.Util.number import* from gmpy2 import iroot c1a=2607076237872456265701394408859286660368327415582106508683648834772020887801353062171214554351749058553609022833985773083200356284531601339221590756213276590896143894954053902973407638214851164171968630602313844022016135428560081844499356672695981757804756591891049233334352061975924028218309004551 c2=\u0026#39;10010000100001101110100010100111101000111110010010111010100001101110010010111111101000011110011010000001101011111110011010011000101011111110010110100110100000101110010010111101100101011110011110111100\u0026#39; c3 = b\u0026#39;lueggeeahO+8jOmCo+S5iOW8gOWni+aIkQ==\u0026#39; c4 = \u0026#39;e4bbace79a8443727970746fe68c91e68898e590a72121217d\u0026#39; c1 = iroot(c1a,5) f1 = long_to_bytes(int(c1[0])) f = [c2[i*8:(i+1)*8] for i in range(len(c2)//8)] f2 = \u0026#39;\u0026#39;.join([hex(int(\u0026#39;0b\u0026#39;+k,base=0))[2:] for k in f]) f2=bytes.fromhex(f2) f3 = b64decode(c3) f4=bytes.fromhex(c4) flag=(f1+f2+f3+f4).decode(\u0026#39;utf-8\u0026#39;) print(flag) Take my bag! # 赛后复现补充：背包dp，动态规划，这下真手撕算法了orz\n没看出是什么加密，也没找到标准的解密方式，就当成算法题做了。\n分析一下我的思路：\n题中的加密函数把明文转为二进制并逆序处理，init是给出的一个数表，关键在init[i] * int(m[i]) % n这个表达式。我们知道二进制中只会出现0和1，相应地，表达式也只会出现两种结果：\nint(m[i]) = 0，表达式等于0\nint(m[i]) = 1，init[i] * int(m[i]) % n = init[i] % n，而init中元素已经对n取过模，不会大于n。故表达式等于init[i]\n即密文c是列表init中特定项的和，这些项的索引与得到的逆序二进制数中“1”对应。解密的思路很直接，遍历所有元素并找出和刚好为c的项，就可以反推二进制数，乃至flag。\n说起来容易，但程序如果这么实现，时间复杂度还是很高的。对思路重新优化，我们可以先把c视为若干项的和，在init中逐一找到各项并从c中减去。如果这一过程能完全进行那么c会被减到0，此时这些被减去的项就是我们要求的。按这个思路编写脚本，选取 [ c减去init某一项的剩余值，在过程不成立时表示回溯情况的偏移量，被减项的索引 ] 作为关键数据保存在栈（列表memory）中，最后剩余值=0时就可以从栈中得到各所求项的索引。（一开始没发现，后来flag交了之后想起来这有点像深度优先搜索算法?）\n接下来按照索引求出二进制数，逆序还原，再转为bytes就看到flag了。\nfrom Crypto.Util.number import * w=16221818045491479713 n=9702074289348763131102174377899883904548584105641045150269763589431293826913348632496775173099776917930517270317586740686008539085898910110442820776001061 c=4795969289572314590787467990865205548430190921556722879891721107719262822789483863742356553249935437004378475661668768893462652103739250038700528111 init = [w*pow(3, i) % n for i in range(512)] memory = [] #记录上一次操作时的[剩余值,偏移量,在init中对应的索引位置] def find(p):\t#找到在init中小于给定数p的最大元素索引 for i in range(512): if init[i]\u0026lt;=p and init[i+1]\u0026gt;p: return i if p==0: return 0 def forward(num,move,index):#保存上一次操作数据，更新偏移量=0，计算剩余值 datas=[num,move,index] memory.append(datas) move=0 return num - init[index-move] num,move,index=c,0, find(c)#初始化 while True: if num==0: break elif (num - init[index - move]\u0026gt;= init[0] or num == init[index - move]) and move\u0026lt;=index: num=forward(num,move, index) index=find(num) else: num,move,index=memory[-1] move+=1 memory.pop()\t#回溯到上一次操作，向左偏移+1 m=[\u0026#39;0\u0026#39;]*512 for k in memory: m[k[2]]=\u0026#39;1\u0026#39; m=\u0026#39;\u0026#39;.join(m)[::-1] flag=long_to_bytes(int(m,2)) print(flag) BabyRSA # RSA在密码学领域是常见的非对称加密算法，破解的难度在于从公钥推出私钥，核心是超大整数的质因数分解。\n在一般的RSA加密中，m表示明文，n是一个超大整数，e为与φ(n)互素的任意整数，(e,n)作为公钥加密明文，得到密文c。解密需要私钥(d,n)，其中d是e关于模φ(n)的乘法逆元。要从密文c中解出明文m，只需要求出n的欧拉函数，为此需要将n质因数分解。\n不同于传统的n=p*q这种只有两个质因数，本题的getN()函数直接给出了16个大质数相乘的超大数n，正常的分解因数算法肯定不好使了。在查找资料的过程中发现了名叫yafu的工具，顺利的分解了n。果然是整齐的16个质数\n这样一来，就可以利用欧拉函数的性质，把各个因数减一再全部相乘，求出φ(n)，进而得到密钥去解密\n还要注意求得的结果是m*mask，要再除以mask并用long_to_bytes()还原为字符串，才能得到正确的flag。\nfrom Crypto.Util.number import * import gmpy2 n=93099494899964317992000886585964221136368777219322402558083737546844067074234332564205970300159140111778084916162471993849233358306940868232157447540597 e = 65537 c=54352122428332145724828674757308827564883974087400720449151348825082737474080849774814293027988784740602148317713402758353653028988960687525211635107801 mask = 54257528450885974256117108479579183871895740052660152544049844968621224899247 factors=[3479527847,2864469667,3561068417,2770441151, 4134768233,3281340371,3111632101,2821163021, 3978177241,3267547559,2329990801,3162958289, 2995527113,4160088337,2732757047,2436711469] phi=1 for p in factors: phi *= (p-1) #欧拉函数 d=gmpy2.invert(e,phi) #通过乘法逆元找到私钥d m=pow(c,d,n) #解密 result=gmpy2.c_div(m,mask) flag=long_to_bytes(result) print(flag) 猜谜 # 已知部分明文攻击\n题目还蛮善良的，给出加密enc()函数的同时还送上了解密的dec()函数，对密文进行第一次解密如下:\nc = b\u0026#39;IPxYIYPYXPAn3nXX3IXA3YIAPn3xAYnYnPIIPAYYIA3nxxInXAYnIPAIxnXYYYIXIIPAXn3XYXIYAA3AXnx=\u0026#39; print(dec(c)) #b\u0026#39;gWM\\x84u\\xe4N\\x05x=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\1\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; 然而第二层加密就不好办了，又又出现了未知的key。题目的意思是把key猜出来?\n分析代码，i%7 这段给了启示。无论len(key)有多大，只有前7位能发挥作用。不妨猜key就是7位的bytes。恰好我们知道flag的前七位是标准格式 '0xGame{' ，再利用xor运算的性质反推key成功。同样用xor解出flag\nkey=b\u0026#39;\u0026#39; flag=\u0026#39;\u0026#39; flagformat=b\u0026#39;0xGame{\u0026#39; text=b\u0026#39;gWM\\x84u\\xe4N\\x05X=a}\\xe5\\xb2-a}\\x9f\\x82\\xf6C\\xde[\\\\l\\x89\\xd4\\xb1\\xd0\\x10\\x9f\u0026#39; for i in range(7): key += (text[i] ^ (flagformat[i]+i)).to_bytes(1,\u0026#39;big\u0026#39;) for j in range(len(text)): flag += chr((text[j] ^ key[j%7])-j) print(flag) Vigenere # 完全没见过的加密方式，百度搜索给出的解释是“使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码的一种简单形式”。\n直接找在线解密工具，摸索后发现解密需要密钥，而且只会对字母进行改变。查阅资料发现以下要点：\n1.明文中的所有字母都在字母表上向后偏移某个数目后被替换成密文，偏移量与密钥相对应。\n2.密钥若长度不够可以继续重复。\n现在只需要得到密钥就可以破解flag，题目没有给出密钥的任何信息（也可以暴力破解？），但结合密文：0dGmqk{79ap4i0522g0a67m6i196he52357q60f}，猜测0dGmqk与0xGame 相对应，分析各字母前后的偏移量：6，0，12，4，6。对应g,a,m,e,g ,考虑到密钥的可重复性，取game作为密钥（看起来很靠谱），放到网站解密得到flag。\nWeek2 # EzLFSR # LFSR，又是很陌生的算法。\n查了好几天资料，大概理解的差不多了。作为流密码的关键成分，LSFR也就是线性反馈移位寄存器，能够不断输出随机而长周期的序列。由此它可以作为流密钥产生器的线性驱动部分。寄存器的容量有限，当其中的数据整体左(右)移一位时，最左(右)面的数会溢出（输出）而最右(左)面会留出空位。为了有持续的输出，LSFR通过某种线性反馈函数计算出一个数补到空位，依次循环，源源不断。\n题中给出了初始状态和256位输出，根据移位寄存器的原理，我们可以用initState[i:]+outputState[:i]来表示第i组状态，同时给出计算补充右边空位数字的方法lfsr()，但其中mask未知。即不完全知道LFSR的反馈函数，但已知其级数n=128。而且明文中不包括0xGame{}，不能取巧反推反馈函数。\n注意到反馈函数中有异或运算，state和mask中元素只能取0或1。可以把mask[i]理解为寄存器第i位的数是否参与到异或运算中（抽头）。用 \\(x_i\\) 表示mask[i]， \\(k_i\\) 至 \\(k_{i+127}\\) 表示第i组状态下寄存器各位数字，从数学角度可得到异或方程组： $$ \\begin{cases} \\quad k_{1}x_1\\oplus k_{2}x_2 \\oplus\\cdots\\oplus k_{128}x_{128} = k_{129} \\\\ \\quad k_{2}x_1\\oplus k_{3}x_2 \\oplus\\cdots\\oplus k_{129}x_{128} = k_{130} \\\\ \\quad k_{3}x_1\\oplus k_{4}x_2 \\oplus\\cdots\\oplus k_{130}x_{128} = k_{131} \\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots \\\\ k_{128}x_1\\oplus k_{129}x_2 \\oplus\\cdots\\oplus k_{255}x_{128} = k_{256} \\\\ \\end{cases} $$ 由于异或有“半加”的性质，用线性(加法)方程组类比异或方程组，上式等价于： $$ \\begin{cases} \\quad k_{1}x_1+ k_{2}x_2 +\\cdots+ k_{128}x_{128} \\equiv k_{129}(\\bmod2)\\\\ \\quad k_{2}x_1+ k_{3}x_2 +\\cdots+ k_{129}x_{128} \\equiv k_{130}(\\bmod2)\\\\ \\quad k_{3}x_1+ k_{4}x_2 +\\cdots+ k_{130}x_{128} \\equiv k_{131}(\\bmod2)\\\\ \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\enspace\\cdots\\\\ k_{128}x_1+ k_{129}x_2 +\\cdots+ k_{255}x_{128} \\equiv k_{256}(\\bmod2)\\\\ \\end{cases} $$ 矩阵表示为： $$ \\begin{bmatrix} k_1 \u0026amp; k_2 \u0026amp; k_3 \u0026amp; \\cdots \u0026amp; k_{128}\\\\ k_2 \u0026amp; k_3 \u0026amp; k_4 \u0026amp; \\cdots \u0026amp; k_{129}\\\\ k_3 \u0026amp; k_4 \u0026amp; k_5 \u0026amp; \\cdots \u0026amp; k_{130}\\\\ \\vdots \u0026amp; \\vdots \u0026amp; \\vdots \u0026amp; \\ddots \u0026amp; \\vdots\\\\ k_{128} \u0026amp; k_{129} \u0026amp; k_{130} \u0026amp; \\cdots \u0026amp; k_{255} \\end{bmatrix}X=\\begin{bmatrix} k_{129}\\\\ k_{130}\\\\ k_{131}\\\\ \\vdots\\\\ k_{256}\\\\ \\end{bmatrix} $$ 借助软件Sage函数solve_right()，在有限环Zmod(2)中求解矩阵方程得到mask，转换为secret就可以得到flag\n#SageMath from Crypto.Util.number import * def string2bits(s): return [int(b) for b in s] def bits2string(bs): s = [str(b) for b in bs] return \u0026#39;\u0026#39;.join(s) initState = [0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0] outputState = \u0026#39;1101111111011101100001000011111101001000111000110100010011110111010011100110100100111001101010110110101110000011110101000110010010000011111111001111000110111001100111101110010100100001101001111110001010000100111101011011100010000000100000100000100111010110\u0026#39; outputState = string2bits(outputState) States_Array=[initState[i:]+outputState[:i] for i in range(128)] states=matrix(Zmod(2),States_Array) output=matrix(Zmod(2),outputState[:128]) output=output.transpose() mask=states.solve_right(output) mask=[i[0] for i in (mask)] secret=bits2string(mask) secret=long_to_bytes(int(secret,2)) flag = \u0026#39;0xGame{\u0026#39;+secret.decode(\u0026#39;utf-8\u0026#39;)+\u0026#39;}\u0026#39; print(flag) 中间的那个人 # 题目模拟了Alice和Bob两人的加密通信场景，二人使用对称加密的CBC算法。因为未事先商量好密钥，所以加密一方要想办法把密文和特殊处理的密钥一并发送给对方，这里涉及DH密钥交换算法。我们作为“中间的那个人”，通过各种方式截获了二人通信的数据如下： $$ P(A)\\equiv Alice\\equiv g^A (\\bmod\\ p) $$\n$$ P(B)\\equiv Bob\\equiv g^B(\\bmod\\ p) $$\n$$ key\\equiv P(A)^B\\equiv P(B)^A\\equiv g^{AB}(\\bmod\\ p) $$\n由数学关系我们可反推：\\(A\\equiv \\log_gP(A)\\ (\\bmod \\ p)\\) 和\\(B\\equiv \\log_gP(B)\\ \\ (\\bmod \\ p)\\)。即只需要计算其中一个离散对数，得到A或B的值，就可以计算出密钥key。\n借助SageMath计算mod 2下的离散对数：\n#SageMath p=250858685680234165065801734515633434653 G=GF(p) g=G(2) Bob=G(33067794433420687511728239091450927373) B = discrete_log(Bob,g) 再用python计算key，用题中给出的密文和初始化向量 $iv$ 解密，得到flag（其实可以放在Sage里面一步到位，但是我的Sage里面Crypto.Cipher库出了点小问题，就分开写了）\nfrom Crypto.Util.number import * from Crypto.Cipher import AES from hashlib import sha256 g=2 p= 250858685680234165065801734515633434653 Bob= 33067794433420687511728239091450927373 Alice=235866450680721760403251513646370485539 enc=b\u0026#39;s\\x04\\xbc\\x8bT6\\x846\\xd9\\xd6\\x83 y\\xaah\\xde@\\xc9\\x17\\xdc\\x04v\\x18\\xef\\xcf\\xef\\xc5\\xfd|\\x0e\\xca\\n\\xbd#\\x94{\\x8e[.\\xe8\\xe1GU\\xfa?\\xda\\x11w\u0026#39; iv = b\u0026#34;0xGame0xGameGAME\u0026#34; B = 1620639479 key = pow(Alice,B,p) key = sha256(long_to_bytes(key)).digest() aes = AES.new(key, AES.MODE_CBC, iv) flag = aes.decrypt(enc) print(flag) Week3 # EzECC # ECC 即 EllipseCurve Cryptography，是一种基于椭圆曲线的公钥密码。在数学上椭圆曲线用 $$ y^2+axy+by=x^3+cx^2+dx+e $$ 来表示，而密码学中常取\\(a=b=c=0\\),得到椭圆曲线的一般形式 $$ y^2=x^3+dx+e $$ 密码学椭圆曲线一般定义在有限域GF(p)上。定义了二元运算：点与点的加法“ + ”，包括不同点相加以及点的自加（数乘）两种情况，与题中给出的 add() 函数和 mul() 函数相对应。同时，椭圆曲线上所有点（包括无穷远点\\(O\\)）与“ + ”运算构成abel群，满足封闭性，有限次运算后的结果依然在曲线上。\n不同于数学中光滑连续的曲线，GF(p)上的椭圆曲线只包含离散而有限的整数点以及特殊的无穷远点，点的总数称为曲线的阶\\(n\\) ,若用 \\(G\\) 表示该曲线的生成元，则满足 \\(nG = O\\)。\n曲线上两点满足 \\(Q=mP\\) ,则称 \\(m\\) 为椭圆曲线的离散对数，即 \\(m=log_PQ\\) 。ECC密码体系建立在离散对数求解难题的基础上。\n根据以上性质，我们可以分析ECC的加密过程：首先接受方确定私钥 \\(k\\) 并选择椭圆曲线E(a,b)上基点 \\(G\\) ，计算出公钥 \\(K=kG\\)。将除私钥外的信息公开给发送方。发送方将明文编码成椭圆曲线上一点 \\(M\\)（但本题并没有这样做），随机选一个整数 \\(r\\) 计算出密文｛\\(M+rK,rG\\)｝即题中的 {C_1,C_2}。解密的思路比较直接，注意到数学关系 $$ \\begin{cases} C_1=M+rK=M+rkG\\\\ C_2=rG\\\\ C_1-kC_2=M+rkG-krG=M \\end{cases} $$ 只要求出私钥 \\(k=log_GK\\) 就可以求出 \\(M\\)，难题在于求解离散对数，还好SageMath有内置的求解函数。下图是利用discrete_log()函数求出 \\(r\\) 和 \\(k\\) 的过程：\n另外还有一种思路是求出 \\(r=log_GC_2\\) ，再根据\\(M=C_1-rK\\)求出明文，同样关键在离散对数。但从上图不难发现 \\(r\\) 是一个比较小的数，也可以爆破 \\(r\\) 来规避这一难题。（好像有师傅是这么做的）\n求出 \\(k\\) 或 \\(r\\) 离flag就不远了。脚本求解：\nfrom Crypto.Util.number import * q=1139075593950729137191297 a=930515656721155210883162 b=631258792856205568553568 G = (641322496020493855620384, 437819621961768591577606) K = (781988559490437792081406, 76709224526706154630278) C_1=(55568609433135042994738, 626496338010773913984218) C_2=(508425841918584868754821, 816040882076938893064041) def add(P,Q): if P[0] != Q[0] and P[1] != Q[1]: t = ((Q[1]-P[1]) * inverse(Q[0]-P[0],q)) %q else: t = ((3*P[0]*P[0]+a) * inverse(2*P[1],q))%q x3 = t*t - P[0] - Q[0] y3 = t*(P[0] - x3) - P[1] return (x3%q, y3%q) def mul(t, A, B=0): if not t: return B return mul(t//2, add(A,A), B if not t\u0026amp;1 else add(B,A) if B else A) r=10077 k=12515237792257199894 h=mul(r,K) H=(h[0],q-h[1]) m1,m2=add(C_1,H) flag = b\u0026#39;0xGame{\u0026#39; + long_to_bytes(m1)+long_to_bytes(m2) + b\u0026#39;}\u0026#39; print(flag.decode(\u0026#39;utf8\u0026#39;)) LLL-FirstBlood # 初识LLL一头雾水，找了点格密码的资料看了看。实话说也没有理解透，但是发现题里给的MakeMask()函数很有意思。它会生成一个有限域GF(p)内的n阶方阵，各个位置的元素完全随机，但方阵的行列式恒为1。资料中称这样的矩阵为“幺模矩阵”，同时提到了格的一个性质：对于格的一组基 \\(v_1,v_2,\\cdots,v_n\\) 可以进行如下三种变换，得到新的一组基与原来的基等价。\n​\t1.交换若干个基向量的顺序\n​\t2.对基向量取负 \\(v_i\\rightarrow-v_i\\)\n​\t3.把某一基向量的k倍加到另一基向量上 \\(v_i+kv_j\\)\n如果把基表示成矩阵 \\(B_i\\) 的形式，其中列向量为基向量，那么以上三种对基的变换可以写成 \\(B_iU\\) ，这里 \\(U\\) 为幺模矩阵。\n换句话说，我们有基 \\(B_1\\)，而且 \\(B_2=B_1U\\) ，此时 \\(B_1\\) 与 \\(B_2\\) 等价，都会生成相同的格。\n题中M是第一行为编码后的密文、其余位置是随机数的4阶方阵，A是随机生成的幺模矩阵。C是M与A相乘的结果。把M看成格，与幺模矩阵A相乘后得到的格C与M等价，即\\( M \\sim C\\)。根据这种等价关系，我们尝试对C进行格基规约（LLL）化简为M。\n这里设使用LLL算法得到的格基为K，其第一行的四个元素即为被切成四份的flag，用long_to_bytes() 转化一下在拼一起就好了。\n（PS：其实不太确定 C.LLL() 得到的到底是不是M，毕竟只是试了下就出flag了，第一行肯定没问题，但是时间很紧其他行没有验证）\n#Sage from Crypto.Util.number import * p=198880159035681668071031460916089145469 c=[[1528140902799730745476264672501768332416990282355490479242339131918301176698899635154781328839496210200676497333428,2081687444435007467807250373278513114045272585243815458840083487459795021302180077490134099644993120009567147202772,3080873409460299046339495750746632185307246572817534784703936044874106809413620470006445984962733721029566440253675,3491734341995174183626991907292607070252197520631412767989879432598743851171175369180080355977574296558734415823458], [2359409535809048127331244699867147546817134802610067329431135227991488324148374065940238308147500809599395748756798,3191196199160821446351036460385791985682645040446022512790815348810555748825420237291839170774872264097466183208742,4665346530155386457242345394284286198347336281451530670818113876767736288089400119492317775648206643242839430899283,5369350746042850276067380638571565496087948799720968959426256192923852197959381101839484196445995828389461004495917], [1641407111066265429602929560264443103285908072677065498760570514577412905392260182334706635555256537745902283191251,2190536173399177167068153351271988931232272884028569669242062395087922275021628334797729266560930040116807133977244,3127556759140845426132305699421707182108351516931881411928719802847628408656887897596425133523782526561471050447359,3707239956529200159380870618471703921011276020439315706352183576289925263316580408968092016782483770373121972835410], [9883814543195849013523934427451407019514807606993414569626142656857168165339,13190422499129347541373922929251088892868361241120937213742340947017395215646,18832738552342488056498211782604832513006649329982003661701684946590064734701,22323329751908690611034666068697427811613727429398087082295754189068333861152]] C=Matrix(ZZ,c) K=C.LLL() flag=b\u0026#39;\u0026#39; for i in K[0]: flag+=long_to_bytes(-i) print(flag) LLL-SecondBlood # 题中通过encrypt()函数向noise_ 和 mask_ 两个列表各添加4个大质数，并将(mask*m + noise) % p 的结果添加到列表 c_ 中。m是我们要找出的明文。理论上我们只要在有限域GF(q)中解出至少一组形如 mask_[i] * m+noise_[i]=c_[i] 的方程就可以求出m。但本题最大的困难在于 noise 完全未知。注意到mask是511位的超大质数，再与m相乘的结果必然更大，而noise只是50位的质数，显然mask*m 远大于 noise ，我们可以把问题转化为已知高位的HNP问题，进一步，HNP问题可以在格上转化为CVP问题。\n由于对格理论了解的不够充分，解题时借鉴了CVP - CTF Wiki (ctf-wiki.org)上的部分思路和方法。 令向量 \\(M\\)=mask ,\\(C\\)=c_ , 数量阵\\(P=pE\\) ,参数\\(l\\approx log^\\frac{1}{2}p\\) (这里没弄懂底数是几，我按lg算的)。我们构造用如下矩阵表示的格 $$ \\begin{bmatrix} P\u0026amp;0\\\\ M\u0026amp;\\frac{1}{2^{l+1}} \\end{bmatrix} $$ 目标是在这个格上找到与已知向量 \\(C\\) 最近的向量 \\(C\u0026rsquo;\\)，恰好这里 \\(C\u0026rsquo;=mM\\) ，我们就可以求出m。\n利用最近平面算法（Babai\u0026rsquo;s nearest plane algorithm）求解CVP，得到flag，脚本如下（借鉴了一点点）\n#Sage from math import * from Crypto.Util.number import * q = 9342426601783650861020119568565656404715236059903009041977149778244153930435908024696666887269890479558473622355346816236972767736577737332173213722012253 mask = [6237128445236992920577225644858662677575951126467888858782461334057970069468925833844231116647406833999142659751374620280213290736114576089069396331226747, 6368031389213953889417545256750169233725975229197446803885029159767701479445576860704561593200907482372690851152126782391126462547524526631934408981070841, 5106473460982791188578285397420642137630347289252852045044021197988607082777231839839730169682158507822078412449827976663385282021916120837408192506341443, 6318090842950331228033349517542810123596316850353637421587264886413877142612686177796023049304908696413386218992511112752788640732410845589679820003047667] c_ = [3823539664720029027586933152478492780438595004453489251844133830947165342839393878831914879334660250621422877333022321117120398528430519794109624186204492, 1721659645750224819953244995460589691120672649732560768435214608167861246790136217219349234604724148039910656573436663379375048145045443527267790379816425, 668633520079344839648950502380059311916108468801009386138810324259146523323704014491547148973835774917331333581475920804677395949854411894556705238578896, 497860586379981076499130281851986010889356253371192266267220334713415782402939318483926418213877341511996918189750595755372560345085899109305344338944066] def babai(A, w): A = A.LLL(delta=0.75) G = A.gram_schmidt()[0] t = w for i in reversed(range(A.nrows())): c = ((t * G[i]) / (G[i] * G[i])).round() t -= A[i] * c return w - t M = Matrix(QQ, 5, 5) for i in range(4): M[i, i] = q M[4, i] = mask[i] M[4, 4] = 1 / (2 ** (l + 1)) closest = babai(M, vector(c_ + [0])) m=(closest[-1] * (2 ** (l + 1))) % q flag=long_to_bytes(404417766109752774365993311026206252937822359426120081323087457724287886115277329019989616964477) print(flag) Week4 # Normal ECC # 又是一道ECC题，根据上周解题经验直接求 \\(k=log_GK\\)，但是数太大了，尝试跑了几个小时sage毫无作用。\n暴力求 \\(k\\) 肯定是行不通的，这里只好换种思路。Hint中给出了 ord(E)==p 这样一个很特殊的条件，据此上网查照了若干资料，发现具有这种特殊性质的曲线有一个专属名称 “异常曲线” 即 anomalous curve，还有专门的攻击方法 “Smart‘s Attack ” 来求解离散对数。\n将 \\(P, Q\\) 扩充成 \\(E(Q_p)\\) 下的点 \\(P^′, Q^′\\)。原来的离散对数是找到 \\(n\\) 使得 \\(Q=nP\\) 且 \\(P,Q \\in E(F_p) \\)，现在只需先把 \\(P, Q\\) 拓展成 \\(P^′, Q^′\\)，然后找到 \\(n\\) 满足 \\(Q^′−nP^′=O^′\\)，其中 \\(O^′\\)是某个非整数点。\n找到函数 \\(ϕ:\\mathbb{Q}→\\mathbb{Q}\\) 使得 \\(Q=nP⇔ϕ(Q)=nϕ(P)\\)。把椭圆曲线的加法「转换」成正常的加法，也就使离散对数问题变成简单的除法： $$ n=\\frac{ϕ(P)}{ϕ(Q)} $$\n为了套上 \\(ϕ\\)，我们把式子乘上 \\(p\\) 倍，得到 \\(pO^′=pQ^′−npP^′\\)。套上 \\(ϕ\\) 函数得到: $$ n≡\\frac{ϕ(pQ^′)}{ϕ(pP^′)}(\\bmod\\ p) $$\n这里引用了资料（Smart\u0026rsquo;s Attack | Utaha\u0026rsquo;s CTF Note）中的一些分析，也比较幸运地找到了smart’s attack的代码。直接放到脚本里求出 \\(k\\)，再按常规思路解密 \\(M\\) 即可。\n完整的SageMath代码如下：\n#sage from hashlib import md5 def MD5(m):return md5(str(m).encode()).hexdigest() def SmartAttack(P,Q,p): E = P.curve() Eqp = EllipticCurve(Qp(p, 2), [ ZZ(t) + randint(0,p)*p for t in E.a_invariants() ]) P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True) for P_Qp in P_Qps: if GF(p)(P_Qp.xy()[1]) == P.xy()[1]: break Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True) for Q_Qp in Q_Qps: if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]: break p_times_P = p*P_Qp p_times_Q = p*Q_Qp x_P,y_P = p_times_P.xy() x_Q,y_Q = p_times_Q.xy() phi_P = -(x_P/y_P) phi_Q = -(x_Q/y_Q) k = phi_Q/phi_P return ZZ(k) p=11093300438765357787693823122068501933326829181518693650897090781749379503427651954028543076247583697669597230934286751428880673539155279232304301123931419 a=490963434153515882934487973185142842357175523008183292296815140698999054658777820556076794490414610737654365807063916602037816955706321036900113929329671 b=7668542654793784988436499086739239442915170287346121645884096222948338279165302213440060079141960679678526016348025029558335977042712382611197995002316466 E=EllipticCurve(GF(p),[a,b]) G=E(4045939664332192284605924284905750194599514115248885617006435833400516258314135019849306107002566248677228498859069119557284134574413164612914441502516162, 2847794627838984866808853730797794758944159239755903652092146137932959816137006954045318821531984715562135134681256836794735388745354065994745661832926404) K=E(9857925495630886472871072848615069766635115253576843197716242339068269151167072057478472997523547299286363591371734837904400286993818976404285783613138603, 9981865329938877904579306200429599690480093951555010258809210740458120586507638100468722807717390033784290215217185921690103757911870933497240578867679716) C1=E(4349662787973529188741615503085571493571434812105745603868205005885464592782536198234863020839759214118594741734453731681116610298272107088387481605173124, 10835708302355425798729392993451337162773253000440566333611610633234929294159743316615308778168947697567386109223430056006489876900001115634567822674333770) C2=E(5193866657417498376737132473732737330916570240569047910293144235752602489388092937375844109374780050061859498276712695321973801207620914447727053101524592, 684299154840371832195648774293174908478389728255128448106858267664482339440737099810868633906297465450436417091302739473407943955874648486647511119341978) assert E.order() == p k=SmartAttack(G,K,p) M=C1-k*C2 flag=\u0026#39;0xGame{\u0026#39;+MD5( M.xy()[0] )+\u0026#39;}\u0026#39; print(flag) ","date":"2024-01-01","externalUrl":null,"permalink":"/writeups/0xgame2023_crypto/","section":"Writeups","summary":"crypto writeup of 0xgame2023","title":"0xGame2023 Crypto","type":"writeups"},{"content":"An ordinary CTFer mainly interested in Reverse.\nqaq\n","date":"2024-01-01","externalUrl":null,"permalink":"/about/","section":"1n1t-Flare Blog","summary":"","title":"About","type":"page"},{"content":"","date":"2024-01-01","externalUrl":null,"permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]